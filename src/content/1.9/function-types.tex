% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{こ}{れまで}私は関数型の意味を大まかに説明してきました。関数型は他の型とは異なります。

例えば\code{Integer}を考えてみましょう。これは単に整数の集合です。
\code{Bool}は二要素集合です。しかし、関数型 $a\to b$ はそれ以上のものです。それは、対象 $a$ と $b$ の間の射の集合です。任意の圏の二つの対象間の射の集合はホム集合と呼ばれます。圏 $\Set$ では、すべてのホム集合が自身が属する同じ圏の対象であることがよくあります  --- 結局のところ、それは\emph{集合}ですから。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/set-hom-set.jpg}
  \caption{Set内のホム集合はただの集合です}
\end{figure}

\noindent
他の圏ではホム集合は圏外部のものです。それらは\emph{外部}ホム集合とさえ呼ばれます。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/hom-set.jpg}
  \caption{圏C内のホム集合は外部集合です}
\end{figure}

\noindent
関数型を特別なものにしているのは、$\Set$ 圏の自己参照的な性質です。しかし、少なくともいくつかの圏では、ホム集合を表す対象を構成する方法があります。そのような対象は\newterm{内部}ホム集合と呼ばれます。

\section{普遍構成}

一時的に関数型が集合であるということを忘れて、関数型、または一般的に内部ホム集合を最初から構成してみましょう。通常のように、$\Set$圏から手がかりを得ますが、集合の特性を避けるように注意して、構成が他の圏にも自動的に適用されるようにします。

関数型は、引数型と結果型との関係のために、複合型と見なされるかもしれません。私たちはすでに対象間の関係を含む複合型の構成を見てきました。普遍構成を使って\hyperref[products-and-coproducts]{積型と余積型}を定義しました。同じトリックを使って関数型を定義することができます。我々は、構成している関数型、引数型、および結果型の3つの対象を含むパターンが必要です。

これらの3つの型を接続する明白なパターンは、\newterm{関数適用}または\newterm{評価}と呼ばれます。関数型の候補としましょう $z$ (圏$\Set$ にいない場合、これは他のどの対象とも同様に単なる対象です) と引数型 $a$ (対象)、適用はこのペアを結果型 $b$ (対象) にマッピングします。我々は3つの対象、そのうち2つは固定されています (引数型と結果型を表すもの)。

また、我々は適用というマッピングを持っています。対象の内部を見ることができれば、$z$の関数 $f$ (要素) を$a$の引数$x$ (要素) とペアにし、それを$f x$ ($f$による$x$の適用、$b$の要素) にマッピングすることができます。

\begin{figure}[H]
  \centering\includegraphics[width=0.35\textwidth]{images/functionset.jpg}
  \caption{Setでは関数の集合 $z$ から関数 $f$ を選び、集合 (型) $a$ から引数 $x$ を選ぶことができます。集合 (型) $b$ における要素 $f x$ を得ます。}
\end{figure}

\noindent
しかし、個々のペア $(f, x)$ を扱う代わりに、関数型 $z$ と引数型 $a$ の全\emph{積}について話すこともできます。積 $z\times{}a$ は対象であり、$b$ への適用射として、$g$ という射を選ぶことができます。$\Set$ では、$g$ はすべてのペア $(f, x)$ を $f x$ にマッピングする関数です。

パターンは次のようになります: 2つの対象 $z$ と$a$ の積が、$g$ という射によって別の対象 $b$ に接続されています。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/functionpattern.jpg}
  \caption{普遍構成の出発点となる対象と射のパターン}
\end{figure}

\noindent
このパターンは、普遍構成を使って関数型を特定するのに十分具体的ですか？すべての圏ではありません。しかし私たちが興味を持っている圏ではそうです。別の質問として、まず積を定義せずに関数対象を定義することは可能でしょうか？すべての対象のペアに対して積が存在しない圏もあります。答えはいいえです: 積型がなければ、関数型は存在しません。指数について話すとき、これについて後で戻ってきます。

普遍構成を見直しましょう。我々は対象と射のパターンから始めます。それが我々の漠然としたクエリであり、通常はたくさんのヒットを生み出します。特に$\Set$では、ほぼすべてが何かに接続されています。任意の対象$z$を取り、$a$とその積を形成し、$b$への関数が存在します ($b$が空集合でない限り)。

それが私たちが秘密兵器を適用するときです: ランキング。これは通常、候補の対象間に何らかの方法で因数分解する一意のマッピングがあることを要求することによって行われます。この場合、$z \times a$ から $b$ への射 $g$ を持つ$z$と、$g$を介して$g'$の適用が因数分解されるような方法で$z$へ一意にマップされる$z'$がある場合、$z$と$g$が他の$z'$とその独自の適用$g'$よりも\emph{優れている}と判断します。  (ヒント: 写真を見ながらこの文を読んでください。) 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/functionranking.jpg}
  \caption{関数対象の候補間のランキングを確立する}
\end{figure}

\noindent
ここでトリッキーな部分です、そしてこの特定の普遍構成を今まで延期した主な理由です。射 $h \Colon z'\to z$ を与えられた場合、$a$で交差する$z'$と$z$の両方を含む図を閉じたいと思います。$z'$から$z$へのマッピング$h$が与えられたとき、私たちは$z' \times a$から$z \times a$へのマッピングが必要です。そして今、\hyperref[functoriality]{積の関手性}を議論した後、それを行う方法を知っています。積自体が関手 (より正確にはエンド・バイ・関手) であるため、射のペアを持ち上げることが可能です。つまり、対象だけでなく射の積も定義できます。

積の第二コンポーネント$z' \times a$を触れずに、射のペア$(h, \id)$を持ち上げるつもりです。ここで$\id$は$a$上の恒等写像です。

従って、$g$の適用を別の適用$g'$からどのように因数分解できるかが分かります。
\[g' = g \circ (h \times \id)\]
ここでの鍵は射上の積の作用です。

普遍構成の第三部分は、普遍的に最も優れた対象を選択することです。この対象を$a \Rightarrow b$と呼びましょう (これを一つの対象に対する象徴的な名前として考えてください、Haskellの型クラス制約と混同しないでください ---後でそれを名付けるさまざまな方法について話し合います)。この対象は、$(a \Rightarrow b) \times a$から$b$への適用 ---$\mathit{eval}$と呼ばれる射---を持っています。対象\code{$a \Rightarrow b$}が最も優れている場合、その適用射$g$が$\mathit{eval}$を介して因数分解されるように、他のすべての候補の関数対象を一意にそれにマッピングすることができます。この対象は、私たちのランキングによると、他のどの対象よりも優れています。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/universalfunctionobject.jpg}
  \caption{普遍関数対象の定義。これは上の図と同じですが、今では対象 $a \Rightarrow b$ が\emph{普遍}です。}
\end{figure}

\noindent
正式には:

\begin{longtable}[]{@{}l@{}}
  \toprule
  \begin{minipage}[t]{0.97\columnwidth}\raggedright\strut
    $a$ から $b$ への\emph{関数対象}は、対象
    $a \Rightarrow b$ と射
    \[\mathit{eval} \Colon ((a \Rightarrow b) \times a) \to b\]
    であり、それによって他の任意の対象 $z$ には射
    \[g \Colon z \times a \to b\]
    が存在し、それを介して $\mathit{eval}$ を因数分解する唯一の射
    \[h \Colon z \to (a \Rightarrow b)\]
    が存在します。
  \end{minipage}\tabularnewline
  \bottomrule
\end{longtable}

\noindent
もちろん、任意の圏の任意の対象のペア $a$ と $b$ に対して、そのような対象 $a \Rightarrow b$ が存在するとは限りません。
しかし、$\Set$ では常に存在します。さらに、$\Set$では、この対象はホム集合 $\Set(a, b)$ と同型です。

これが、Haskellでは関数型 \code{a -> b} を圏論的な関数対象 $a \Rightarrow b$ として解釈する理由です。

\section{Curry化}

関数対象の候補をもう一度見てみましょう。しかし、今回は射 $g$ を2変数の関数として考えます。
\[g \Colon z \times a \to b\]
積からの射であることは、2変数の関数であることに非常に近いです。特に、$\Set$では、$g$ は$z$の集合と$a$の集合の値のペアからの関数です。

一方、普遍的な性質は、そのような各 $g$ に対して、$z$ を関数対象 $a \Rightarrow b$ にマッピングする唯一の射 $h$ が存在することを私たちに教えてくれます。
\[h \Colon z \to (a \Rightarrow b)\]
$\Set$では、これは単に $z$ の型の変数を取り、$a$ から $b$ への関数を返す関数であることを意味します。これにより、$h$ は高階関数です。
従って、普遍構成は2変数の関数と1変数で関数を返す関数の間の一対一の対応関係を確立します。この対応関係は\newterm{curry化}と呼ばれ、$h$ は $g$ のCurry化されたバージョンと呼ばれます。

この対応関係は一対一です。なぜなら、任意の $g$ に対して一意の $h$ が存在し、任意の $h$ に対して次の式を使って2引数の関数 $g$ を常に再作成できるからです。
\[g = \mathit{eval} \circ (h \times \id)\]
関数 $g$ は $h$ の\emph{非curry化}バージョンと呼ぶことができます。

Curry化は本質的にHaskellの構文に組み込まれています。関数を返す関数: 

\src{snippet01}
はしばしば2変数の関数として考えられます。それが括弧を使わないシグネチャの読み方です: 

\src{snippet02}
この解釈は、多引数関数を定義する方法で明らかです。例えば: 

\src{snippet03}
同じ関数は、関数を返す1引数の関数 --- ラムダとして書くこともできます: 

\src{snippet04}
これらの2つの定義は同等であり、いずれも1つの引数だけを部分的に適用して、次のような1引数の関数を生成することができます: 

\src{snippet05}
厳密に言えば、2変数の関数とは、ペア (積型) を取る関数です: 

\src{snippet06}
2つの表現間の変換は簡単であり、それを行う2つの (高階) 関数は、驚くべきことに、\code{curry} と \code{uncurry} と呼ばれます: 

\src{snippet07}
そして

\src{snippet08}
\code{curry} は、関数対象の普遍構成のための\emph{ファクトライザ}です。これは、次の形式で書き直された場合に特に明らかです: 

\src{snippet09}
 (リマインダー: ファクトライザは候補から因数分解関数を生成します。) 

C++のような非関数型言語では、Curry化は可能ですが非自明です。C++の多引数

関数をHaskellでタプルを取る関数に対応させることができます (ただし、C++では\code{std::tuple}を明示的に取る関数を定義できるだけでなく、可変引数関数や初期化リストを取る関数も定義できるため、さらに混乱する可能性があります)。

C++関数を部分的に適用するには、テンプレート\code{std::bind}を使用します。例えば、2つの文字列を取る関数があるとします: 

\begin{snip}{cpp}
std::string catstr(std::string s1, std::string s2) {
    return s1 + s2;
}
\end{snip}
1つの文字列を取る関数を定義できます: 

\begin{snip}{cpp}
using namespace std::placeholders;

auto greet = std::bind(catstr, "Hello ", _1);
std::cout << greet("Haskell Curry");
\end{snip}
ScalaはC++やJavaよりも機能的であり、関数を部分適用することが予想される場合には、複数の引数リストでそれを定義します: 

\begin{snip}{cpp}
def catstr(s1: String)(s2: String) = s1 + s2
\end{snip}
もちろん、それはライブラリ作者の先見の明または予知に何らかの量を必要とします。

\section{指数関数}

数学の文献では、関数対象、または2つの対象 $a$ と $b$ の間の内部ホム対象はしばしば\newterm{指数関数}と呼ばれ、$b^{a}$ と表記されます。引数型が指数になっていることに注意してください。この表記は最初は奇妙に思えるかもしれませんが、関数と積の関係を考えると完全に理にかなっています。私たちは、内部ホム対象の普遍構成を使用するために積を使用する必要がありますが、接続はそれ以上に深いものです。

これは特に有限型間の関数を考えるときに最もよく見られます --- \code{Bool}、\code{Char}、あるいは\code{Int}や\code{Double}のように値の数が有限な型です。そのような関数は、少なくとも原理的には完全にメモ化されたり、ルックアップ用のデータ構造に変換されたりすることができます。そしてこれが関数 (射) と関数型 (対象) の間の同等性の本質です。

例えば、\code{Bool}からの (純粋な) 関数は完全に2つの値で指定されます。1つは\code{False}に対応し、もう1つは\code{True}に対応します。任意の\code{Int}への\code{Bool}からのすべての可能な関数の集合は、\code{Int}のペアの集合です。これは、少し創造力を働かせて、\code{Int}×\code{Int}または\code{Int}\textsuperscript{2}と同じです。

別の例として、256値を含むC++の型\code{char}を見てみましょう (Haskellの\code{Char}はより大きいです、なぜならHaskellはUnicodeを使用するからです)。C++標準ライブラリの一部には、通常ルックアップを使用して実装される関数がいくつかあります。\code{isupper}や\code{isspace}のような関数は、256個のブール値のタプルに相当するテーブルを使用して実装されます。タプルは積型なので、256個のブール値の積に取り組んでいます: \code{bool × bool × bool × ... × bool}。算数から知っているように、繰り返される積はべき乗を定義します。256 (または\code{char}) 回「掛ける」と、\code{bool}の\code{char}乗、つまり\code{bool}\textsuperscript{\code{char}}を得ます。

\code{bool}の256タプル型にはいくつの値がありますか？正確には $2^{256}$ 個です。これはまた、\code{char}から\code{bool}への異なる関数の数です。各関数は唯一の256タプルに対応します。同様に、\code{bool}から\code{char}への関数の数は $256^{2}$ であり、以下同様です。関数型の指数記法はこれらの場合に完全に意味を成します。

我々は\code{int}や\code{double}からの関数を完全にメモ化したいとは思わないかもしれません。しかし、関数とデータ型の間の等価性は、常に実用的でない場合でも存在します。無限型もあります。例えばリスト、文字列、または木です。それらの型からの関数のイーガーなメモ化は、無限のストレージを必要とします。しかし、Haskellは遅延言語なので、遅延評価される (無限の) データ構造と関数の境界は曖昧です。この関数とデータの二重性は、Haskellの関数型が圏論的な指数対象に対応するという私たちの考え方---つまり\emph{データ}により近いもの---と同一視されていることを説明しています。

\section{Cartesian閉圏}

型と関数のモデルとして集合の圏を使用し続けるつもりですが、その目的に使用できる圏の大きな族が存在することに触れる価値があります。これらの圏は\newterm{Cartesian閉圏}と呼ばれ、$\Set$ はそのような圏の一例に過ぎません。

Cartesian閉圏には以下が含まれる必要があります: 

\begin{enumerate}
  \tightlist
  \item
        終対象
  \item
        任意の対象ペアの積
  \item
        任意の対象ペアの指数関数
\end{enumerate}
指数関数を (無限に多くの回) 繰り返し積と考えるならば、任意のアリティの積をサポートする圏としてCartesian閉圏を考えることができます。特に、終対象はゼロの対象の積、または対象のゼロ乗と考えることができます。

コンピュータ科学の視点からCartesian閉圏について興味深いことは、それらが全ての型付けプログラミング言語の基礎を形成する単純型付きラムダ計算のモデルを提供することです。

終対象と積はそれぞれ始対象と余積の双対を持ちます。積が余積上で分配可能である場合
\begin{gather*}
  a \times (b + c) = a \times b + a \times c \\
  (b + c) \times a = b \times a + c \times a
\end{gather*}
圏は\newterm{双Cartesian閉圏}と呼ばれます。私たちは次のセクションで見るように、$\Set$のような双Cartesian閉圏はいくつかの興味深い特性を持っています。

\section{指数関数と代数的データ型}

関数型を指数関数と解釈することは代数的データ型のスキームに非常によく適合しています。高校の代数でゼロと一、和、積、指数関数に関連する基本的な恒等性は、それぞれ初期および終対象、余積、積、指数関数について、ほとんど変更されずに双Cartesian閉圏の任意のもので成立します。私たちはそれらを証明するツールをまだ持っていません (随伴や米田の補題など) が、それでもここにそれらを列挙して、貴重な直感の源としています。

\subsection{ゼロ乗}

\[a^{0} = 1\]
圏的に解釈すると、0を始対象、1を終対象に置き換え、等価を同型に置き換えます。指数関数は内部ホム対象です。この特定の指数関数は、始対象から任意の対象 $a$ への射の集合を表します。始対象の定義により、そのような射は正確に1つだけ存在するので、ホム集合 $\cat{C}(0, a)$ は単集合です。単集合は $\Set$ で終対象なので、この恒等は $\Set$ で自明に機能します。つまり、それは任意の双Cartesian閉圏で機能すると言えます。

Haskellでは、0を \code{Void} に、1をユニット型 \code{()} に、指数関数を関数型に置き換えます。主張は、\code{Void} から任意の型 \code{a} への関数の集合がユニット型と同等であるということです --- つまり、単一要素です。言い換えると、\code{Void -> a} のような関数は1つだけです。私たちはこの関数を以前に見たことがあります。それは \code{absurd} と呼ばれています。

これは2つの理由で少し厄介です。1つは、Haskellには本当に無人の型がないということです --- すべての型には「終わることのない計算の結果」という底が含まれています。2つ目の理由は、\code{absurd} のすべての実装が同等であり、それらが何をしても、誰もそれらを実行することはできないからです。 \code{absurd} に渡すことができる値はありません。(そして、終わることのない計算を渡すことができ

たとしても、それは決して返ってこないでしょう！) 

\subsection{1のべき乗}

\[1^{a} = 1\]
この恒等式は、$\Set$で終対象の定義を再述しています: 任意の対象から終対象への一意の射があります。一般的に、$a$から終対象への内部ホム対象は、終対象自体と同型です。

Haskellでは、任意の型 \code{a} からユニット型への関数は1つだけです。私たちはこの関数を以前に見たことがあります --- それは \code{unit} と呼ばれています。あるいは、\code{const} を \code{()} に部分適用した関数と考えることもできます。

\subsection{第1乗}

\[a^{1} = a\]
これは、終対象からの射が対象 \code{a} の「要素」を選択するために使用できるという観察の再述です。そのような射の集合は、対象自体と同型です。$\Set$では、およびHaskellでは、同型は集合 \code{a} の要素とそれらの要素を選択する関数、\code{() -> a} の間のものです。

\subsection{和の指数関数}

\[a^{b+c} = a^{b} \times a^{c}\]
圏的には、2つの対象の余積からの指数関数が、2つの指数関数の積と同型であることを示しています。Haskellでは、この代数的恒等式は非常に実用的な解釈を持っています。それは、2つの型の和からの関数が、個々の型からの一対の関数と等価であることを教えてくれます。これは私たちが和で関数を定義するときに使用するケース分析です。1つの関数定義を \code{case} 文で書く代わりに、通常はそれを2つ (またはそれ以上) の関数に分割します。それぞれが型コンストラクタごとに個別に処理します。例えば、\code{(Either Int Double)} の和型からの関数を取ります: 

\src{snippet10}
それは、それぞれ \code{Int} と \code{Double} からの一対の関数として定義することができます: 

\src{snippet11}
ここで、\code{n} は \code{Int} であり、\code{x} は \code{Double} です。

\subsection{指数関数の指数関数}

\[(a^{b})^{c} = a^{b \times c}\]
これは、純粋に指数対象の用語でCurry化を表現する方法です。関数を返す関数は、積 (2引数の関数) からの関数と同等です。

\subsection{積の上の指数関数}

\[(a \times b)^{c} = a^{c} \times b^{c}\]
Haskellでは: ペアを返す関数は、ペアの各要素を生成する一対の関数と同等です。

これらの簡単な高校の代数的恒等式が圏論に持ち上げられ、関数型プログラミングの実践的な応用を持っているのはかなり信じられないことです。

\section{Curry-Howard同型}

私はすでに論理と代数的データ型の間の対応について言及しました。\code{Void} 型とユニット型 \code{()} は偽と真に対応します。積型と和型は、それぞれ論理的な接続 $\wedge$ (AND) と選言 $\vee$ (OR) に対応します。このスキームで、私たちが定義した関数型は論理的な含意 $\Rightarrow$ に対応します。言い換えると、型 \code{a -> b} は「aならばb」と読むことができます。

Curry-Howard同型によれば、すべての型は命題として解釈できます --- 真または偽かもしれない言明または判断です。そのような命題は、型が居住している場合は真と見なされ、そうでない場合は偽と見なされます。特に、論理的な含意は、それに対応する関数型が居住している場合に真であり、それはその型の関数が存在することを意味します。関数の実装は従って定理の証明です。プログラムを書くことは定理を証明することに等しいです。いくつかの例を見てみましょう。

関数対象の定義で導入した関数 \code{eval} を取ります。そのシグネチャは: 

\src{snippet12}
それは関数とその引数からなるペアを取り、適切な型の結果を生成します。それは射: 

\[\mathit{eval} \Colon (a \Rightarrow b) \times a \to b\]
をHaskellで実装したものです。これは関数型 $a \Rightarrow b$ (または指数対象 $b^a$) を定義します。このシグネチャをCurry-Howard同型を使って論理的な述語に変換しましょう: 

\[((a \Rightarrow b) \wedge a) \Rightarrow b\]
この文は次のように読むことができます: $b$ が $a$ から導かれることが真であり、かつ $a$ が真であるならば、$b$ も真でなければなりません。これは直感的に非常に理にかなっており、古代から \newterm{modus ponens} として知られています。この定理を実装することで証明します: 

\src{snippet13}
あなたが関数 \code{f} (\code{a} を取って \code{b} を返す) と、型 \code{a} の具体的な値 \code{x} からなるペアを私に与えれば、私は単に関数 \code{f} を \code{x} に適用することで、型 \code{b} の具体的な値を生成することができます。この関数を実装することで、\code{((a -> b), a) -> b} の型が居住されていることを示しました。従って、\newterm{modus ponens} は私たちの論理で真です。

では、明らかに偽の述語はどうでしょうか？例えば: $a$ または $b$ が真であれば $a$ も真でなければなりません。

\[a \vee b \Rightarrow a\]
これは明らかに間違っています。なぜなら、偽の $a$ と真の $b$ を選ぶことができるからです。それは反例です。

Curry-Howard同型を使用してこの述語を関数シグネチャにマッピングすると、次のようになります: 

\src{snippet14}
いくら試みても、この関数を実装することはできません---\code{Right} 値で呼ばれた場合、\code{a} 型の値を生成することはできません。(純粋関数について話していることを忘れないでください。) 

最後に、\code{absurd} 関数の意味について考えてみましょう: 

\src{snippet15}
\code{Void} が偽に対応することを考えると、次のようになります: 

\[\mathit{false} \Rightarrow a\]
偽からは何でも導き出される (\emph{ex falso quodlibet})。以下は、Haskellでのこの文 (関数) の1つの可能な証明 (実装) です: 

\begin{snip}{haskell}
absurd (Void a) = absurd a
\end{snip}
ここで \code{Void} は次のように定義されています: 

\begin{snip}{haskell}
newtype Void = Void Void
\end{snip}
常に、\code{Void} 型は厄介です。この定義により、値を構成することは不可能になります。なぜなら、1つを提供するためには、すでに1つを持っている必要があるからです。従って、関数 \code{absurd} は決して呼び出すことができません。

これらはすべて興味深い例ですが、Curry-Howard同型には実用的な側面があるのでしょうか？おそらく日常のプログラミングではありません。しかし、AgdaやCoqのようなプログラミング言語はCurry-Howard同型を利用して定理を証明します。

コンピュータは数学者が仕事をするのを助けるだけでなく、数学の非常に基礎を革命しています。その分野での最新の熱い研究トピックはホモトピー型理論と呼ばれ、型理論の成長です。それはBooleans、整数、積と余積、関数型などでいっぱいです。そして、疑問を払拭するかのように、この理論はCoqやAgdaで定式化されています。コンピュータは複数の方法で世界を革命しています。

\section{参考文献}

\begin{enumerate}
  \tightlist
  \item
        Ralph Hinze, Daniel W. H. James,
        \urlref{http://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf}{Reason
          Isomorphically!}. この論文には、この章で私が言及した高校の代数的恒等式のすべての証明が含まれています。
\end{enumerate}
