% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{プ}{ログラマ}にモナドを話すと、作用について話すことになるかもしれませんが、数学者にとってモナドは代数についてです。後ほど代数について話します --- プログラミングにおいて重要な役割を果たします --- しかしまず、モナドとの関係について少し直感をお伝えしたいです。今は少し手を振るような議論ですが、お付き合いください。

代数は、表現を作成し、操作し、評価することについてです。表現は演算子を使って構成されます。このシンプルな表現を考えてみてください: 
\[x^2 + 2 x + 1\]
この表現は、変数$x$や定数$1$や$2$を、足し算や掛け算のような演算子で結びつけて構成されています。プログラマとしては、表現を木構造として考えることがよくあります。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/exptree.png}
\end{figure}

\noindent
木はコンテナなので、一般的には、表現は変数を格納するコンテナです。圏論では、コンテナを自己関手として表します。変数$x$に型$a$を割り当てると、私たちの表現は$m\ a$という型を持ちます。ここで$m$は、表現木を構成する自己関手です。(非自明な分岐表現は通常、再帰的に定義された自己関手を使用して作成されます。)

表現に対して実行できる最も一般的な操作は何でしょうか？それは代入です: 変数を表現で置き換えることです。例えば、先ほどの例で、$X$を$y - 1$で置き換えると、以下のようになります: 
\[(y - 1)^2 + 2 (y - 1) + 1\]
ここで何が起こったかというと、型$m\ a$の表現を取り、型$a \to m\ b$の変換 ($b$は$y$の型) を適用しました。結果は型$m\ b$の表現です。はっきりさせましょう: 
\[m\ a \to (a \to m\ b) \to m\ b\]
はい、これがモナド的な束縛のシグネチャです。

これは少し動機付けです。さあ、モナドの数学に取り組みましょう。数学者はプログラマよりも異なる記法を好むことがあります。彼らは自己関手には文字$T$を使用し、ギリシャ文字: $\mu$は\code{join}に、$\eta$は\code{return}に対応します。両方の\code{join}と\code{return}は多相的な関数なので、それらが自然変換に対応すると推測できます。

したがって、圏論では、モナドはペアの自然変換$\mu$と$\eta$を備えた自己関手$T$として定義されます。

$\mu$は、関手$T^2$から$T$に戻る自然変換です。$T^2$は単に関手自体とその自体の組み合わせ、$T \circ T$です (この種の二乗は自己関手に対してのみ実行できます)。
\[\mu \Colon T^2 \to T\]
この自然変換の対象$a$におけるコンポーネントは射です: 
\[\mu_a \Colon T (T a) \to T a\]
これは$\Hask$では\code{join}の定義に直接翻訳されます。

$\eta$は、恒等関手$I$と$T$の間の自然変換です: 
\[\eta \Colon I \to T\]
$I$の対象$a$に対する作用が単に$a$であることを考慮すると、$\eta$のコンポーネントは射によって与えられます: 
\[\eta_a \Colon a \to T a\]
これは\code{return}の定義に直接翻訳されます。

これらの自然変換はいくつかの追加の規則を満たさなければなりません。一つの見方は、これらの規則が私たちに自己関手$T$のためのKleisli圏を定義させることです。$a$と$b$の間のKleisli射は、射$a \to T b$として定義されます。2つのそのような射の合成 ($T$の下付き文字を持つ円として書きます) は$\mu$を使用して実装できます: 
\[g \circ_T f = \mu_c \circ (T g) \circ f\]
ここで
\begin{gather*}
  f \Colon a \to T b \\
  g \Colon b \to T c
\end{gather*}
ここで$T$は関手であり、射$g$に適用できます。この式をHaskell記法で認識するのが容易かもしれません: 

\src{snippet01}
または、コンポーネントで: 

\src{snippet02}
代数的な解釈では、私たちは単に2つの連続する代入を合成しているだけです。

Kleisli射が圏を形成するためには、その合成が結合的であること、そして$\eta_a$が$a$での恒等Kleisli射であることが望まれます。この要件は、$\mu$と$\eta$のためのモナドの規則に翻訳することができます。しかし、これらの規則をよりモノイドの規則のように見せる別の方法で導出することもできます。実際$\mu$はしばしば\emph{乗算}と呼ばれ、$\eta$は\emph{単位}と呼ばれます。

大まかに言えば、結合則は$T$の立方体、$T^3$、を$T$に減らす2つの方法が同じ結果を与えなければならないと述べています。2つの単位則 (左と右) は、$\eta$が$T$に適用されてから$\mu$によって減少されるとき、私たちは$T$に戻ると述べています。

これらの規則は少しトリッキーです、なぜなら自然変換と関手を合成しているからです。そのため、水平合成について少し復習することが必要です。例えば、$T^3$は$T$の後に$T^2$の合成と見なすことができます。私たちはそれに2つの自然変換の水平合成を適用することができます: 
\[I_T \circ \mu\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/assoc1.png}
\end{figure}

\noindent
そして$T \circ T$を得ることができます；これは$\mu$を適用することでさらに$T$に減少できます。$I_T$は$T$から$T$への恒等自然変換です。この種類の水平合成の表記$I_T \circ \mu$を$T \circ \mu$に短縮するのをよく見るでしょう。この表記は曖昧ではありません、なぜなら関手と自然変換を合成することは意味がないので、$T$はこの文脈で$I_T$を意味しなければなりません。

\noindent
また、(自己)関手圏${[}\cat{C}, \cat{C}{]}$における図を描くことができます: 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/assoc2.png}
\end{figure}

\noindent
代わりに、$T^3$を$T^2 \circ T$の合成として扱い、それに$\mu \circ T$を適用することもできます。結果はまた$T \circ T$で、再び$\mu$を使って$T$に減少することができます。私たちは2つのパスが同じ結果を生むことを要求します。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/assoc.png}
\end{figure}

\noindent
同様に、私たちは恒等関手$I$の後に$T$の合成に水平合成$\eta \circ T$を適用して$T^2$を得ることができ、それから$\mu$を使用して減少することができます。結果は、恒等自然変換を直接\code{T}に適用した場合と同じでなければなりません。同様に、$T \circ \eta$にも真実でなければなりません。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/unitlawcomp-1.png}
\end{figure}

\noindent
これらの規則がKleisli射の合成が確かに圏の規則を満たすことを保証することを自分自身に納得させることができます。

モナドとモノイドの類似性は著しいです。私たちは乗算$\mu$、単位$\eta$、結合則、および単位則を持っています。しかし、モナドをモノイドとして記述するためには、私たちのモノイドの定義が狭すぎます。では、モノイドの概念を一般化しましょう。

\section{モノイダル圏}

モノイドの従来の定義に立ち戻りましょう。それは二項演算と単位と呼ばれる特別な要素を持つ集合です。Haskellでは、これは型クラスとして表現されます: 

\src{snippet03}
二項演算\code{mappend}は結合的であり、単位的でなければなりません (つまり、単位\code{mempty}による乗算は無操作です)。

Haskellでの\code{mappend}の定義はCurry化されています。それはすべての\code{m}の要素を関数にマッピングすると解釈することができます: 

\src{snippet04}
この解釈は、モノイドをモノイドの要素として自己準同型\code{(m -> m)}を表す単一対象圏として定義する原因となります。
しかし、Curry化がHaskellに組み込まれているため、私たちは乗算の異なる定義から始めることもできました: 

\src{snippet05}
ここで、デカルト積\code{(m, m)}は乗算されるペアのソースになります。

この定義は、圏論的な積でデカルト積を置き換えることによって一般化への別の道を示唆しています。積が大局的に定義された圏を始めることができ、対象\code{m}を選んで、乗算を射として定義することができます: 
\[\mu \Colon m\times{}m \to m\]
しかし、任意の圏で対象の内部を見ることはできないため、単位要素をどのように選ぶかという問題があります。そのためにはトリックがあります。要素選択が単集合からの関数と同等であることを覚えていますか？Haskellでは、\code{mempty}の定義を関数で置き換えることができます: 

\src{snippet06}
単集合は$\Set$における終対象なので、終対象$t$を持つ任意の圏にこの定義を一般化することは自然です: 
\[\eta \Colon t \to m\]
これにより、要素について話すことなく、単位「要素」を選ぶことができます。

以前のモノイドとしての単一対象圏の定義とは異なり、ここではモノイダル則は自動的に満たされません---私たちはそれらを課さなければなりません。しかし、それらを定式化するためには、基礎となる圏論的な積自体のモノイダル構造を確立する必要があります。まずHaskellでのモノイダル構造がどのように機能するかを思い出しましょう。

結合性から始めます。Haskellで、対応する等式は次のようになります: 

\src{snippet07}
他の圏に一般化する前に、個々の変数に対するその作用からそれを書き換えて、関数 (射) の等式として書く必要があります。言い換えると、それをポイントフリー表記で使用する必要があります。デカルト積が双関手であることを知っていれば、左辺を次のように書くことができます: 

\src{snippet08}
右辺は次のようになります: 

\src{snippet09}
これはほぼ私たちが望むものです。残念ながら、デカルト積は厳密に結合的ではない--- \code{(x, (y, z))}は\code{((x, y), z)}と同じではありません --- したがって、ポイントフリーで書くことはできません: 

\src{snippet10}
他方で、ペアの2つの入れ子は同型です。それらの間を変換する可逆関数、結合子 (associator) があります: 

\src{snippet11}
結合子の助けを借りて、\code{mu}のポイントフリーな結合則を書くことができます: 

\src{snippet12}
同様のトリックを単位則に適用することができます。新しい表記では、次の形を取ります: 

\src{snippet13}
それらは次のように書き換えることができます: 

\src{snippet14}
同型\code{lambda}と\code{rho}はそれぞれ\code{左単位子}と\code{右単位子}と呼ばれます。これらは、単位\code{()}が同型の違いを除いてデカルト積の恒等写像であるという事実を示しています: 

\src{snippet15}

\src{snippet16}
したがって、単位則のポイントフリー版は次のようになります: 

\src{snippet17}
私たちは、基礎となるデカルト積自体が型の圏でモノイダル乗算のように機能するという事実を使用して、\code{mu}と\code{eta}のポイントフリーなモノイダル則を定式化しました。ただし、デカルト積の結合性と単位則は、同型によってのみ有効です。

これらの規則は、積と終対象を持つ任意の圏に一般化することができます。圏論的な積は、実際には同型によって結合的であり、終対象は同型によって単位です。結合子と2つの単位子は自然同型です。規則は可換図式によって表されます。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/assocmon.png}
\end{figure}

\noindent
積が双関手であるため、対の射を持ち上げることができます --- Haskellではこれは\code{bimap}を使用して行われました。

ここで止めて、圏論的な積と終対象を持つ任意の圏の上にモノイドを定義することができると言うことができます。対象$m$と2つの射$\mu$と$\eta$を選び、モノイダル則を満たすことができれば、モノイドを持っています。しかし、私たちはそれよりも良くすることができます。$\mu$と$\eta$の規則を定式化するために完全な圏論的な積を必要とするわけではありません。積が射影を使用する普遍構成を通じて定義されることを思い出してください。私たちのモノイダル則の定式化では、射影を使用していません。

積のように振る舞うが積ではない双関手は、しばしば中置演算子$\otimes$で表される\newterm{テンソル積}と呼ばれます。一般にテンソル積の定義は少し難しいですが、私たちはそれについて心配しません。私たちはそれの特性をリストするだけです --- 最も重要なのは同型による結合性です。

同様に、対象$t$が終対象である必要はありません。その終対象の性質、つまりそれへの任意の対象からの一意な射の存在を使用したことはありません。私たちが必要とするのは、それがテンソル積と連携して機能することです。つまり、同型によってテンソル積の単位であることが望まれます。全体をまとめましょう: 

モノイダル圏は、テンソル積と呼ばれる双関手を備えた圏$\cat{C}$です: 
\[\otimes \Colon \cat{C}\times{}\cat{C} \to \cat{C}\]
そして、単位対象$i$と呼ばれる特異な対象、およびそれぞれ結合子と左右の単位子と呼ばれる3つの自然同型があります: 
\begin{align*}
  \alpha_{a b c} & \Colon (a \otimes b) \otimes c \to a \otimes (b \otimes c) \\
  \lambda_a      & \Colon i \otimes a \to a                                   \\
  \rho_a         & \Colon a \otimes i \to a
\end{align*}
 (四重テンソル積を単純化するための整合性条件もあります。) 

重要なのは、テンソル積が多くのおなじみの双関手を記述することです。特に、積、余積、およびまもなく見るように、自己関手の合成 (およびDay畳み込みのようないくつかのより奇妙な積) に対して機能します。モノイダル圏は、豊穣圏の定式化において重要な役割を果たします。

\section{モノイダル圏におけるモノイド}

私たちは今、モノイダル圏のより一般的な設定でモノイドを定義する準備ができました。対象$m$を選びます。テンソル積を使用して$m$の累乗を形成できます。$m$の二乗は$m \otimes m$です。$m$の立方体を形成する2つの方法がありますが、結合子を介して同型です。同様に、$m$のより高い累乗のために (整合性条件が必要です)。モノイドを形成するために、2つの射を選びます: 
\begin{align*}
  \mu  & \Colon m \otimes m \to m \\
  \eta & \Colon i \to m
\end{align*}
ここで$i$は私たちのテンソル積のための単位対象です。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/monoid-1.jpg}
\end{figure}

\noindent
これらの射は結合則と単位則を満たさなければなりませんが、それらは次の可換図式の形で表現できます: 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/assoctensor.jpg}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/unitmon.jpg}
\end{figure}

\noindent
テンソル積が双関手であることが重要です。なぜなら、私たちは射のペアを持ち上げて$\mu \otimes \id$や$\eta \otimes \id$のような積を形成する必要があるからです。これらの図式は、圏論的な積に対する私たちの以前の結果の直接的な一般化です。

\section{モナドとしてのモノイド}

モノイダル構造は予期せぬ場所で現れます。その一つが関手圏です。少し目を細めれば、関手の合成が乗法の一種として見えるかもしれません。問題は、任意の2つの関手が合成可能であるわけではないことです --- 一つの関手の目的圏がもう一つの関手の出発圏でなければなりません。これは射の合成に関する通常の規則です --- そして、私たちは関手が実際には圏$\Cat$の射であることを知っています。しかし、自己準同型 (同じ対象に戻る射) は常に合成可能であるように、自己関手もそうです。任意の与えられた圏$\cat{C}$の自己関手は、関手圏${[}\cat{C}, \cat{C}{]}$を形成します。その対象は自己関手であり、射はそれらの間の自然変換です。この圏から任意の2つの対象、例えば自己関手$F$と$G$を取り、それらの合成である第三の対象$F \circ G$ --- それらの合成である自己関手を生成できます。

自己関手の合成はテンソル積の良い候補ですか？まず、それが双関手であることを確立する必要があります。ここでの射のペア --- つまり、自然変換 --- を持ち上げることができますか？テンソル積の\code{bimap}の類似物の署名は次のようになります: 
\[\mathit{bimap} \Colon (a \to b) \to (c \to d) \to (a \otimes c \to b \otimes d)\]
対象を自己関手に、矢を自然変換に、そしてテンソル積を合成に置き換えると、次のようになります: 
\[(F \to F') \to (G \to G') \to (F \circ G \to F' \circ G')\]
これは水平合成の特別なケースとして認識できます。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/horizcomp.png}
\end{figure}

\noindent
また、私たちの新しいテンソル積のための恒等写像として機能できる、恒等自己関手$I$も利用可能です。さらに、関手の合成は結合的です。実際、結合則と単位則は厳格です --- 結合子や2つの単位子は必要ありません。したがって、自己関手は、関手の合成をテンソル積として、厳密なモノイダル圏を形成します。

この圏でのモノイドとは何ですか？それは対象 --- つまり自己関手$T$；そして2つの射 --- つまり自然変換です: 
\begin{gather*}
  \mu \Colon T \circ T \to T \\
  \eta \Colon I \to T
\end{gather*}
それだけでなく、ここにモノイド則があります: 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/assoc.png}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/unitlawcomp.png}
\end{figure}

\noindent
それらは、以前見たモナド則とまさに同じです。これで、Saunders Mac Laneの有名な引用を理解できます: 

\begin{quote}
  総じて、モナドは単に自己関手の圏のモノイドです。
\end{quote}
あなたはそれを機能的プログラミング会議でいくつかのTシャツに掲げられているかもしれません。

\section{随伴からのモナド}

随伴$L \dashv R$は、2つの圏$\cat{C}$と$\cat{D}$の間を行き来する一対の関手です。それらを合成する2つの方法があり、2つの自己関手$R \circ L$と$L \circ R$が生まれます。随伴によれば、これらの自己関手は単位と余単位と呼ばれる2つの自然変換を介して恒等関手に関連しています: 
\begin{gather*}
  \eta \Colon I_{\cat{D}} \to R \circ L \\
  \varepsilon \Colon L \circ R \to I_{\cat{C}}
\end{gather*}
直ちに、随伴の単位はモナドの単位とまったく同じように見えることがわかります。実際、自己関手$R \circ L$はモナドです。適切な$\mu$を$\eta$とともに定義するだけでよいのです。それは、私たちの自己関手の二乗と自己関手自体の間の自然変換です、または随伴関手の観点からは: 
\[R \circ L \circ R \circ L \to R \circ L\]
実際、私たちは中間の$L \circ R$を崩壊させるために余単位を使用することができます。$\mu$の正確な式は、水平合成によって与えられます: 
\[\mu = R \circ \varepsilon \circ L\]
モナド則は、随伴の単位と余単位によって満たされる恒等式と交換則から導かれます。

Haskellでは、随伴が2つの圏に関与するため、随伴から派生したモナドをあまり見ません。ただし、指数関数、または関数対象の定義は例外です。この随伴を形成する2つの自己関手は次のようになります: 
\begin{gather*}
  L z = z\times{}s \\
  R b = s \Rightarrow b
\end{gather*}
その合成を、おなじみのStateモナドとして認識するかもしれません: 
\[R (L z) = s \Rightarrow (z\times{}s)\]
これは、以前にHaskellで見たモナドです: 

\src{snippet18}
随伴をHaskellに翻訳しましょう。左関手はProduct関手です: 

\src{snippet19}
そして、右関手はReader関手です: 

\src{snippet20}
それらは随伴を形成します: 

\src{snippet21}
Product関手の後のReader関手の合成が確かにState関手に等しいことを簡単に納得することができます: 

\src{snippet22}
予想通り、随伴の\code{unit}はStateモナドの\code{return}関数に相当します。余単位は、その引数に作用する関数を評価することで作用します。これは\code{runState}の未Curry化バージョンとして認識できます: 

\src{snippet23}
(未Curry化、なぜなら\code{counit}はペアに作用するからです)。

私たちは、3つの自然変換の水平合成を必要とする自然変換$\mu$の一部としてStateモナドの\code{join}を定義することができます: 
\[\mu = R \circ \varepsilon \circ L\]
つまり、余単位$\varepsilon$をReader関手の1レベルを超えて潜り込ませる必要があります。コンパイラは\code{Reader}関手ではなく\code{State}関手のための\code{fmap}を選択するため、直接\code{fmap}を呼び出すことはできません。しかし、Reader関手の\code{fmap}は左関数合成に過ぎないことを思い出してください。だから、関数合成を直接使用します。

まず、\code{State}データコンストラクタを剥がして、\code{State}関手内の関数を露出させる必要があります。これは\code{runState}を使用して行われます: 

\src{snippet24}
次に、それを余単位である\code{uncurry runState}で左合成します。最後に、それを\code{State}データコンストラクタで再び覆います: 

\src{snippet25}
これは実際には、\code{State}モナドの\code{join}の実装です。

実際には、すべての随伴がモナドを生み出すだけでなく、逆もまた真であることがわかります: すべてのモナドは2つの随伴関手の合成に分解することができます。ただし、そのような分解は一意ではありません。

次のセクションで他の自己関手$L \circ R$について話します。
