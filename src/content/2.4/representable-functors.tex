% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{そ}{ろそろ}集合について少し話しましょう。
数学者は集合理論と愛憎関係にあります。それは数学のアセンブリ言語のようなものです --- 少なくとも昔はそうでした。圏論は、ある程度、集合理論から距離を置こうとします。例えば、全ての集合の集合は存在しないというのが知られていますが、全ての集合の圏、$\Set$は存在します。だからそれは良いことです。一方で、圏の任意の二つの対象間の射は集合を形成すると仮定しています。我々はそれをホム集合と呼びました。公平を期すと、射が集合を形成しない圏論の分岐もあります。その代わりに、それらは別の圏の対象です。ホム集合ではなくホム対象を使用するそれらの圏は、\newterm{豊穣}な圏と呼ばれます。しかし、これから我々が扱うのは、良い古典的なホム集合を持つ圏です。

集合は、圏論的対象の外で得られる、ほとんど特徴のないブロブに最も近いものです。集合には要素がありますが、これらの要素についてはあまり語ることができません。有限集合があれば、要素を数えることができます。無限集合の要素を、基数を使って何となく数えることができます。例えば、自然数の集合は実数の集合よりも小さいですが、どちらも無限です。しかし、驚くべきことに、有理数の集合は自然数の集合と同じ大きさです。

それ以外に、集合に関する全ての情報は、それらの間の関数 --- 特に同型と呼ばれる可逆なもの --- にエンコードすることができます。全ての意図と目的において、同型な集合は同一です。基礎数学者の怒りを呼ぶ前に、等価性と同型の違いは、最新の数学の分岐、ホモトピー型理論 (HoTT) の主要な関心事の一つです。HoTTは計算からインスピレーションを得た純粋な数学理論であり、その主要な提唱者の一人であるVladimir Voevodskyは、Coq定理証明器を研究中に主要な啓示を得ました。数学とプログラミングの相互作用は双方向です。

集合に関する重要な教訓は、異なる要素の集合を比較することが許されるということです。たとえば、ある自然変換の集合が、ある射の集合と同型であると言えます、なぜなら集合はただの集合だからです。この場合の同型とは、一方の集合からの自然変換ごとに他方の集合から一意の射があり、その逆も同様であることを意味します。それらは互いにペアにすることができます。異なる圏の対象であれば、リンゴとオレンジを比較することはできませんが、リンゴの集合とオレンジの集合を比較することはできます。しばしば、圏論的な問題を集合理論的な問題に変換することで、必要な洞察を得たり、貴重な定理を証明することができます。

\section{ホム関手}

すべての圏は、$\Set$への標準的な写像の族を備えています。これらの写像は実際には関手であり、したがって圏の構造を保持します。そのような写像を一つ構成してみましょう。

$\cat{C}$の一つの対象$a$を固定し、$\cat{C}$内の別の対象$x$を選びます。ホム集合$\cat{C}(a, x)$は集合であり、$\Set$の対象です。$x$を変えると、$a$を固定したまま、$\cat{C}(a, x)$も$\Set$内で変わります。したがって、$x$から$\Set$への写像があります。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth]{images/hom-set.jpg}
\end{figure}

\noindent
ホム集合を第二引数の写像として考慮したい場合、記法$\cat{C}(a, -)$を使用し、ダッシュが引数のプレースホルダーとして機能します。

この対象の写像は容易に射の写像に拡張されます。$\cat{C}$内の任意の射$f$を、任意の対象$x$と$y$の間で取りましょう。対象$x$は集合$\cat{C}(a, x)$に写され、対象$y$は私たちが定義した写像の下で$\cat{C}(a, y)$に写されます。この写像が関手であるためには、$f$は二つの集合間の関数に写されなければなりません: $\cat{C}(a, x) \to \cat{C}(a, y)$

この関数を点ごとに定義しましょう、つまり各引数に対して別々に。引数として$\cat{C}(a, x)$の任意の要素を選びましょう --- それを$h$と呼びます。射は、端と端が一致する場合に合成可能です。偶然にも$f$の源が$h$の目標と一致するので、その合成: 
\[f \circ h \Colon a \to y\]
は$a$から$y$への射です。したがって、それは$\cat{C}(a, y)$のメンバーです。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth]{images/hom-functor.jpg}
\end{figure}

\noindent
私たちはちょうど$\cat{C}(a, x)$から$\cat{C}(a, y)$への関数を見つけました、これが$f$の像として機能することができます。混乱の恐れがなければ、この持ち上げられた関数を$\cat{C}(a, f)$と書き、射$h$に対するその作用を次のように書きます: 
\[\cat{C}(a, f) h = f \circ h\]
この構造が任意の圏で機能するので、Haskellの型の圏にも機能します。Haskellでは、ホム関手は\code{Reader}関手としてよりよく知られています: 

\src{snippet01}

\src{snippet02}
それでは、ホム集合の源を固定するのではなく、目標を固定した場合に何が起こるかを考えてみましょう。つまり、写像$\cat{C}(-, a)$も関手であるかという問いです。それはそうですが、共変であるのではなく反変です。それは、射の端と端の同じ種類の一致が、$\cat{C}(a, -)$の場合とは逆に、$f$による後方合成をもたらすからです。

私たちはすでにHaskellでこの反変関手を見てきました。それは\code{Op}と呼ばれていました: 

\src{snippet03}

\src{snippet04}
最終的に、両方の対象を変化させると、第一引数で反変で、第二引数で共変であるプロ関手$\cat{C}(-, =)$が得られます (二つの引数が独立して変化することを強調するために、第二プレースホルダーとしてダブルダッシュを使用します)。私たちは以前、関手性について話をしたときにこのプロ関手を見ました: 

\src{snippet05}
重要な教訓は、この観察が任意の圏で成り立つということです: 対象をホム集合に写す写像は関手的です。反変性が逆圏からの写像に相当するので、私たちはこの事実を簡潔に述べることができます: 
\[C(-, =) \Colon \cat{C}^\mathit{op} \times \cat{C} \to \Set\]

\section{表現可能関手}

$\cat{C}$の任意の対象$a$を選ぶと、$\cat{C}$から$\Set$への関手が得られます。このような$\Set$への構造保存写像はしばしば\newterm{表現}と呼ばれます。$\cat{C}$の対象と射を$\Set$の集合と関数として表現しています。

関手$\cat{C}(a, -)$自体は時々表現可能と呼ばれます。より一般的に、ホム関手に自然に同型であるような任意の関手$F$は、\newterm{表現可能}と呼ばれます。そのような関手は必然的に$\Set$値でなければならず、$\cat{C}(a, -)$がそうであるからです。

私は以前、私たちは通常同型な集合を同一と考えると言いました。より一般的には、圏内の同型な\emph{対象}を同一と考えます。それは、対象が射を通じて他の対象 (およびそれ自身) との関係以外に構造を持たないからです。

例えば、私たちは以前、集合で初めてモデル化されたモノイドの圏、$\cat{Mon}$について話しました。しかし、我々はそれらの集合のモノイダル構造を保存する関数のみを射として選びました。したがって、$\cat{Mon}$内の二つの対象が同型である場合、つまりそれらの間に可逆な射がある場合、それらは正確に同じ構造を持っています。我々がそれらの基礎となる集合と関数を覗き見れば、一つのモノイドの単位素が別のモノイドの単位要素に写され、二つの要素の積がその写像の積に写されるのを見るでしょう。

関手に対する同じ推論を適用することができます。二つの圏間の関手は、自然変換が射として機能する圏で形成されます。したがって、二つの関手が同型であり、それらが同一であると考えることができます。それらの間に可逆な自然変換がある場合。

表現可能関手の定義をこの視点から分析しましょう。$F$が表現可能であるためには、次が必要です: $\cat{C}$の中に対象$a$が存在し、$\cat{C}(a, -)$から$F$への自然変換$\alpha$が一つ、逆方向にはもう一つの自然変換$\beta$があり、そしてそれらの合成が恒等自然変換であること。

$\alpha$の$x$におけるコンポーネントを見てみましょう。それは$\Set$内の関数です: 
\[\alpha_x \Colon \cat{C}(a, x) \to F x\]
この変換の自然性条件は、$x$から$y$への任意の射$f$に対して、次の図式が可換であることを告げています: 
\[F f \circ \alpha_x = \alpha_y \circ \cat{C}(a, f)\]
Haskellでは、自然変換を多相関数で置き換えます: 

\src{snippet06}
オプショナルの\code{forall}量化子を使います。自然性条件

\src{snippet07}
は、パラメトリシティにより自動的に満たされます (私が以前言及した無料の定理の一つです)、左側の\code{fmap}は関手$F$によって定義され、右側はReader関手によって定義されることを理解しています。Readerのための\code{fmap}はただの関数前置合成なので、より明確にすることができます。$\cat{C}(a, x)$の要素である$h$に作用すると、自然性条件は次のように単純化されます: 

\src{snippet08}
逆方向の変換、\code{beta}は反対の方向に進みます: 

\src{snippet09}
それは自然性条件を尊重しなければならず、\code{alpha}の逆でなければなりません: 

\begin{snip}{text}
alpha . beta = id = beta . alpha
\end{snip}
私たちは後で、$F a$が空でない限り、$\cat{C}(a, -)$から任意の$\Set$値関手への自然変換が常に存在することを見るでしょう (米田の補題) が、それが必ずしも可逆ではないことも見るでしょう。

Haskellでのリスト関手と\code{Int}を\code{a}とする例を挙げましょう。ここでは仕事をする自然変換を次のように任意に選びます: 

\src{snippet10}
私は任意に数12を選び、それで一つの要素のリストを作りました。その後、関数\code{h}をこのリスト上で\code{fmap}することができ、\code{h}によって返される型のリストを得ることができます。 (実際には、整数のリストと同じ数だけこのような変換が存在します。) 

自然性条件は\code{map}の合成可能性 (\code{fmap}のリストバージョン) と同等です: 

\src{snippet11}
しかし、逆変換を見つけようとした場合、任意の型\code{x}のリストから\code{x}を返す関数へ行かなければなりません: 

\src{snippet12}
例えば、\code{head}を使ってリストから\code{x}を取り出すことを考えるかもしれませんが、空のリストではうまくいきません。このため、\code{a}の型として (\code{Int}の代わりに) 機能する選択肢はありません。従ってリスト関手は表現可能ではありません。

Haskellの(自己)関手がコンテナのようなものだと話したときのことを覚えていますか？同じ意味で、表現可能関手は関数呼び出しのメモ化結果を格納するコンテナとして考えることができます。Haskellではホム集合のメンバーは単なる関数です。表現する対象、$\cat{C}(a, -)$の型$a$は、関数の表計算値にアクセスするためのキー型と考えられます。私たちが\code{alpha}と呼んだ変換は\code{tabulate}と呼ばれ、その逆は\code{index}と呼ばれます。ここに (少し単純化された) \code{Representable}クラスの定義があります: 

\src{snippet13}
表している型、つまり我々の$a$である\code{Rep f}は、\code

{Representable}の定義の一部であることに注意してください。星印は単に\code{Rep f}が型であることを意味します (型コンストラクタや他のもっと奇妙なものとは対照的に)。

空でない無限リスト、またはストリームは表現可能です。

\src{snippet14}
それらは引数として\code{Integer}を取る関数のメモ化値として考えることができます。 (厳密に言えば、非負の自然数を使うべきですが、コードを複雑にしたくありませんでした。) 

そのような関数を\code{tabulate}するためには、値の無限ストリームを作成します。もちろん、これはHaskellが遅延評価であるために可能です。値は要求に応じて評価されます。\code{index}を使ってメモ化された値にアクセスします: 

\src{snippet15}
興味深いことに、任意の戻り型の全ての族の関数に対して単一のメモ化スキームを実装することができます。

反変関手に対する表現可能性も同様に定義されますが、$\cat{C}(-, a)$の第二引数を固定します。または、$\cat{C}^\mathit{op}$から$\Set$への関手として考えることができます、なぜなら$\cat{C}^\mathit{op}(a, -)$は$\cat{C}(-, a)$と同じだからです。

表現可能性には面白い捩れがあります。ホム集合は、デカルト閉圏内で指数対象として内部的に扱うことができることを覚えていますか。ホム集合$\cat{C}(a, x)$は$x^a$に相当し、表現可能関手$F$に対して、私たちは$-^a = F$と書くことができます。

両側に対数を取ってみましょう、単にキックのために: $a = \mathbf{log}F$

もちろん、これは純粋に形式的な変換ですが、対数のいくつかの特性を知っていれば、それはかなり役立ちます。特に、積型に基づく関手は和型で表現されることがわかり、和型関手は一般的には表現可能ではありません (例: リスト関手)。

最後に、表現可能関手は、同じことの二つの異なる実装を与えてくれることに注意してください --- 一つは関数、もう一つはデータ構造です。それらにはまったく同じ内容があり --- 同じキーを使って同じ値が取り出されます。それが私が話していた「同じさ」の感覚です。二つの自然に同型な関手は、その内容に関与する限りでは同一です。一方、二つの表現はしばしば異なって実装され、異なるパフォーマンス特性を持っています。メモ化はパフォーマンスの向上として使用され、大幅に実行時間を短縮することがあります。同じ基礎となる計算の異なる表現を生成する能力は、実際には非常に貴重です。従って、驚くべきことに、パフォーマンスに関しては全く関心がないにも関わらず、圏論は実用的な価値を持つ代替実装を探求するための豊富な機会を提供しています。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        ホム関手が\emph{C}内の恒等射を$\Set$内の対応する恒等関数に写すことを示してください。
  \item
        \code{Maybe}が表現可能でないことを示してください。
  \item
        \code{Reader}関手は表現可能ですか？
  \item
        \code{Stream}表現を使って、引数を二乗する関数をメモ化してください。
  \item
        \code{Stream}の\code{tabulate}と\code{index}が実際に互いの逆であることを示してください。 (ヒント: 帰納法を使用します。) 
  \item
        関手: 

        \begin{snip}{haskell}
Pair a = Pair a a
\end{snip}
        は表現可能です。それを表現する型を推測できますか？\code{tabulate}と\code{index}を実装してください。
\end{enumerate}

\section{参考文献}

\begin{enumerate}
  \tightlist
  \item
        表現可能関手についてのCatstersビデオ
        \urlref{https://www.youtube.com/watch?v=4QgjKUzyrhM}{representable
          functors}.
\end{enumerate}
