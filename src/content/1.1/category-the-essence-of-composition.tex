% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{圏}{は}驚くほど単純な概念です。圏 (category) は\newterm{対象 (object)} とそれらの間を結ぶ\newterm{矢印 (arrow)} で構成されます。だから圏は図示しやすいのです。対象は円や点として描かれ、矢印は\ldots{}矢印です。(たまに変わり種として、対象を豚として、矢印を花火として描くこともあります。) しかし、圏の本質は\emph{合成}です。もしくは、合成の本質が圏です。矢印は合成できるので、対象$A$から$B$への矢印があり、さらに$B$から$C$への矢印があるならば --- それらの合成である --- $A$から$C$への矢印が存在しなければなりません。

\begin{figure}
  \centering
  \includegraphics[width=0.8\textwidth]{images/img_1330.jpg}
  \caption{圏では、$A$から$B$への矢印と、$B$から$C$への矢印がある場合、それらの合成である$A$から$C$への直接の矢印も存在しなければなりません。この図は、恒等射 (後述) が欠けているため完全な圏ではありません。}
\end{figure}

\section{関数としての射}

抽象的すぎてナンセンスに感じますか？落胆しないでください。具体例で考えましょう。矢印、つまり\newterm{射 (morphism)} を関数と考えてみましょう。型$A$の引数を取り、$B$を返す関数$f$があります。そして、$B$を取り、$C$を返す別の関数$g$があります。それらを、$f$の結果を$g$に渡すことで合成することができます。これにより、$A$を取り、$C$を返す新しい関数が定義されました。

数学では、このような合成は関数の間に小さな円を置いて表されます: $g \circ f$。合成の順番が右から左であることに注意してください。この順序が混乱の原因となることもあります。Unixのパイプ記法`lsof | grep Chrome`や、F\#のchevron記法`>>`は左から右に進みますが、数学やHaskellでは関数は右から左に合成されます。「$g \circ f$」を「fの後にg」と読むと理解しやすいかもしれません。

さらに具体的にC言語のコードを書いてみましょう。型\code{A}の引数を取り、型\code{B}の値を返す関数\code{f}があります:

\begin{snip}{text}
B f(A a);
\end{snip}
もう一つあります:

\begin{snip}{text}
C g(B b);
\end{snip}
それらの合成は以下のようになります:

\begin{snip}{text}
C g_after_f(A a)
{
    return g(f(a));
}
\end{snip}
ここでも、再び右から左への合成が見られます: \code{g(f(a))}; 今回はC言語でです。

残念ながら、C++標準ライブラリには二つの関数を取ってその合成を返すテンプレートがないので、少しHaskellを試してみましょう。AからBへの関数の宣言は以下の通りです:

\src{snippet01}
同様に:

\src{snippet02}
その合成は:

\src{snippet03}
Haskellのシンプルさを見ると、C++で直接的な関数概念を表現することができないのは少し恥ずかしいです。実際、HaskellではUnicode文字を使用して合成を書くことができます:
% don't 'mathify' this block
\begin{snip}{text}
g ◦ f
\end{snip}

さらに、Unicodeの二重コロンと矢印も使用できます:
% don't 'mathify' this block
\begin{snipv}
f \ensuremath{\Colon} A → B
\end{snipv}
ここで最初のHaskellのレッスンです。二重コロンは「\ldots{}の型を持つ」という意味です。関数型は二つの型の間に矢印を挿入することで作成されます。二つの関数を合成するには、それらの間にピリオド (またはUnicodeの円) を挿入します。

\section{合成の特性}

どんな圏でも合成が満たさなければならない二つの非常に重要な特性があります。

\begin{enumerate}
  \item
        合成は結合的です。三つの射、$f$、$g$、および$h$が合成できる (つまり、それらの対象が端から端まで一致する) 場合、それらを合成するために括弧は必要ありません。数学的な記法では、これは以下のように表されます:
        \[h \circ (g \circ f) = (h \circ g) \circ f = h \circ g \circ f\]
        (擬似) Haskellでは以下のようになります:

        \src{snippet04}[b]
        (「擬似」と言ったのは、関数に対する等価性は定義されていないからです。)

        関数を扱う場合、結合性はかなり明白ですが、他の圏ではそうとは限りません。

  \item
        すべての対象$A$に対して、合成の単位となる射が存在します。この射は対象自体をループします。合成の単位であるとは、$A$から始まるか、または$A$で終わるいかなる射と合成しても、同じ射を返すということです。対象Aの単位射は$\idarrow[A]$ ($A$上の\newterm{恒等射}) と呼ばれます。数学的な記法では、$f$が$A$から$B$へ行く場合:
        \[f \circ \idarrow[A] = f\]
        そして
        \[\idarrow[B] \circ f = f\]
\end{enumerate}
関数を扱う場合、恒等射はその引数をそのまま返す恒等関数として実装されます。この実装はすべての型に対して同じであり、これは関数が普遍的に多相的であることを意味します。C++ではテンプレートとして定義することができます:

\begin{snip}{cpp}
template<class T> T id(T x) { return x; }
\end{snip}
もちろん、C++では何を渡すかだけでなく、どのように渡すかも考慮に入れなければなりません (つまり、値として、参照として、const参照として、ムーブとしてなど)。

Haskellでは、恒等関数は標準ライブラリ (Preludeと呼ばれる) の一部です。こちらがその宣言と定義です:

\src{snippet05}
ご覧の通り、Haskellでは多相的関数は簡単です。宣言で、型を型変数に置き換えるだけです。ポイントは、具体的な型の名前は常に大文字で始まり、型変数の名前は小文字で始まることです。ここでは\code{a}はすべての型を表しています。

Haskell関数の定義は関数名に続けて公式のパラメータが続きます --- ここではただ一つ、\code{x}です。関数の本体は等号に続きます。この簡潔さは初心者にとってしばしば衝撃ですが、すぐにそれが完全に理にかなっていることがわかります。関数の定義と関数の呼び出しは関数型プログラミングの中心であるため、その構文は最小限に抑えられています。引数リストの周りに括弧がなく、引数間にコンマがないことに気づくでしょう (後で、複数の引数を持つ関数を定義するときにこれを見ることになります) 。

関数の本体は常に式です --- 関数内には文がありません。関数の結果はこの式です --- ここでは、単に\code{x}です。

これで第二のHaskellレッスンが終了です。

恒等条件は (再び、擬似Haskellで) 以下のように書かれます:

\src{snippet06}
あなたは自分自身に疑問を持つかもしれません。なぜ誰かが何もしない恒等関数を気にするのでしょうか？それでも、なぜ私たちはゼロという数字を気にするのでしょうか？ゼロは無の象徴です。古代ローマ人はゼロのない数字システムを持っていましたが、それでも彼らは優れた道路や水道を建設しました。そのいくつかは今日まで残っています。

シンボル変数を扱うとき、ゼロや$\id$のような中立的な値は非常に便利です。それが、代数を得意としなかったローマ人と、ゼロの概念に精通していたアラブ人やペルシャ人の違いです。ですから、高階関数への引数として、または返り値として、恒等関数は非常に便利です。高階関数は関数の象徴的な操作を可能にするものです。それらは関数の代数です。

まとめると、圏は対象と矢印 (射) で構成されます。射は合成でき、その合成は結合的です。すべての対象には合成の単位となる恒等射があります。

\section{プログラミングの本質は合成}

関数型プログラマは問題に特有の方法でアプローチします。彼らは非常に禅的な質問から始めます。例えば、対話型プログラムを設計する際には、何が対話なのかと問います。コンウェイのライフゲームを実装する際には、生命の意味について考えるでしょう。この精神で、私たちはプログラミングとは何かという問いを立てます。最も基本的なレベルで、プログラミングはコンピュータに何をするかを伝えることです。「メモリアドレスxの内容をEAXレジスタの内容に加えてください。」しかし、たとえアセンブリ言語でプログラミングしていても、私たちがコンピュータに指示する命令は、より意味のある何かの表現です。私たちは重要な問題を解決しています (それが些細な問題であれば、コンピュータの助けは必要ないでしょう) 。そして、問題をどのように解決しますか？私たちは、大きな問題をより小さな問題に分解します。もし小さな問題がまだ大きすぎる場合は、さらに分解し続けます。そして最終的に、すべての小さな問題を解決するコードを書きます。そして、プログラミングの本質が現れます: それらのコードの断片を組み合わせて、より大きな問題の解決策を作り出します。分解は、分解した部分を再構築できなければ意味がありません。

この階層的な分解と再構成のプロセスは、コンピュータによって私たちに課されたものではありません。それは人間の心の限界を反映しています。私たちの脳は、一度に扱える概念の数が限られています。心理学で最も引用される論文の一つである「魔法の数字7±2」は、私たちが心に留めることができる「チャンク」の数は「7±2」であると主張しています。人間の短期記憶に対する理解の詳細は変わるかもしれませんが、それが限られていることは確かです。要するに、私たちはオブジェクトのスープやコードのスパゲッティを処理することはできません。私たちは構造を必要とするのです。それは、うまく構造化されたプログラムが見た目に楽しいからではなく、そうでなければ私たちの脳が効率的に処理できないからです。私たちはしばしばあるコードの断片をエレガントあるいは美しいと表現しますが、私たちが本当に意味しているのは、それが私たちの限られた人間の心にとって消化しやすいということです。エレガントなコードは、私たちの精神的な消化システムに取り込むのにちょうど良いサイズと数のチャンクを作り出します。

では、プログラムの構成に適したチャンクとは何でしょうか？その表面積は体積より遅く増加する必要があります。 (この類推が好きです。幾何学的な物体の表面積はサイズの二乗で増加し、体積はサイズの三乗で増加するという直感からです。) 表面積は、チャンクを構成するために必要な情報です。体積は、それらを実装するために必要な情報です。考え方は、一旦チャンクが実装されると、その実装の詳細を忘れて、他のチャンクとどのようにやり取りするかに集中できるということです。オブジェクト指向プログラミングでは、表面はオブジェクトのクラス宣言やその抽象インターフェースです。関数型プログラミングでは、それは関数の宣言です。 (少し単純化していますが、それが要点です。) 

圏論は極端な意味で、私たちに対象の内部を見ることを積極的に抑制します。圏論の対象は抽象的で曖昧な実体です。あなたがそれについて知り得るすべては、それがどのように他の対象と関係しているか、つまりそれが射を使ってどのように接続しているかです。これはインターネット検索エンジンが、インバウンドリンクとアウトバウンドリンクを分析することによってウェブサイトをランク付けする方法と似ています (彼らが不正を働かない限り) 。オブジェクト指向プログラミングでは、理想化されたオブジェクトはその抽象インターフェース (純粋な表面、ボリュームなし) を通じてのみ可視化され、メソッドは射の役割を果たします。オブジェクトの実装を掘り下げて、他のオブジェクトとどのように組み合わせるかを理解する必要がある瞬間に、あなたはプログラミングパラダイムの利点を失います。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        あなたのお気に入りの言語で恒等関数を、できるだけよく実装してください (もしHaskellがあなたのお気に入りの言語であれば、2番目に好きな言語で試してください) 。
  \item
        あなたのお気に入りの言語で合成関数を実装してください。それは2つの関数を引数として取り、それらの合成を返す関数です。
  \item
        あなたの合成関数が恒等を尊重するかどうかをテストするプログラムを書いてください。
  \item
        世界中のウェブはいかなる意味で圏ですか？リンクは射ですか？
  \item
        Facebookは圏ですか？人々を対象とし、友情を射とする場合。
  \item
        有向グラフはいつ圏になりますか？
\end{enumerate}

