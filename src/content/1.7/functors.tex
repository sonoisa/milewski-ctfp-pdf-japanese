% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{壊}{れた}レコードのように聞こえることを覚悟して、関手について言っておきます: 関手は非常にシンプルでありながら強力なアイディアです。圏論はそうしたシンプルで強力なアイディアでいっぱいです。関手とは圏間の写像です。2つの圏、$\cat{C}$ と $\cat{D}$ を与えられたとき、関手 $F$ は $\cat{C}$ の対象を $\cat{D}$ の対象へ写像します --- これは対象に対する関数です。もし $a$ が $\cat{C}$ の対象なら、私たちはその $\cat{D}$ での像を $F a$  (括弧なし) と書きます。しかし、圏は単に対象だけではありません --- それは対象とそれらを結ぶ射です。関手はまた射を写像します --- これは射に対する関数です。しかし、それは射を無造作に写像するのではありません --- それは接続を保存します。従って、もし射 $f$ が $\cat{C}$ で対象 $a$ から対象 $b$ へと繋がっているならば、
\[f \Colon a \to b\]
$\cat{D}$ での $f$ の像、$F f$ は $a$ の像を $b$ の像へと繋ぐでしょう: 
\[F f \Colon F a \to F b\]

 (これは数学とHaskellの表記法を混合したもので、今までに理解していただけたと願います。関手を対象や射に適用する際、私は括弧を使いません。) 

\begin{figure}[H]
  \centering\includegraphics[width=0.3\textwidth]{images/functor.jpg}
\end{figure}

\noindent
ご覧のとおり、関手は圏の構造を保存します: 一つの圏で繋がっているものは、他の圏でも繋がっています。しかし、圏の構造にはもう一つ重要なものがあります: 射の合成です。もし $h$ が $f$ と $g$ の合成ならば: 
\[h = g \circ f\]
私たちは $F$ によるその像が $f$ と $g$ の像の合成であることを望みます: 
\[F h = F g \circ F f\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/functorcompos.jpg}
\end{figure}

\noindent
最終的に、私たちは $\cat{C}$ の全ての恒等射が $\cat{D}$ の恒等射へ写像されることを望みます: 
\[F \idarrow[a] = \idarrow[F a]\]

\noindent
ここで、$\idarrow[a]$ は対象 $a$ での恒等射であり、$\idarrow[F a]$ は $F a$ での恒等射です。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/functorid.jpg}
\end{figure}

\noindent
これらの条件は関手を通常の関数よりもずっと制限的にします。関手は圏の構造を保存しなければなりません。もし圏を対象が射によって結び付けられたコレクションとして想像するならば、関手はこの布にいかなる裂け目も導入してはいけません。それは対象をまとめたり、複数の射を一つにまとめることはできますが、決して物事を分解してはなりません。この引き裂きを許さない制約は、あなたが微積分から知っているかもしれない連続性の条件に似ています。この意味で関手は「連続的」です (ただし、関手に対してはもっと制限的な連続性の概念が存在します)。関数のように、関手は崩壊させることも埋め込むこともできます。ソース圏がターゲット圏よりもずっと小さい場合、埋め込む側面がより目立ちます。極端な場合、ソースは自明な単一対象圏になります --- 一つの対象と一つの射 (恒等射) を持つ圏です。単一対象圏から他の任意の圏への関手は、単にその圏の中の対象を一つ選びます。これは完全に、単集合からの射がターゲット集合の要素を選ぶ性質と類似しています。最大限に崩壊させる関手は定値関手 $\Delta_c$ と呼ばれます。それはソース圏の全ての対象をターゲット圏の選ばれた一つの対象 $c$ に写像します。また、ソース圏の全ての射をターゲット圏の恒等射 $\idarrow[c]$ に写像します。それはブラックホールのように、全てを一つの特異点に凝縮させます。極限や余極限を議論する際に、この関手についてもっと見ることになるでしょう。

\section{プログラミングにおける関手}

地に足をつけてプログラミングについて話しましょう。私たちは型と関数の圏を持っています。私たちは自己関手と呼ばれる、この圏を自分自身へ写像する関手について話すことができます。では、型の圏における自己関手とは何でしょうか？まず第一に、それは型を型に写像します。私たちはそのような写像の例を、それがまさにそれであると気づかずに見てきました。私が話しているのは、他の型によってパラメータ化された型の定義です。いくつかの例を見てみましょう。

\subsection{Maybe関手}

\code{Maybe}の定義は型 \code{a} から型 \code{Maybe a} への写像です: 

\src{snippet01}
ここで重要な繊細さがあります: \code{Maybe}自体は型ではなく、\emph{型コンストラクタ}です。あなたはそれに型引数を与えなければなりません、例えば \code{Int} や \code{Bool} のように、それを型に変えるために。引数なしの \code{Maybe} は型に対する関数を表します。しかし、私たちは \code{Maybe} を関手にすることができるでしょうか？ (今後、プログラミングの文脈で関手について話すとき、私はほぼ常に自己関手を意味します。) 関手は対象 (ここでは型) の写像だけでなく、射 (ここでは関数) の写像でもあります。任意の関数 \code{a} から \code{b} へ: 

\src{snippet02}
私たちは \code{Maybe a} から \code{Maybe b} への関数を生成したいと思います。このような関数を定義するためには、\code{Maybe} の2つのコンストラクタに対応する2つのケースを考慮する必要があります。\code{Nothing} のケースは単純です: 私たちは単に \code{Nothing} を返します。そしてもし引数が \code{Just} ならば、私たちは関数 \code{f} をその内容に適用します。従って \code{f} の \code{Maybe} の下での像は次の関数です: 

\src{snippet03}
 (ところで、Haskellでは変数名にアポストロフィを使うことができます。これはこのような場合に非常に便利です。) Haskellでは、関手の射写像部分を \code{fmap} と呼ばれる高階関数として実装します。\code{Maybe} の場合、それは次のようなシグネチャを持ちます: 

\src{snippet04}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/functormaybe.jpg}
\end{figure}

\noindent
私たちはしばしば \code{fmap} が関数を \emph{持ち上げる}と言います。持ち上げられた関数は \code{Maybe} 値に作用します。通常のCurry化のために、このシグネチャは2つの方法で解釈されるかもしれません: 関数 \code{(a -> b)} を一つの引数として持つ関数として --- これは関数 \code{(Maybe a -> Maybe b)} を返します；または2つの引数を持つ関数として \code{Maybe b} を返します: 

\src{snippet05}
私たちの前の議論に基づいて、これが \code{Maybe} に対する \code{fmap} の実装です: 

\src{snippet06}
型コンストラクタ \code{Maybe} と関数 \code{fmap} が関手を形成することを示すためには、\code{fmap} が恒等性と合成を保存することを証明しなければなりません。これらは「関手則」と呼ばれますが、それらは単に圏の構造の保存を保証するだけです。

\subsection{等式推論}

関手則を証明するために、私は\newterm{等式推論}を使います。これはHaskellで一般的な証明手法です。それはHaskell関数が等式として定義される事実を利用します: 左辺は右辺と等しいです。あなたは常に一方を他方に代入することができます、変数の名前の衝突を避けるために名前を変更することが必要かもしれません。これを関数のインライン化、あるいは逆に、式を関数にリファクタリングすると考えてください。例えば、次のような恒等関数を考えてみましょう: 

\src{snippet07}
例えば、ある式で \code{id y} を見た場合、あなたはそれを \code{y} と置き換えることができます (インライン化)。さらに、式に \code{id} が適用されている場合、例えば \code{id (y + 2)} を見た場合、それを式自体 \code{(y + 2)} で置き換えることができます。そして、この置換は双方向で機能します: あなたは任意の式 \code{e} を \code{id e} で置き換えることができます (リファクタリング)。関数がパターンマッチングによって定義されている場合、あなたはそれぞれのサブ定義を独立して使用することができます。例えば、上記の \code{fmap} の定義を与えられた場合、\code{fmap f Nothing} を \code{Nothing} と置き換えることができます、またはその逆も可能です。これが実際にどのように機能するか見てみましょう。恒等性の保存から始めましょう: 

\src{snippet08}
\code{Nothing} と \code{Just} の2つのケースを考慮する必要があります。こちらが最初のケースです (私はHaskellの疑似コードを使用して左辺を右辺に変換します) : 

\begin{snip}{haskell}
  fmap id Nothing
= { definition of fmap }
  Nothing
= { definition of id }
  id Nothing
\end{snip}
最後のステップで \code{id} の定義を逆向きに使用しました。式 \code{Nothing} を \code{id Nothing} と置き換えました。実際には、このような証明を行う際には、「両端からキャンドルを燃やす」ようにして、中央で同じ式に達するまで進めます — ここではそれが \code{Nothing} でした。2番目のケースも同様に簡単です: 

\begin{snip}{haskell}
  fmap id (Just x)
= { definition of fmap }
  Just (id x)
= { definition of id }
  Just x
= { definition of id }
  id (Just x)
\end{snip}
次に、\code{fmap} が合成を保存することを示しましょう: 

\src{snippet09}
まず \code{Nothing} のケースから: 

\begin{snip}{haskell}
  fmap (g . f) Nothing
= { definition of fmap }
  Nothing
= { definition of fmap }
  fmap g Nothing
= { definition of fmap }
  fmap g (fmap f Nothing)
\end{snip}
それから \code{Just} のケース: 

\begin{snip}{haskell}
  fmap (g . f) (Just x)
= { definition of fmap }
  Just ((g . f) x)
= { definition of composition }
  Just (g (f x))
= { definition of fmap }
  fmap g (Just (f x))
= { definition of fmap }
  fmap g (fmap f (Just x))
= { definition of composition }
  (fmap g . fmap f) (Just x)
\end{snip}
等式推論が副作用を持つC++スタイルの「関数」には機能しないことを強調しておく価値があります。このコードを考えてみてください: 

\begin{snip}{cpp}
int square(int x) {
    return x * x;
}

int counter() {
    static int c = 0;
    return c++;
}

double y = square(counter());
\end{snip}
等式推論を使えば、\code{square} をインライン化して以下のようになります: 

\begin{snip}{cpp}
double y = counter() * counter();
\end{snip}
これは明らかに有効な変換ではなく、同じ結果を生み出すことはありません。それにもかかわらず、C++ コンパイラは \code{square} をマクロとして実装している場合、等式推論を試みるでしょう、その結果は災害になる可能性があります。

\subsection{Optional}

関手はHaskellで容易に表現されますが、ジェネリックプログラミングと高階関数をサポートするどんな言語でも定義することができます。C++の \code{Maybe} の類似物であるテンプレート型 \code{optional} を考えてみましょう。こちらが実装のスケッチです (実際の実装は引数の渡され方、コピー意味論、およびC++特有のリソース管理問題など、さまざまな側面を扱うため、はるかに複雑です) : 

\begin{snip}{cpp}
template<class T>
class optional {
    bool _isValid; // the tag
    T _v;
public:
    optional()    : _isValid(false) {}        // Nothing
    optional(T x) : _isValid(true) , _v(x) {} // Just
    bool isValid() const { return _isValid; }
    T val() const { return _v; } };
\end{snip}
このテンプレートは関手の定義の一部を提供します: 型の写像です。それは任意の型 \code{T} を新しい型 \code{optional<T>} に写像します。その関数の作用を定義しましょう: 

\begin{snip}{cpp}
template<class A, class B>
std::function<optional<B>(optional<A>)>
fmap(std::function<B(A)> f) {
    return [f](optional<A> opt) {
        if (!opt.isValid())
            return optional<B>{};
        else
            return optional<B>{ f(opt.val()) };
    };
}
\end{snip}
これは引数として関数を取

り、関数を返す高階関数です。こちらがCurry化されていないバージョンです: 

\begin{snip}{cpp}
template<class A, class B>
optional<B> fmap(std::function<B(A)> f, optional<A> opt) {
    if (!opt.isValid())
        return optional<B>{};
    else
        return optional<B>{ f(opt.val()) };
}
\end{snip}
\code{fmap} を \code{optional} のテンプレートメソッドとするオプションもあります。選択肢の多さが、C++で関手パターンを抽象化する問題を生み出しています。関手は継承するインターフェースとして定義されるべきですか (残念ながら、仮想テンプレート関数を持つことはできません)？それはCurry化された自由なテンプレート関数か、あるいはCurry化されていない自由なテンプレート関数か？C++コンパイラは欠けている型を正しく推測できるでしょうか、それともそれらは明示的に指定されるべきですか？入力関数 \code{f} が \code{int} から \code{bool} へのものである場合、コンパイラは \code{g} の型をどのようにして推測するでしょうか: 

\begin{snip}{cpp}
auto g = fmap(f);
\end{snip}
特に将来的には、\code{fmap} をオーバーロードする複数の関手が存在する可能性がある場合です。(もうすぐ私たちはもっと多くの関手を見ることになります。) 

\subsection{型クラス}

では、Haskellは関手の抽象化をどのように扱っているのでしょうか？それは型クラスメカニズムを使用します。型クラスは共通のインターフェースをサポートする型の族を定義します。例えば、等価性をサポートするオブジェクトのクラスは次のように定義されます: 

\src{snippet10}
この定義は、型 \code{a} が2つの \code{a} 型の引数を取り、\code{Bool} を返す演算子 \code{(==)} をサポートする場合、\code{Eq} クラスの型であると述べています。特定の型が \code{Eq} であるとHaskellに伝えたい場合、それをこのクラスの\newterm{インスタンス}と宣言し、\code{(==)} の実装を提供しなければなりません。例えば、2つの \code{Float} の積型である2次元の \code{Point} の定義が与えられた場合: 

\src{snippet11}
点の等価性を定義することができます: 

\src{snippet12}
ここで、演算子 \code{(==)} (私が定義しているもの) を2つのパターン \code{(Pt x y)} と \code{(Pt x' y')} の間の中置位置で使用しました。関数の本体は単一の等号に続いています。いったん \code{Point} が \code{Eq} のインスタンスとして宣言されると、直接点を等価性で比較することができます。C++やJavaとは異なり、\code{Point} を定義する際に \code{Eq} クラス (またはインターフェース) を指定する必要はなく、クライアントコードで後から行うことができます。型クラスはまた、関数 (および演算子) のオーバーロードのためのHaskell唯一のメカニズムです。私たちは異なる関手に対して \code{fmap} をオーバーロードするためにそれを必要とします。ただし、一つの複雑さがあります: 関手は型ではなく、型の写像、型コンストラクタとして定義されます。私たちは型ではなく、型コンストラクタの族である型クラスが必要です。幸いなことに、Haskellの型クラスは型コンストラクタと同じくらい型でも機能します。こちらが \code{Functor} クラスの定義です: 

\src{snippet13}
それは \code{f} が指定された型シグネチャを持つ関数 \code{fmap} が存在する場合、\code{Functor} であると規定します。小文字の \code{f} は型変数であり、型変数 \code{a} および \code{b} に似ています。しかし、コンパイラは、それが他の型に作用することによって、それが型コンストラクタであるという事実を推測することができます、例えば \code{f a} と \code{f b} のように。それに応じて、\code{Functor} のインスタンスを宣言する際には、\code{Maybe} のケースのように、型コンストラクタを与えなければなりません: 

\src{snippet14}
ちなみに、\code{Functor} クラスとそのインスタンス定義の多くは、\code{Maybe} を含む多くの単純データ型と共に標準のPreludeライブラリの一部です。

\subsection{C++における関手}

同じアプローチをC++で試すことはできますか？型コンストラクタに相当するものはテンプレートクラス、例えば \code{optional} のようなものですので、類推により、\code{fmap} を\newterm{テンプレートテンプレートパラメータ} \code{F} でパラメータ化したいと思います。これがそのための構文です: 

\begin{snip}{cpp}
template<template<class> F, class A, class B>
F<B> fmap(std::function<B(A)>, F<A>);
\end{snip}
私たちは異なる関手に対してこのテンプレートを特殊化することができるようにしたいのですが、残念ながらC++ではテンプレート関数の部分特殊化が禁止されています。以下のように書くことはできません: 

\begin{snip}{cpp}
template<class A, class B>
optional<B> fmap<optional>(std::function<B(A)> f, optional<A> opt)
\end{snip}
代わりに、関数のオーバーロードに頼らなければなりません。これにより、元のCurry化されていない \code{fmap} の定義に戻ります: 

\begin{snip}{cpp}
template<class A, class B>
optional<B> fmap(std::function<B(A)> f, optional<A> opt) {
    if (!opt.isValid())
        return optional<B>{};
    else
        return optional<B>{ f(opt.val()) };
}
\end{snip}
この定義は機能しますが、第二引数の \code{fmap} がオーバーロードを選択するため、より一般的な定義の \code{fmap} を完全に無視します。

\subsection{リスト関手}

プログラミングにおける関手の役割についての直感を得るためには、さらに多くの例を見る必要があります。任意の型が別の型によってパラメータ化される場合、それは関手の候補です。ジェネリックコンテナは保存している要素の型によってパラメータ化されるため、非常にシンプルなコンテナ、リストを見てみましょう: 

\src{snippet15}
私たちは型コンストラクタ \code{List} を持っており、それは任意の型 \code{a} を型 \code{List a} に写像します。 \code{List} が関手であることを示すためには、関数の持ち上げを定義する必要があります: 関数 \code{a -> b} を与えられて、関数 \code{List a -> List b} を定義します: 

\src{snippet16}
\code{List a} に作用する関数は2つのケースを考慮する必要があります、それはリストの2つのコンストラクタに対応します。\code{Nil} のケースは単純です --- 単に \code{Nil} を返します --- 空のリストに対してはそれ以上することがありません。\code{Cons} のケースは少し複雑ですが、再帰を含みます。私たちが何をしようとしているのか少し立ち止まって考えてみましょう。私たちは \code{a} のリストを持っており、\code{a} を \code{b} に変換する関数 \code{f} を持っており、そして私たちは \code{b} のリストを生成したいと思っています。\code{f} を使用してリストの各要素を \code{a} から \code{b} に変換することが明らかです。では、実際にどのようにしてこれを行うのでしょうか？非空リストがヘッドとテールの \code{Cons} として定義されていることを考えると、ヘッドに \code{f} を適用し、テールにリフトされた (\code{fmap} された) \code{f} を適用します。これは再帰的な定義です。私たちはリフトされた \code{f} を、それを定義しているリストよりも短いリストに適用しています --- それはそのテールです。私たちはより短いリストに向かって再帰していますので、最終的には空のリスト、つまり \code{Nil} に到達するはずです。しかし、先に決定したように、\code{fmap f} が \code{Nil} に作用すると \code{Nil} を返します、これによって再帰が終了します。最終結果を得るために、新しいヘッド \code{(f x)} と新しいテール \code{(fmap f t)} を \code{Cons} コンストラクタを使用して組み合わせます。全てをまとめると、こちらがリスト関手のインスタンス宣言です: 

\src{snippet18}
C++に慣れているなら、\code{std::vector} を考えてみてください。これは最も一般的なC++コンテナであると考えられています。 \code{std::vector} の \code{fmap} の実装は、\code{std::transform

} の薄いカプセル化に過ぎません: 

\begin{snip}{cpp}
template<class A, class B>
std::vector<B> fmap(std::function<B(A)> f, std::vector<A> v) {
    std::vector<B> w;
    std::transform( std::begin(v)
                  , std::end(v)
                  , std::back_inserter(w)
                  , f);
    return w;
}
\end{snip}
例えば、数列の要素を二乗するためにそれを使用することができます: 

\begin{snip}{cpp}
std::vector<int> v{ 1, 2, 3, 4 };
auto w = fmap([](int i) { return i*i; }, v);
std::copy( std::begin(w)
         , std::end(w)
         , std::ostream_iterator(std::cout, ", "));
\end{snip}
\code{std::transform} に渡すことができるイテレータを実装しているほとんどのC++コンテナは、よりプリミティブな \code{fmap} のいとこである \code{std::transform} によって、関手として機能します。残念ながら、イテレータや一時オブジェクトの通常のごちゃごちゃ (上記の \code{fmap} の実装を参照) の下に、関手の単純さが失われます。新しい提案されたC++レンジライブラリは、範囲の関手的な性質をはるかに顕著にします。

\subsection{Reader関手}

あなたがいくらかの直感を得たかもしれない今 — 例えば、関手は何らかのコンテナであるとか、少なくともそれらがパラメータ化されている型の値を含んでいるオブジェクトであるとか — まったく異なるものの例を示しましょう。型 \code{a} を \code{a} を返す関数の型への写像を考えてみてください。私たちは関数型について深くは話していません — その完全な圏論的扱いはこれから来ます — しかし、プログラマとしてそれらについてある程度の理解を持っています。Haskellでは、関数型は2つの型を取る矢印型コンストラクタ \code{(->)} を使用して構成されます: 引数型と結果型です。あなたは既にそれを中置形式で見てきました、\code{a -> b} ですが、括弧を使用すると接頭辞形式でも同様に使用することができます: 

\src{snippet19}
通常の関数と同様に、2つ以上の引数を持つ型関数は部分適用することができます。従って、矢印にただ一つの型引数を与えると、それはまだ別の型 \code{b} を必要としています。完全な型 \code{a -> b} を生成します。それが立っている状態では、それは型コンストラクタの全体の族を定義します。\code{a} によってパラメータ化された族です。これが関手の族であるかどうかを見てみましょう。2つの型パラメータを扱うことは少し混乱するかもしれませんので、いくつかのリネーミングをしましょう。引数型を \code{r} と呼び、結果型を \code{a} と呼びましょう、これは私たちの以前の関手定義と一致します。それで私たちの型コンストラクタは任意の型 \code{a} を型 \code{r -> a} に写像します。それが関手であることを示すためには、関数 \code{a -> b} を持ち上げて、\code{r -> a} を取り \code{r -> b} を返す関数を定義したいと思います。これらは、それぞれ、型コンストラクタ \code{(->) r} が \code{a} および \code{b} に作用するときに形成される型です。この場合に適用される \code{fmap} の型シグネチャはこちらです: 

\src{snippet21}
次のパズルを解かなければなりません: 関数 \code{f :: a -> b} と関数 \code{g :: r -> a} が与えられたとき、関数 \code{r -> b} を作成します。2つの関数を合成する唯一の方法があり、その結果はちょうど私たちが必要とするものです。それでこちらが私たちの \code{fmap} の実装です: 

\src{snippet22}
それはちょうど動作します！あなたが簡潔な表記が好きなら、この定義は合成を接頭辞形式で書き換えることによってさらに短縮されることができます: 

\src{snippet23}
そして、引数を省略することによって、2つの関数の直接的な等価性をもたらします: 

\src{snippet24}
この型コンストラクタ \code{(->) r} と上記の \code{fmap} の実装の組み合わせは、reader関手と呼ばれます。

\section{関手としてのコンテナ}

私たちは、一般的な目的のコンテナ、または少なくともそれらがパラメータ化されている型の値を含む何らかのオブジェクトを定義するプログラミング言語における関手の例をいくつか見てきました。Reader関手は外れ値のように思えるかもしれません。なぜなら私たちは関数をデータとして考えることはないからです。しかし、私たちは純粋関数がメモ化され得ること、そして関数実行がテーブルルックアップに変換され得ることを見てきました。テーブルはデータです。逆に、Haskellの遅延評価のために、伝統的なコンテナ、例えばリストは、実際には関数として実装され得ます。例えば、自然数の無限リストは、コンパクトに次のように定義され得ます: 

\src{snippet25}
最初の行では、リストのためのHaskellの組み込み型コンストラクタの一つのペアの角括弧があります。2行目では、リストリテラルを作成するために角括弧が使用されています。明らかに、このような無限リストはメモリに保存され得ません。コンパイラは需要に応じて \code{Integer} を生成する関数として実装します。Haskellは実効的にデータとコードの区別を曖昧にします。リストは関数と考えられ得、関数は引数を結果にマッピングするテーブルとして考えられ得ます。後者は関数の始域が有限で、かつ大きすぎない場合に実用的でさえあり得ます。しかしながら、\code{strlen} をテーブルルックアップとして実装することは実用的ではないでしょう。なぜなら、異なる文字列は無限に存在するからです。プログラマとしては、私たちは無限を好みませんが、圏論では無限を朝食にします。それが全ての文字列の集合であろうと、過去、現在、未来の宇宙の全ての可能な状態の集合であろうと --- 私たちはそれを扱うことができます！私は関手オブジェクト (自己関手によって生成される型のオブジェクト) を、それがパラメータ化されている型の値または値を含んでいるものと考えるのが好きです。たとえそれらの値が物理的に存在していないとしてもです。関手はC++の \code{std::future} のようなものであるかもしれません。それはいつか値を含むかもしれませんが、それが含まれるとは保証されておらず、そしてあなたがアクセスしようとすると、別のスレッドが実行を終えるのを待つかもしれません。別の例はHaskellの \code{IO} オブジェクトであり、それはユーザー入力を含むか、または「Hello World!」がモニターに表示される未来の宇宙のバージョンを含むかもしれません。この解釈に従うと、関手オブジェクトは、それがパラメータ化されている型の値を含むかもしれないもの、またはそれらの値を生成するためのレシピを含むかもしれないものです。私たちは値にアクセスできるかどうかにはまったく関心がありません。それは完全にオプションであり、関手の範囲外です。私たちが興味を持つのは、関数を使用してそれらの値を操作できること、値にアクセスできる場合は、この操作の結果を見ることができることです。もしそうでなければ、操作が正しく合成され、恒等関数での操作が何も変わらないことだけを気にします。関手オブジェクト内の値にアクセスできるかどうかを気にしないほど、こちらが \code{a} の引数を完全に無視する型コンストラクタです: 

\src{snippet26}
\code{Const} 型コンストラクタは2つの型、\code{c} と \code{a} を取ります。矢印コンストラクタと同じように、私たちは部分適用することによって関手を作成します。データコンストラクタ (\code{Const} も呼ばれます) は型 \code{c} の値をただ一つ取ります。それは \code{a} に依存しません。この型コンストラクタの \code{fmap} の型はこちらです: 

\src{snippet27}
関手がその型引数を無視するため、\code{fmap} の実装はその関数引数を無視する自由があります --- 関数が作用するものは何もありません: 

\src{snippet28}
これは

C++で少し明確になるかもしれません (私はそのようなことを言う日が来るとは思いませんでした！)、そこでは型引数と値の間には、コンパイル時と実行時というより強い区別があります: 

\begin{snip}{cpp}
template<class C, class A>
struct Const {
    Const(C v) : _v(v) {}
    C _v;
};
\end{snip}
\code{fmap} のC++実装も関数引数を無視し、本質的に \code{Const} 引数を再キャストしますが、その値を変更することはありません: 

\begin{snip}{cpp}
template<class C, class A, class B>
Const<C, B> fmap(std::function<B(A)> f, Const<C, A> c) {
    return Const<C, B>{c._v};
}
\end{snip}
その奇妙さにもかかわらず、\code{Const} 関手は多くの構成で重要な役割を果たします。圏論では、それは私が以前述べた $\Delta_c$ 関手の特別なケースです --- ブラックホールの自己関手ケースです。私たちはそれを将来もっと見ることになるでしょう。

\section{関手の合成}

関手が圏間で合成できると自分自身を納得させるのは難しいことではありません。集合間の関数が合成できるのと同じように、関手間でも合成できます。対象に作用するときの合成は、それぞれの対象写像の合成であり、射に作用するときも同様です。2つの関手を通じてジャンプした後、恒等射は恒等射として終わり、射の合成は射の合成として終わります。本当にそれ以上のものはありません。特に、自己関手の合成は容易です。私は\code{maybeTail}関数を使って書き直します。Haskellのリストの組み込み実装を使用します: 

\src{snippet29}
 (空のリストコンストラクタは、私たちが\code{Nil}と呼んでいたものが、空のペアの角括弧\code{{[}{]}}に置き換えられています。\code{Cons}コンストラクタは、コロン\code{:}という中置演算子に置き換えられています。) \code{maybeTail}の結果は、\code{a}に作用する2つの関手、\code{Maybe}と\code{{[}{]}}の合成の型です。それぞれの関手は自分のバージョンの\code{fmap}を装備していますが、もし私たちが合成されたもの、つまり\code{Maybe}リストの内容に関数\code{f}を適用したい場合はどうでしょうか？私たちは2層の関手を突破する必要があります。\code{fmap}を使って外側の\code{Maybe}を突破することができます。しかし、私たちは\code{f}を\code{Maybe}の内部に送ることはできません。なぜなら\code{f}はリスト上では機能しないからです。私たちは内部リストに作用するために\code{(fmap f)}を送らなければなりません。例えば、\code{Maybe}リストの整数の要素を二乗する方法を見てみましょう: 

\src{snippet30}
コンパイラは、型を分析した後、外側の\code{fmap}には\code{Maybe}インスタンスからの実装を使用し、内側のものにはリスト関手の実装を使用するべきだと判断します。上記のコードが次のように書き換えられることがすぐには明らかではないかもしれません: 

\src{snippet31}
しかし、\code{fmap}は1つの引数の関数として考えることができることを覚えておいてください: 

\src{snippet32}
私たちの場合、2番目の\code{fmap}で、\code{(fmap . fmap)}の中の\code{fmap}は次の引数を取ります: 

\src{snippet33}
そして、次の型の関数を返します: 

\src{snippet34}
最初の\code{fmap}はその関数を取り、次の型の関数を返します: 

\src{snippet35}
最後に、その関数は\code{mis}に適用されます。従って、2つの関手の合成は関手であり、その\code{fmap}は対応する\code{fmap}の合成です。圏論に戻って: 関手の合成が結合的であることはかなり明白です (対象の写像は結合的であり、射の写像も結合的です)。そして、すべての圏には自己関手として機能する自明な恒等関手があります: それはすべての対象をそれ自体にマッピングし、すべての射をそれ自体にマッピングします。だから関手は圏のいくつかの圏における射と同じ性質を持っています。しかし、その圏はどのようなものでしょうか？それは圏が対象であり、関手が射である圏でなければなりません。それは圏の圏です。しかし、\emph{全ての}圏の圏はそれ自体を含む必要があり、我々は「全ての集合の集合」が不可能であることを示す同じ種類の逆説に陥ります。しかし、対象が集合を形成する (つまり集合よりも大きい何かではない) 小さい圏の\emph{すべての}圏である $\Cat$ と呼ばれる圏はあります (それは大きいので、自分自身のメンバーにはなれません)。小さい圏とは、無限不可算集合でさえ「小さい」と見なされる圏論において、対象が集合を形成するものです。これらのことに触れるのは、私たちが抽象化の多くのレベルで同じ構造が繰り返されていることを認識できるのが非常に素晴らしいからです。私たちは後で見るでしょうが、関手もまた圏を形成します。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        \code{Maybe} 型コンストラクタを関手に変換することができますか？両方の引数を無視する次のように定義することによって: 

        \begin{snip}{haskell}
fmap _ _ = Nothing
\end{snip}

         (ヒント: 関手則をチェックしてください。) 
  \item
        reader関手の関手則を証明してください。ヒント: それは本当にシンプルです。
  \item
        あなたの2番目に好きな言語 (もちろん1番目はHaskellです) でreader関手を実装してください。
  \item
        リスト関手の関手則を証明してください。リストのテール部分にそれを適用するときに規則が真であると仮定します (言い換えれば、\emph{帰納法}を使ってください)。
\end{enumerate}

