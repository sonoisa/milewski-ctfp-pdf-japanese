% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{随}{伴}の強力な応用としての\newterm{自由関手}は、\newterm{忘却関手}の左随伴として定義されます。忘却関手は通常、ある構造を忘れるという、かなりシンプルな関手です。例えば、多くの興味深い圏は集合の上に構成されています。しかし、これらの集合を抽象化した圏論的対象は内部構造を持たず、要素を持ちません。それでも、これらの対象はしばしば集合の記憶を保持しており、ある圏$\cat{C}$から$\Set$への射としての写像 --- 関手 --- が存在します。ある対象の$\cat{C}$に対応する集合は、その\newterm{台集合}と呼ばれます。

モノイドは要素の集合を台集合として持つような対象です。モノイドの圏$\cat{Mon}$から集合の圏への忘却関手$U$は、モノイドをそれらの台集合へと写像し、モノイドの射 (準同型) を集合間の関数へと写像します。

$\cat{Mon}$は分裂した性格を持つと考えるのが好きです。一方で、それは乗法と単位要素を持つ集合の束です。一方で、それは対象が特徴のないもので、唯一の構造がその間にある射によって符号化される圏です。乗法と単位を保つすべての集合関数は、$\cat{Mon}$における射を生み出します。\\
\newline
心に留めておくべきこと:

\begin{itemize}
  \tightlist
  \item
        同じ集合に写像されるモノイドが多数存在するかもしれません。
  \item
        モノイドの射は、それらの台集合間の関数よりも少ない (または多くとも同じ数) です。
\end{itemize}

\noindent
忘却関手$U$に対する左随伴である関手$F$は、生成集合から自由モノイドを構成する自由関手です。この随伴関係は、以前議論した自由モノイドの普遍構成から導かれます。\footnote{第13章の\hyperref[free-monoids]{自由モノイド}を参照してください。}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{images/forgetful.jpg}
  \caption{モノイド$m_1$と$m_2$は同じ台集合を持ちます。$m_2$と$m_3$の台集合間の関数は、それらの間の射よりも多いです。}
\end{figure}

\noindent
ホム集合の観点から、この随伴関係を次のように書くことができます:
\[\cat{Mon}(F x, m) \cong \Set(x, U m)\]
この ($x$と$m$に対して自然な) 同型は、以下を示しています:

\begin{itemize}
  \tightlist
  \item
        $x$によって生成される自由モノイド$F x$と任意のモノイド$m$間のすべてのモノイド準同型に対して、生成集合$x$を$m$の台集合に埋め込む一意的な関数が存在します。それは$\Set(x, U m)$内の関数です。
  \item
        ある$m$の台集合に$x$を埋め込むすべての関数に対して、$x$によって生成された自由モノイドとモノイド$m$間の一意的な射が存在します。 (これは私たちが普遍構成で呼んだ射$h$です。) 
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{images/freemonadjunction.jpg}
\end{figure}

\noindent
直感的には、$F x$は$x$の基礎に構成できる「最大」のモノイドです。もし私たちがモノイドの内部を見ることができたなら、$\cat{Mon}(F x, m)$に属するどの射も、他のモノイド$m$にこの自由モノイドを\emph{埋め込む}ことを確認できるでしょう。それは、おそらくいくつかの要素を同一視することによって行われます。特に、$F x$の生成要素 (つまり$x$の要素) を$m$に埋め込みます。随伴関係は、右側にある$\Set(x, U m)$からの関数によって与えられる$x$の埋め込みが、左側にあるモノイドの埋め込みを一意に決定すること、そしてその逆もまた真であることを示しています。

Haskellでは、リストデータ構造は自由モノイドです (いくつかの注意点があります: \urlref{http://comonad.com/reader/2015/free-monoids-in-haskell/}{Dan
  Doel's blog post}を参照)。リスト型\code{{[}a{]}}は、生成集合を表す型\code{a}を持つ自由モノイドです。例えば、型\code{{[}Char{]}}は、単位要素 --- 空のリスト\code{{[}{]}} --- および単集合\code{{[}'a'{]}}, \code{{[}'b'{]}} --- 自由モノイドの生成要素を含みます。残りは「積」を適用することによって生成されます。ここでの積は、単に一方のリストをもう一方に追加することです。追加は結合的で単位的です (つまり、中立要素、ここでは空のリストがあります)。型\code{Char}によって生成される自由モノイドは、\code{Char}からのすべての文字列の集合に他なりません。これはHaskellでは\code{String}と呼ばれます:

\src{snippet01}
 (\code{type}は既存の型の別名、すなわち型同義名を定義します)。

もう一つの興味深い例は、ただ一つの生成要素から構成される自由モノイドです。それは単位のリストの型、\code{{[}(){]}}です。その要素は\code{{[}{]}}, \code{{[}(){]}}, \code{{[}(), (){]}},などです。そのようなリストの各々は、その長さという一つの自然数によって記述することができます。単位のリストにはそれ以上の情報はエンコードされていません。二つのそのようなリストを追加すると、その構成要素の長さの和である新しいリストが生成されます。型\code{{[}(){]}}が、自然数 (ゼロを含む) の加法モノイドと同型であることは容易にわかります。ここに、互いに逆である二つの関数があり、この同型性を証明しています:

\src{snippet02}
単純化のために\code{Int}型を使用しましたが、考え方は同じです。\code{replicate}関数は、指定された値 (ここでは単位) で事前に満たされた長さ\code{n}のリストを作成します。

\section{いくつかの直感}

以下に述べるのは、いくつかの手振り的な議論です。これらの種類の議論は厳密からは程遠いですが、直感を形成するのに役立ちます。

自由/忘却随伴についての直感を得るためには、関手と関数が本質的に情報損失を伴うということを心に留めておくと役立ちます。関手は複数の対象と射を折りたたむことがあり、関数は集合の複数の要素をまとめることがあります。また、それらの像は終域の一部のみをカバーするかもしれません。

$\Set$内の「平均的な」ホム集合には、最も情報損失が少ないもの (例えば、単射や、可能であれば同型) から、始域全体を単一の要素に収束させる定数関数まで、全ての関数のスペクトルが含まれるでしょう。

私は、任意の圏における射もまた情報損失を伴うものとして考えることがあります。これは単なる精神モデルですが、随伴関係を考えるとき、特に一方の圏が$\Set$である場合に、有用なモデルです。

形式的には、射が可逆である (同型) かそうでないかのみを議論することができます。後者の種類の射は、情報損失を伴うものと考えられるかもしれません。また、単射 (非収束) や全射 (全終域をカバー) 関数を一般化するモノ射やエピ射の概念もありますが、モノでありエピでありながら、それでも可逆でない射が存在する可能性があります。

Free ⊣ Forgetful随伴では、より制約された圏$\cat{C}$を左に、そしてより少ない制約を持つ圏$\cat{D}$を右に持ちます。$\cat{C}$内の射は「少ない」です。なぜなら、それらは追加の構造を保持する必要があるからです。$\cat{Mon}$の場合、それらは乗法と単位を保持する必要があります。$\cat{D}$内の射は、そこまで多くの構造を保持する必要がないため、「より多い」です。

ある対象$c$を$\cat{C}$から忘却関手$U$を使って写像するとき、私たちはそれを$c$の「内部構造」を明らかしていると考えます。実際、$\cat{D}$が$\Set$である場合、私たちは$U$が$c$の内部構造---その台集合---を\emph{定義}していると考えます。 (任意の圏では、他の対象との関連を通してしか対象の内部について話すことができませんが、ここでは手を振っているだけです。) 

二つの対象$c'$と$c$を$U$で写像するとき、一般的には$\cat{C}(c', c)$のホム集合の写像が$\cat{D}(U c', U c)$の部分集合のみをカバーすると期待されます。これは、$\cat{C}(c', c)$の射が追加の構造を保持する必要がある一方で、$\cat{D}(U c', U c)$の射はそうする必要がないためです。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth]{images/forgettingmorphisms.jpg}
\end{figure}

\noindent
しかし、随伴関係が特定のホム集合の\newterm{同型}として定義されているので、$c'$の選択に非常に注意しなければなりません。随伴関係では、$c'$は$\cat{C}$のどこからでも選ばれるのではなく、自由関手$F$の (おそらく小さい) 像から選ばれます:
\[\cat{C}(F d, c) \cong \cat{D}(d, U c)\]
したがって、$F$の像は、任意の$c$に多くの射を持つ対象から構成されなければなりません。実際には、$F d$から$c$への構造を保持する射が、$d$から$U c$への構造を保持しない射と同じ数だけ存在する必要があります。これは、$F$の像が本質的に構造のない「自由」対象でなければならないことを意味します。このような「構造のない」対象は自由対象と呼ばれます。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth]{images/freeimage.jpg}
\end{figure}

\noindent
モノイドの例では、自由モノイドは単位と結合則によって生成される以外の構造を持ちません。それ以外のすべての乗法は新しい要素を生み出します。

自由モノイドでは、$2 * 3$は$6$ではなく新しい要素${[}2, 3{]}$です。${[}2, 3{]}$と$6$を同一視しないため、この自由モノイドから任意の他のモノイド$m$への射は、それらを別々に写像することも、両方を$m$の同じ要素に写像することも、あるいは${[}2, 3{]}$と$5$ (それらの和) を加法モノイドで同一視することも許されます。異なる同一視が異なるモノイドを生み出します。

これは別の興味深い直感につながります: 自由モノイドは、モノイド演算を実行する代わりに、それに渡された引数を蓄積します。$2$と$3$を掛ける代わりに、$2$と$3$をリストに覚えています。このスキームの利点は、どのモノイド演算を使用するかを指定する必要がないことです。引数を蓄積し続け、最後に結果に演算子を適用することができます。そしてその時に初めて、どの演算子を適用するかを選ぶことができます。数字を足すことも、掛けることも、2を法とする加算を行うこともできます。自由モノイドは、式の作成と評価を分離します。代数について話すときに、この考え方を再び見ることになります。

この直感は、他のより複雑な自由構成にも一般化することができます。たとえば、評価する前に全体の式木を蓄積することができます。このアプローチの利点は、評価を高速化したり、メモリ消費を少なくするために、そのような木を変換できることです。これは、例えば、行列計算を実装する際に行われます。そこでは、積極的な評価が中間結果を格納する一時的な配列の多大な割り当てをもたらすでしょう。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        単一の生成要素から構成される自由モノイドを考えてください。この自由モノイドから任意のモノイド$m$への射と、単一の生成要素の集合から$m$の台集合への関

数との間に一対一の対応があることを示してください。
\end{enumerate}

