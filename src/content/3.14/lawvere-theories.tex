% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{最}{近}では、モナドに言及せずに関数型プログラミングについて語ることはできません。しかし、偶然にも、Eugenio MoggiがモナドではなくLawvere理論に注目した別の宇宙が存在します。その宇宙を探検しましょう。

\section{普遍代数}

代数を説明する方法は、抽象度の異なる様々な方法があります。私たちは、モノイド、群、環などのような構造を説明する一般的な言語を見つけようとしています。最も単純なレベルでは、これらの構造はすべて、集合の要素に対する\emph{操作}と、これらの操作によって満たされなければならないいくつかの\emph{規則}を定義します。例えば、結合的な二項演算によってモノイドを定義することができます。また、単位要素と単位則があります。しかし、少し想像力を働かせれば、単位要素を引数を取らない零項演算 --- 特定の集合の要素を返す演算に変えることができます。群について話す場合は、要素を取り、その逆要素を返す単項演算子を追加します。それに伴う左右の逆規則があります。環は2つの二項演算子といくつかの追加の規則を定義します。等々です。

大まかなところでは、代数は様々な$n$の値に対する$n$項演算の集合と、恒等式の集合によって定義されます。これらの恒等式はすべて全称量化されています。結合性に関する式は3つの要素のすべての可能な組み合わせに対して満たされなければならない、等々です。

偶然にも、これは0 (加法に関する単位要素) が乗法に関して逆を持たないという単純な理由で、体を考慮外にします。体の可逆則を全称量化することはできません。

この普遍代数の定義は、操作 (関数) を射に置き換えることにより、$\Set$以外の圏に拡張することができます。集合の代わりに、私たちは一般的な対象$a$ (一般対象 (generic object) と呼ばれます) を選択します。単項演算は$a$の自己同型です。しかし、他のアリティ (\newterm{アリティ}は与えられた演算の引数の数です) についてはどうでしょうか？二項演算 (アリティ2) は、積$a\times{}a$から$a$への射として定義することができます。一般的な$n$項演算は、$a$の$n$乗から$a$への射です: 
\[\alpha_n \Colon a^n \to a\]
零項演算は終対象 ($a$の0乗) からの射です。したがって、任意の代数を定義するために必要なのは、一つの特別な対象$a$のべき乗である対象を持つ圏だけです。特定の代数はこの圏のホム集合にエンコードされています。これがLawvere理論の要点です。

Lawvere理論の導出は多くのステップを経ますので、ここにロードマップを示します: 

\begin{enumerate}
  \tightlist
  \item
        有限集合の圏$\cat{FinSet}$
  \item
        そのスケルトン$\cat{F}$
  \item
        その逆$\Fop$
  \item
        Lawvere理論$\cat{L}$: 圏$\cat{Law}$の対象
  \item
        Lawvere圏のモデル$M$: 圏\\
        $\cat{Mod}(\cat{Law}, \Set)$の対象
\end{enumerate}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{images/lawvere1.png}
\end{figure}

\section{Lawvere理論}

すべてのLawvere理論は共通の背骨を共有しています。Lawvere理論のすべての対象は、単に積 (実際には、ただのべき乗) を使用してただ一つの対象から生成されます。しかし、一般的な圏でこれらの積をどのように定義しますか？積を定義するために、より単純な圏からのマッピングを使用することができることが判明しました。実際、このより単純な圏は積の代わりに余積を定義するかもしれませんが、私たちはそれらを目標の圏に埋め込むために\emph{反変}関手を使用します。反変関手は余積を積に変え、単射を射影に変えます。

Lawvere圏の背骨に自然な選択肢は、有限集合の圏、$\cat{FinSet}$です。これには空集合$\varnothing$、一つの要素を持つ集合$1$、2つの要素を持つ集合$2$、などが含まれます。この圏のすべての対象は、余積 (空集合を特殊な場合の零項余積として扱う) を使用して単一の要素集合から生成することができます。例えば、2つの要素を持つ集合は2つの単一要素の合計で、$2 = 1 + 1$として表現されます。これはHaskellで表現されます: 

\src{snippet01}
しかし、空集合がただ一つだと自然に思えるにもかかわらず、多くの異なる単集合が存在するかもしれません。特に、集合$1 + \varnothing$は集合$\varnothing + 1$とは異なり、$1$とも異なります --- それらはすべて同型です。集合の圏における余積は結合的ではありません。この状況を解決するために、すべての同型集合を識別する圏を構成することができます。このような圏は\newterm{スケルトン}と呼ばれます。言い換えれば、任意のLawvere理論の背骨は$\cat{FinSet}$のスケルトン$\cat{F}$です。この圏の対象は、$\cat{FinSet}$における要素カウントに対応する自然数 (ゼロを含む) として識別することができます。余積は加算の役割を果たします。$\cat{F}$の射は、有限集合間の関数に対応します。例えば、$\varnothing$から$n$への一意な射があります (空集合が始対象である)、$n$から$\varnothing$への射はありません ($\varnothing \to \varnothing$を除く)、$1$から$n$への$n$の射があります (単射)、$n$から$1$への一つの射、などです。ここで、$n$は$\cat{F}$内のすべての$n$要素集合を$\cat{FinSet}$で同型を通じて識別される対応する対象です。

$\cat{F}$を使用して、\newterm{Lawvere理論}を特別な関手と装備された圏$\cat{L}$として形式的に定義することができます: 
\[I_{\cat{L}} \Colon \Fop \to \cat{L}\]
この関手は対象上での単射でなければならず、有限積を保持しなければなりません ($\Fop$内の積は$\cat{F}$内の余積と同じです) : 
\[I_{\cat{L}} (m\times{}n) = I_{\cat{L}} m\times{}I_{\cat{L}} n\]
時々、この関手は対象上での恒等関手として特徴づけられることがあります。これは、$\cat{F}$と$\cat{L}$の対象が同じであることを意味します。したがって、私たちはそれらに同じ名前を使用します --- 自然数で表します。ただし、$\cat{F}$の対象が集合と同じではないことを念頭に置いてください (それらは同型集合のクラスです)。

$\cat{L}$のホム集合は、一般的に$\Fop$のそれよりも豊かです。それらは、$\cat{FinSet}$の関数に対応するもの以外の射を含む場合があります (後者は時々\newterm{基本積演算}と呼ばれます)。Lawvere理論の恒等則は、これらの射にエンコードされています。

重要な観察は、$\cat{F}$内の単集合$1$が$\cat{L}$内の何らかの対象$1$にマップされ、$\cat{L}$内の他のすべての対象が自動的にこの対象のべき乗になるということです。例えば、$\cat{F}$内の2つの要素集合$2$は余積$1 + 1$であるため、$\cat{L}$内で積$1 \times 1$ (または$1^2$) にマップされなければなりません。この意味では、圏$\cat{F}$は$\cat{L}$の対数のように振る舞います。

$\cat{L}$の射の中には、関手$I_{\cat{L}}$によって$\cat{F}$から転送されたものがあります。それらは$\cat{L}$内で構造的な役割を果たします。特に、余積の単射$i_k$は積の射影$p_k$になります。射影を想像する便利な直感は、次のように考えることです: 
\[p_k \Colon 1^n \to 1\]
これは$n$変数の関数の原型であり、$k^\text{th}$変数以外のすべてを無視します。逆に、$\cat{F}$内の定数射$n \to 1$は、$\cat{L}$内で対角射$1 \to 1^n$になります。これは変数の複製に対応します。

$\cat{L}$内の興味深い射は、射影以外の$n$項演算を定義するものです。これらの射が一つのLawvere理論を別のものと区別します。これらは代数を定義する乗算、加算、単位要素の選択などです。しかし、$\cat{L}$を完全な圏にするためには、$n \to m$ (または同等に、$1^n \to 1^m$) の複合演算も必要です。圏の単純な構造のために、それらは$n \to 1$のタイプのより単純な射の積であることがわかります。これは、積を返す関数が関数の積であるという言明の一般化です (または、以前に見たように、ホム関手は連続です)。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{images/lawvere1.png}
  \caption{Lawvere理論$\cat{L}$は$\Fop$に基づいており、それから積を定義する「退屈な」射を継承します。それは$n$項演算 (点線の矢印) を記述する「興味深い」射を追加します。}
\end{figure}

Lawvere理論は圏$\cat{Law}$を形成し、その射は有限積を保持し、関手$I$と交換する関手です。このような理論が2つある場合、$(\cat{L}, I_{\cat{L}})$と$(\cat{L'}, I'_{\cat{L'}})$、それらの間の射は、次のような関手$F \Colon \cat{L} \to \cat{L'}$です: 
\begin{gather*}
  F (m \times n) = F m \times F n \\
  F \circ I_{\cat{L}} = I'_{\cat{L'}}
\end{gather*}
Lawvere理論間の射は、一つの理論を別の理論内での解釈のアイデアを捉えます。例えば、群の乗法は逆を無視することでモノイドの乗法として解釈することができます。

Lawvere圏の最も単純な自明な例は、$\Fop$自体です ($I_{\cat{L}}$に対する恒等関手の選択に対応します)。このLawvere理論には操作や規則がないため、$\cat{Law}$内の始対象になります。

この時点で非自明な例を提示するのが非常に役立ちますが、まずモデルが何であるかを理解することなく説明するのは難しいでしょう。

\section{Lawvere理論のモデル}

Lawvere理論を理解する鍵は、そのような理論が同じ構造を共有する多くの個々の代数を一般化することを認識することです。例えば、モノイドのLawvere理論は、モノイドであることの本質を記述します。それはすべてのモノイドに対して有効でなければなりません。特定のモノイドは、そのような理論のモデルになります。モデルは、Lawvere理論$\cat{L}$から集合の圏$\Set$への関手として定義されます。 (他の圏を使用してLawvere理論を一般化することがありますが、ここでは$\Set$に集中しましょう。) $\cat{L}$の構造は積に大きく依存しているため、そのような関手は有限積を保持する必要があります。したがって、$\cat{L}$のモデル、またはLawvere理論$\cat{L}$上の代数は、次のように関手で定義されます: 
\begin{gather*}
  M \Colon \cat{L} \to \Set \\
  M (a \times b) \cong M a \times M b
\end{gather*}
積の保存は\emph{同型までの}ということに注意してください。これは非常に重要です。積の厳格な保存は、ほとんどの興味深い理論を排除します。

モデルによる積の保存は、$\Set$内の$M$のイメージが、集合$M 1$のべき乗によって生成される一連の集合であることを意味します --- 対象$1$からの集合$M 1$のイメージを呼びましょう。この集合を$a$とします。 (この集合は時々\emph{ソート}と呼ばれ、そのような代数は\newterm{単一ソート}と呼ばれます。Lawvere理論を多ソート代数に一般化することもあります。) 特に、$\cat{L}$からの二項演算は関数としてマップされます: 
\[a \times a \to a\]
任意の関手と同様に、$\cat{L}$内の複数の射が$\Set$内で同じ関数に折り畳まれる可能性があります。

偶然にも、すべての規則が全称量化された等式であるという事実は、すべてのLawvere理論が自明なモデルを持つことを意味します: すべての対象を単集合にマップし、すべての射をそれに対する恒等関数にマップする定数関手です。

一般的な射$m \to n$は、関数としてマップされます: 
\[a^m \to a^n\]
もし異なる2つのモデル、$M$と$N$があれば、それらの間の自然変換は$n$によって索引付けられた関数の族です: 
\[\mu_n \Colon M n \to N n\]
または同等に: 
\[\mu_n \Colon a^n \to b^n\]
ここで$b = N 1$です。

自然性条件は$n$項演算の保存を保証します: 
\[N f \circ \mu_n = \mu_1 \circ M f\]
ここで$f \Colon n \to 1$は$\cat{L}$内の$n$項演算です。

モデルを定義する関手は、モデルの圏$\cat{Mod}(\cat{L}, \Set)$を形成し、自然変換を射とします。

自明なLawvere圏$\Fop$のモデルを考えてみましょう。そのようなモデルは、$1$でのその値$M 1$によって完全に決定されます。$M 1$が任意の集合である場合、$\Set$内の集合の数だけこれらのモデルがあります。さらに、$\cat{Mod}(\Fop, \Set)$内のすべての射 (関手$M$と$N$間の自然変換) は、$M 1$でのそのコンポーネントによって一意に決定されます。逆に、$M 1 \to N 1$の任意の関数は、2つのモデル$M$と$N$の間の自然変換を誘導します。したがって$\cat{Mod}(\Fop, \Set)$は$\Set$と同値です。

\section{モノイドの理論}

最も単純な非自明な例としてモノイドのLawvere理論があります。これは、この理論のモデルがモノイドの全圏$\cat{Mon}$をスパンするすべての可能なモノイドの構造を蒸留する単一の理論です。私たちはすでに\hyperref[free-monoids]{普遍構成}を見てきました。これは、任意のモノイドが適切な自由モノイドから一部の射を識別することによって得られることを示しました。したがって、単一の自由モノイドはすでに多くのモノイドを一般化しています。しかしながら、無限に多くの自由モノイドがあります。モノイドのLawvere理論$\cat{L}_{\cat{Mon}}$は、それらを一つのエレガントな構造に組み合わせます。

すべてのモノイドには単位が必要なので、$\cat{L}_{\cat{Mon}}$内には$0$から$1$への特別な射$\eta$がなければなりません。$\cat{F}$内に対応する射は存在しないことに注意してください。そのような射は反対の方向、つまり$\cat{FinSet}$内で単集合から空集合への関数になります。そのような関数は存在しません。

次に、$2 \to 1$への射を考えます。これらは$\cat{L}_{\cat{Mon}}(2, 1)$のメンバーであり、すべての二項演算の原型を含まなければなりません。$\cat{Mod}(\cat{L}_{\cat{Mon}}, \Set)$内でモデルを構成するとき、これらの射はデカルト積$M 1 \times M 1$から$M 1$への関数にマップされます。言い換えれば、2つの引数を持つ関数です。

問題は、モノイド演算子を使用して実装できる2引数の関数がどれだけあるかです。2つの引数を$a$と$b$としましょう。両方の引数を無視してモノイド単位を返す関数が1つあります。次に、それぞれ$a$と$b$を返す2つの射影があります。それに続いて、$ab$、$ba$、$aa$、$bb$、$aab$などを返す関数があります\ldots{} 実際には、$a$と$b$のジェネレーターを持つ自由モノイドの要素と同じ数の2引数関数があります。$\cat{L}_{\cat{Mon}}(2, 1)$は、そのようなすべての射を含まなければなりません。なぜなら、そのモデルの1つは自由モノイドだからです。自由モノイドでは、それらは異なる関数に対応します。他のモデルは、$\cat{L}_{\cat{Mon}}(2, 1)$内の複数の射を単一の関数に折り畳むかもしれませんが、自由モノイドではそうではありません。

$n$ジェネレーターを持つ自由モノイドを$n^*$と表記すると、ホム集合$\cat{L}(2, 1)$をモノイドの圏$\cat{Mon}$内のホム集合$\cat{Mon}(1^*, 2^*)$と同一視することができます。一般に、$\cat{L}_{\cat{Mon}}(m, n)$を$\cat{Mon}(n^*, m^*)$とします。言い換えれば、圏$\cat{L}_{\cat{Mon}}$は自由モノイドの圏の逆です。

モノイドのLawvere理論の\emph{モデル}の圏、\\
$\cat{Mod}(\cat{L}_{\cat{Mon}}, \Set)$は、すべてのモノイドの圏、$\cat{Mon}$と同値です。

\section{Lawvere理論とモナド}

覚えているかもしれませんが、代数理論はモナドを使用して記述することができます --- 特に
\hyperref[algebras-for-monads]{モナドに関する代数}。それでは、Lawvere理論とモナドの間には接続があることに驚くことはありません。

まず、Lawvere理論がモナドをどのように誘導するかを見てみましょう。それは、忘却関手と自由関手の間の
\hyperref[free-forgetful-adjunctions]{随伴関係}
を通じて行われます。忘却関手$U$は、各モデルに集合を割り当てます。この集合は、$\cat{Mod}(\cat{L}, \Set)$からの関手$M$を$\cat{L}$の対象$1$で評価することによって与えられます。

$U$を導出する別の方法は、$\Fop$が$\cat{Law}$内の始対象であるという事実を利用することです。つまり、任意のLawvere理論$\cat{L}$に対して、一意の関手$\Fop \to \cat{L}$があります。この関手は、モデルに対する逆関手を誘導します (モデルは理論\emph{から}集合への関手です) : 
\[\cat{Mod}(\cat{L}, \Set) \to \cat{Mod}(\Fop, \Set)\]
しかし、私たちが議論したように、$\Fop$のモデルの圏は$\Set$と同値なので、忘却関手を取得します: 
\[U \Colon \cat{Mod}(\cat{L}, \Set) \to \Set\]
このように定義された$U$は常に左随伴、自由関手$F$を持つことが示されます。

これは有限集合に対して容易に見ることができます。自由関手$F$は自由代数を生成します。自由代数は、$\cat{Mod}(\cat{L}, \Set)$内の特定のモデルであり、生成器の有限集合$n$から生成されます。$F$は表現可能関手として実装することができます: 
\[\cat{L}(n, -) \Colon \cat{L} \to \Set\]
それが実際に自由であることを示すためには、それが忘却関手の左随伴であることを証明するだけです: 
\[\cat{Mod}(\cat{L}(n, -), M) \cong \Set(n, U(M))\]
右側を単純化しましょう: 
\[\Set(n, U(M)) \cong \Set(n, M 1) \cong (M 1)^n \cong M n\]
 (集合の射の集合が指数と同型であるという事実を使用しました。この場合、それは単に反復された積です。) 随伴は米田の補題の結果です: 
\[[\cat{L}, \Set](\cat{L}(n, -), M) \cong M n\]
一緒に、忘却と自由関手は$\Set$上の
\hyperref[monads-categorically]{モナド}
$T = U \circ F$を定義します。したがって、すべてのLawvere理論はモナドを生成します。

実は、このモナドの
\hyperref[algebras-for-monads]{代数の圏}は、モデルの圏に同値です。

モナドに関する代数は、モナドを使用して形成された式を評価する方法を定義します。Lawvere理論は$n$項演算を使用して式を生成する方法を定義します。モデルは、これらの式を評価する手段を提供します。

ただし、モナドとLawvere理論の接続は双方向ではありません。限定的なモナドのみがLawvere理論につながります。限定的なモナドは限定的な関手に基づいています。限定的な関手は$\Set$上でその有限集合への作用によって完全に決定されます。任意の集合$a$へのその作用は、次の余を使用して評価できます: 
\[F a = \int^n a^n \times (F n)\]
余は余積、または合計を一般化しますので、この式は冪級数展開の一般化です。または、関手が一般化されたコンテナであるという直感を使用することができます。その場合、$a$の限定的なコンテナは、形と内容の合計として記述できます。ここで、$F n$は$n$要素を格納するための形の集合であり、内容は$a^n$の要素の$n$組自体です。たとえば、リスト (関手として) は限定的であり、各アリティに1つの形を持ちます。ツリーにはアリティごとにより多くの形があります、などです。

まず、Lawvere理論から生成されるすべてのモナドは限定的であり、余エンドとして表現できます: 
\[T_{\cat{L}} a = \int^n a^n \times \cat{L}(n, 1)\]
逆に、$\Set$上の任意の限定的なモナド$T$が与えられた場合、Lawvere理論を構成することができます。$T$のKleisli圏を構成することから始めます。思い出してください、Kleisli圏の射は、基礎となる圏内の射によって与えられます: 
\[a \to T b\]
有限集合に制限された場合、これは次になります: 
\[m \to T n\]
このKleisli圏の逆圏、$\cat{Kl}^\mathit{op}_{T}$を有限集合に制限すると、問題のLawvere理論になります。特に、$\cat{L}$内で$n$項演算を記述するホム集合$\cat{L}(n, 1)$は、$\cat{Kl}_{T}(1, n)$のホム集合によって与えられます。

実際、プログラミングで遭遇するほとんどのモナドは限定的ですが、継続モナドが注目に値する例外です。限定的な操作を超えてLawvere理論の概念を拡張することは可能です。

\section{余エンドとしてのモナド}

余エンドの式をもう少し詳しく探ってみましょう。
\[T_{\cat{L}} a = \int^n a^n \times \cat{L}(n, 1)\]
始めに、この余エンドは$\cat{F}$内のプロ関手$P$に対して取られます: 
\[P n m = a^n \times \cat{L}(m, 1)\]
このプロ関手は、最初の引数$n$で反変です。それが射をどのように持ち上げるかを考えましょう。$\cat{FinSet}$内の射は有限集合のマッピング$f \Colon m \to n$です。このマッピングは$n$要素集合から$m$要素を選択することを説明します (繰り返しが許可されます)。それは$a$のべき乗へのマッピングに持ち上げられます、つまり (方向に注意してください) : 
\[a^n \to a^m\]
持ち上げは単純に$n$組の要素から$m$要素を選択します (繰り返しを伴って) $(a_1, a_2,...a_n)$。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/liftpower.png}
\end{figure}

たとえば、$f_k \Colon 1 \to n$を取ります。これは$n$要素集合から$k^\text{th}$要素を選択することを説明します。それは、$a$の$n$組から$k^\text{th}$要素を返す関数に持ち上げられます。

または、$f \Colon m \to 1$を取ります。これはすべての$m$要素を一つにマッピングする定数関数です。その持ち上げは、$a$の単一要素を取り、それを$m$回複製する関数です: 
\[\lambda{}x \to (\underbrace{x, x,\ ...\ , x}_{m})\]
このプロ関手が第二引数において共変であることは直ちに明らかではありません。ホム関手$\cat{L}(m, 1)$は実際には$m$において反変です。しかしながら、余エンドは$\cat{L}$の圏ではなく$\cat{F}$の圏で取られます。余エンド変数$n$は有限集合 (またはそのようなもののスケルトン) を渡ります。圏$\cat{L}$には$\cat{F}$の逆が含まれているので、$\cat{F}$の射$m \to n$は$\cat{L}$の$\cat{L}(n, m)$のメンバーです (埋め込みは関手$I_{\cat{L}}$によって与えられます)。

$\cat{F}$から$\Set$への関手として$\cat{L}(m, 1)$の関手性を確認しましょう。関数$f \Colon m \to n$を持ち上げることを目指していますので、$\cat{L}(m, 1)$から$\cat{L}(n, 1)$への関数を実装することが目標です。関数$f$に対応する$\cat{L}$内の射は$n$から$m$へです (方向に注意してください)。この射を$\cat{L}(m, 1)$と事前合成することで、$\cat{L}(n, 1)$の部分集合を得ます。

\begin{figure}[H]
  \centering
  \begin{tikzcd}[column sep=large]
    \cat{L}(m, 1) \arrow[r] & \cat{L}(n, 1)\\
    {}^m \bullet \arrow[r, "f"'] & \bullet^n
  \end{tikzcd}
\end{figure}

$1 \to n$の関数を持ち上げることにより、$\cat{L}(1, 1)$から$\cat{L}(n, 1)$へ行くことができます。後でこの事実を使用します。

プロ関手$a^n$と共変関手$\cat{L}(m, 1)$の積は、$\Fop \times \cat{F} \to \Set$へのプロ関手です。余エンドは、プロ関手のすべての対角コンポーネントの非交和 (disjoint sum) として定義され、いくつかの要素が特定されます。これらの識別は、余くさび条件に対応します。

ここでは、余エンドはすべての$n$にわたる集合$a^n \times \cat{L}(n, 1)$の非交和として始まります。識別は、プロ関手の非対角項$a^n \times \cat{L}(m, 1)$から出発して、対角線に到達するために、積の最初のコンポーネントまたは二番目のコンポーネントに射$f \Colon m \to n$を適用することによって生成されます。2つの結果はその後識別されます。

\begin{figure}[H]
  \centering
  \begin{tikzcd}
    & a^n \times \cat{L}(m, 1)
    \arrow[dl, "\langle f {,} \id \rangle"']
    \arrow[dr, "\langle \id {,} f \rangle"]
    & \\
    a^m \times \cat{L}(m, 1)
    & \scalebox{2.5}[1]{\sim}
    & a^n \times \cat{L}(n, 1) \\
    & f \Colon m \to n &
  \end{tikzcd}
\end{figure}

以前に示したように、$f \Colon 1 \to n$を持ち上げることにより、次の2つの変換が得られます: 
\[a^n \to a\]
そして: 
\[\cat{L}(1, 1) \to \cat{L}(n, 1)\]
したがって、$a^n \times \cat{L}(1, 1)$から始めて、次の両方に到達できます: 
\[a \times \cat{L}(1, 1)\]
$\langle f, \id \rangle$を持ち上げるときと、
\[a^n \times \cat{L}(n, 1)\]
$\langle \id, f \rangle$を持ち上げるときです。これは、$a^n \times \cat{L}(n, 1)$のすべての要素が$a \times \cat{L}(1, 1)$と識別されるわけではないことを意味します。$\cat{L}(n, 1)$のすべての要素が$\cat{L}(1, 1)$から基本射を適用することで到達できるわけではないからです。$\cat{F}$からの射を持ち上げることによってのみ構成できる非自明な$n$項演算は$\cat{L}$にあります。

言い換えると、余エンドの式に含まれるすべての加数を識別することができます。これは、$\cat{L}(n, 1)$が基本射を適用することによって$\cat{L}(1, 1)$から到達できる場合に限ります。それらはすべて$a \times \cat{L}(1, 1)$に等価です。基本射は、$\cat{F}$の射のイメージです。

$\Fop$自体のLawvere理論の最も単純な場合を見てみましょう。この理論では、すべての$\cat{L}(n, 1)$が$\cat{L}(1, 1)$から到達できます。これは$\cat{L}(1, 1)$がただの恒等射だけを含む一つの集合であり、$\cat{L}(n, 1)$が$\cat{F}$内の単射$1 \to n$に対応する射だけを含むからです。これらは\emph{基本}射です。したがって、余エンドのすべての加数は同等であり、結果は次のようになります: 
\[T a = a \times \cat{L}(1, 1) = a\]
これは恒等モナドです。

\section{副作用のLawvere理論}

モナドとLawvere理論の間に強い関連があるので、Lawvere理論がモナドの代わりにプログラミングで使用されるかどうかという疑問が自然に浮かびます。モナドの主な問題点は、それらがうまく構成されないことです。モナドトランスフォーマーを構成するための一般的なレシピがありません。この分野ではLawvere理論が優位性を持ちます: それらは余積やテンソル積を使用して構成することができます。一方、限定的なモナドのみが容易にLawvere理論に変換できます。ここでの例外は継続モナドです。この分野では現在も研究が進行中です。

副作用を記述するためにLawvere理論をどのように使用できるかの例を示すために、通常は\code{Maybe}モナドを使用して実装される例外の単純なケースを議論します。

\code{Maybe}モナドは、単一の零項演算$0 \to 1$を持つLawvere理論によって生成されます。この理論のモデルは、$1$をいくつかの集合$a$にマップし、零項演算を関数にマップする関手です: 

\src{snippet02}
余エンドの式を使用して\code{Maybe}モナドを回復することができます。零項演算の追加がホム集合$\cat{L}(n, 1)$にどのように影響するかを考えてみましょう。新しい$\cat{L}(0, 1)$を作成するだけでなく ($\Fop$には存在しない)、$\cat{L}(n, 1)$に新しい射を追加します。これらは、タイプ$n \to 0$の射と$0 \to 1$の私たちの射を合成することによって得られます。このような寄与は、余エンドの式の中で$a^0 \times \cat{L}(0, 1)$と識別されます。それらは、次から取得できます: 
\[a^n \times \cat{L}(0, 1)\]
$0 \to n$を2つの異なる方法で持ち上げることにより。

\begin{figure}[H]
  \centering
  \begin{tikzcd}
    & a^n \times \cat{L}(0, 1)
    \arrow[dl, "\langle f {,} \id \rangle"']
    \arrow[dr, "\langle \id {,} f \rangle"]
    & \\
    a^0 \times \cat{L}(0, 1)
    & \scalebox{2.5}[1]{\sim}
    & a^n \times \cat{L}(n, 1) \\
    & f \Colon 0 \to n &
  \end{tikzcd}
\end{figure}

余エンドは次のように簡約化されます: 
\[T_{\cat{L}} a = a^0 + a^1\]
または、Haskellの表記法を使用して: 

\src{snippet03}
これは次と同等です: 

\src{snippet04}
このLawvere理論は例外の発生のみをサポートしており、その処理はサポートしていません。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        $\cat{F}$ ($\cat{FinSet}$のスケルトン) 内で$2$と$3$の間のすべての射を列挙してください。
  \item
        モノイドのLawvere理論のモデルの圏が、リストモナドのモナド代数の圏に同値であることを示してください。
  \item
        モノイドのLawvere理論はリストモナドを生成します。対応するKleisli射を使用してその二項演算を生成できることを示してください。
  \item
        \textbf{FinSet}は$\Set$の部分圏であり、それを$\Set$に埋め込む関手があります。$\Set$上の任意の関手は$\cat{FinSet}$に制限することができます。限定的な関手がその制限の左Kan拡張であることを示してください。
\end{enumerate}

\section{参考文献}
\begin{enumerate}
  \tightlist
  \item
        \urlref{http://www.tac.mta.ca/tac/reprints/articles/5/tr5.pdf}{Functorial Semantics of Algebraic Theories}, F. William Lawvere
  \item
        \urlref{http://homepages.inf.ed.ac.uk/gdp/publications/Comp_Eff_Monads.pdf}{Notions of computation determine monads}, Gordon Plotkin and John Power
\end{enumerate}





