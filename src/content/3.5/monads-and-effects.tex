% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{モ}{ナド}が何のためにあるかを理解した今 --- それは飾り付けられた関数を合成するため --- 本当に興味深い問題は、なぜそのような関数が関数型プログラミングで重要なのかです。既に\code{Writer}モナドの例を見ましたが、飾り付けによって複数の関数呼び出しを通じてログを作成・蓄積することができました。これは通常、非純粋関数 (例えば、グローバル状態へのアクセスや変更) を使って解決される問題でしたが、純粋関数を用いて解決されました。

\section{問題点}

以下は、伝統的に関数の純粋性を放棄することで解決されてきた類似の問題の短いリストです。これは
\urlref{https://core.ac.uk/download/pdf/21173011.pdf}{Eugenio Moggiの画期的な論文}からの引用です。

\begin{itemize}
  \tightlist
  \item
        部分性: 終了しない可能性がある計算
  \item
        非決定性: 多くの結果を返す可能性がある計算
  \item
        副作用: 状態にアクセス／変更する計算

        \begin{itemize}
          \tightlist
          \item
                読み取り専用状態、または環境
          \item
                書き込み専用状態、またはログ
          \item
                読み書き状態
        \end{itemize}
  \item
        例外: 失敗する可能性がある部分関数
  \item
        継続: プログラムの状態を保存し、要求に応じてそれを復元する能力
  \item
        対話型入力
  \item
        対話型出力
\end{itemize}

これらの問題が同じ巧妙な技、すなわち飾り付けられた関数に頼ることで解決されるというのは本当に驚くべきことです。もちろん、各ケースでの飾り付けは全く異なります。

この段階で、飾り付けがモナド的である必要はありません。それは、私たちが合成を主張する --- 単一の飾り付けられた関数をより小さな飾り付けられた関数に分解することができる --- 時にのみ必要になります。再び、各装飾が異なるため、モナド的な合成は異なる方法で実装されますが、全体的なパターンは同じです。それは、恒等性を備えた結合的な合成の非常に単純なパターンです。

次のセクションはHaskellの例に重点を置いています。もしあなたが圏論に戻ることを切望しているか、またはHaskellのモナドの実装に既に精通しているならば、適宜読み飛ばすか完全にスキップしてください。

\section{解決策}

まず、\code{Writer}モナドを使用した方法を分析しましょう。私たちは特定のタスクを実行する純粋関数から始めました --- 引数が与えられたら、それは特定の出力を生成します。私たちはこの関数を、元の出力と文字列をペアにすることで飾り付けた別の関数に置き換えました。これがログ問題の解決策でした。

しかし、一般的には、私たちは単一の解決策で満足することはできません。一つのログ生成関数をより小さなログ生成関数に分解できるようにする必要がありました。これらの小さな関数の合成が私たちをモナドの概念へと導きました。

飾り付けられた関数の戻り値型を変更するというのは、通常純粋性を放棄する必要がある多くの問題に対する効果的な解決策であることが驚くべきです。リストを通して、それぞれの問題に適用される飾り付けを特定してみましょう。

\subsection{部分性}

終了しない可能性があるすべての関数の戻り値型を変更し、「持ち上げられた」型 --- 元の型のすべての値に特別な「ボトム」値 $\bot$ を加えた型にします。例えば、\code{Bool}型は、集合として二つの要素: \code{True}と\code{False}を含みます。持ち上げられた\code{Bool}には三つの要素が含まれます。持ち上げられた\code{Bool}を返す関数は\code{True}または\code{False}を生成するか、永遠に実行されるかもしれません。

面白いことに、Haskellのような怠惰な言語では、決して終わらない関数が実際には値を返すことがあり、この値は次の関数に渡されることがあります。私たちはこの特別な値をボトムと呼びます。この値が明示的に必要でない限り (例えば、パターンマッチングするため、または出力として生成するため)、それはプログラムの実行を停止させることなく渡されるかもしれません。Haskellのすべての関数が潜在的に非終了であるため、Haskellのすべての型は持ち上げられたものと見なされます。これが、私たちがしばしばHaskell (持ち上げられた) 型と関数の圏$\Hask$について話す理由ですが、$\Hask$が実際には本当の圏であるかどうかははっきりしていません (この
\urlref{http://math.andrej.com/2016/08/06/hask-is-not-a-category/}{Andrej
  Bauerの投稿}を参照)。

\subsection{非決定性}

多くの異なる結果を返す可能性がある関数は、一度にそれらをすべて返すこともできます。意味的には、非決定的な関数は結果のリストを返す関数と同等です。これは怠惰なガベージコレクション言語で非常に理にかなっています。例えば、1つの値だけが必要な場合、リストの先頭を取り出すことができますし、リストの後尾は評価されることはありません。ランダムな値が必要な場合は、乱数生成器を使用してリストのn番目の要素を選ぶことができます。怠惰さは無限の結果のリストを返すことさえ可能にします。

リストモナド --- Haskellにおける非決定的計算の実装 --- で\code{join}は\code{concat}として実装されます。覚えておいてください、\code{join}はコンテナのコンテナを平らにすることを意図しています --- \code{concat}はリストのリストを1つのリストに連結します。そして\code{return}は単一要素のリストを作成します: 

\src{snippet01}
リストモナドのためのbind演算子は、一般的な公式によって与えられます: 
\code{fmap}の後に\code{join}が続きます。この場合は以下のようになります: 

\src{snippet02}
ここで、関数\code{k}自体がリストを生成するものとして、リスト\code{as}の各要素に適用されます。結果はリストのリストであり、それは\code{concat}を使って平らにされます。

プログラマの視点からは、例えば非決定的な関数をループで呼び出したり、反復子を返す関数を実装するよりも、リストを扱う方が簡単です。

ゲームプログラミングにおいて非決定性を創造的に使用するのは良い例です。例えば、コンピュータが人間に対してチェスをする場合、相手の次の動きを予測することはできません。しかし、それはすべての可能な動きのリストを生成し、それらを1つずつ分析することができます。同様に、非決定的なパーサーは与えられた式のすべての可能な解析のリストを生成することができます。

関数がリストを返すことは非決定的として解釈することができますが、リストモナドの適用ははるかに広範です。それは、命令型プログラミングで使われる反復的な構造 --- ループ --- の完璧な関数型代替です。1つのループはしばしば、リストの各要素にループの本体を適用する\code{fmap}を使用して書き直すことができます。リストモナドにおける\code{do}表記は、複雑な入れ子のループを置き換えるために使用することができます。

私のお気に入りの例は、ピタゴラスの三つ組 --- 正しい三角形の辺を形成することができる正の整数の三つ組 --- を生成するプログラムです。

\src{snippet03}
最初の行は、\code{z}が無限の正の数のリスト\code{{[}1..{]}}から要素を取ることを教えています。その後、\code{x}は (有限の) リスト\code{{[}1..z{]}}から要素を取ります。このリストには1から\code{z}までの数が含まれています。最後に、\code{y}は\code{x}と\code{z}の間の数値のリストから要素を取ります。この時点で、$1 \leqslant x \leqslant x \leqslant y \leqslant z$ の3つの数を使用できます。関数 \code{guard} は \code{Bool} 式を取り、ユニットのリストを返します: 

\src{snippet04}
この関数 (より大きなクラスである \code{MonadPlus} のメンバー) は、ここでは非ピタゴラス三つ組をフィルタリングするために使用されています。実際、bind (または関連する演算子 \code{>>}) の実装を見ると、空のリストが与えられた場合、それは空のリストを生成することがわかります。一方、空でないリスト (ここでは、ユニットを含む単一要素のリスト \code{{[}(){]}}) が与えられた場合、bind は続行を呼び出し、ここでは \code{return (x, y, z)} で、検証済みのピタゴラス三つ組を含む単一要素のリストを生成します。これらの単一要素のリストは、結果的な (無限の) 結果を生成するために、囲んでいるbindによって連結されます。もちろん、\code{triples}の呼び出し側は決してリスト全体を消費することはできませんが、それは問題ではありません、なぜならHaskellは怠惰だからです。

通常、3つのネストしたループを必要とする問題が、リストモナドと \code{do} 表記の助けを借りて劇的に簡素化されました。それだけでなく、Haskellはこのコードをさらに簡素化することを可能にしています。それはリスト内包表記を使用することです: 

\src{snippet05}
これはリストモナドのためのさらなるシンタックスシュガーに過ぎません (厳密に言うと、\code{MonadPlus})。

他の関数型または命令型言語でジェネレーターやコルーチンの様相の下で類似の構造を見るかもしれません。

\subsection{読み取り専用状態}

何らかの外部状態、または環境に読み取り専用アクセスを持つ関数は、その環境を追加引数として取る関数に常に置き換えることができます。純粋関数 \code{(a, e) -> b} (ここで \code{e} は環境の型) は、最初の見た目にはKleisli射のようではありません。しかし、私たちがそれを
\code{a -> (e -> b)} にCurry化するとすぐに、飾り付けを私たちの古い友人であるReader関手として認識します: 

\src{snippet06}
\code{Reader} を返す関数を、環境を与えられた結果を生成するアクション、すなわちミニ実行可能ファイルとして解釈することができます。そのようなアクションを実行するためのヘルパー関数 \code{runReader} があります: 

\src{snippet07}
それは環境の異なる値に対して異なる結果を生成するかもしれません。

\code{Reader} を返す関数も、\code{Reader} アクション自体も純粋です。

\code{Reader} モナドのためのbindを実装するために、まず環境 \code{e} を取り、\code{b} を生成する関数を作成する必要があります: 

\src{snippet08}
ラムダの中で、私たちはアクション \code{ra} を実行して \code{a} を生成することができます: 

\src{snippet09}
それから、\code{a} を続行 \code{k} に渡して新しいアクション \code{rb} を得ることができます: 

\src{snippet10}
最後に、環境 \code{e} と共にアクション \code{rb} を実行することができます: 

\src{snippet11}
\code{return} を実装するために、私たちは環境を無視して変更されていない値を返すアクションを作成します。

それをすべてまとめると、いくつかの単純化の後に、次の定義が得られます: 

\src{snippet12}

\subsection{書き込み専用状態}

これは私たちの初期のロギングの例に過ぎません。飾り付けは \code{Writer} 関手によって与えられます: 

\src{snippet13}
完全性のために、データコンストラクタをアンパックするための些細なヘルパー \code{runWriter} もあります: 

\src{snippet14}
私たちが以前に見たように、\code{Writer} を合成可能にするためには、\code{w} がモノイドでなければなりません。ここにbind演算子に関して\code{Writer}のモナドインスタンスが書かれています: 

\src{snippet15}

\subsection{状態}

読み書きアクセスを持つ状態関数は、\code{Reader} と \code{Writer} の飾り付けを結合します。それらは純粋関数と考えることができます。それは追加の引数として状態を取り、結果として値／状態のペアを生成します: 
\code{(a, s) -> (b, s)}。Curry化後、私たちはそれらをKleisli射の形式にしています
\code{a -> (s -> (b, s))}、飾り付けは \code{State} 関手で抽象化されています: 

\src{snippet16}
再び、私たちはKleisli射がアクションを返すと見なすことができます。それはヘルパー関数を使用して実行することができます: 

\src{snippet17}
異なる初期状態は、異なる結果だけでなく、異なる最終状態も生成するかもしれません。

\code{State} モナドのためのbindの実装は、\code{Reader} モナドのそれと非常に似ていますが、各ステップで正しい状態を渡すための注意が必要です: 

\src{snippet18}
ここに完全なインスタンスがあります: 

\src{snippet19}
状態を操作するために使用することができる2つのヘルパーKleisli射もあります。そのうちの一つは検査のために状態を取得します: 

\src{snippet20}
そして、もう一つはそれを完全に新しい状態で置き換えます: 

\src{snippet21}

\subsection{例外}

例外をスローする命令型の関数は、本当は部分関数です --- それはその引数のいくつかの値に対して定義されていない関数です。純粋な全関数に関して例外を実装する最も単純な方法は \code{Maybe} 関手を使用することです。部分関数は、それが意味をなすときはいつでも \code{Just a} を返し、そうでないときは \code{Nothing} を返すように拡張された全関数になります。私たちが失敗の原因に関する情報も返したい場合、代わりに \code{Either} 関手を使用することができます (最初の型は例えば \code{String} に固定されます)。

ここに \code{Maybe} のための \code{Monad} インスタンスがあります: 

\src{snippet22}
\code{Maybe} のためのモナド的な合成が正しく計算をショートサーキットすることに注意してください (続行 \code{k} は決して呼ばれません)。それは私たちが例外から期待する振る舞いです。

\subsection{継続}

これは「私たちがあなたを呼ぶので、あなたは私たちを呼ばないでください！」という状況です。あなたが仕事の面接の後に経験するかもしれません。直接の答えを得る代わりに、結果で呼ばれるべきハンドラ、つまり関数を提供することになります。このスタイルのプログラミングは、特に結果が呼び出しの時点で知られていない場合に有用です。例えば、それが別のスレッドで評価されたり、リモートのウェブサイトから配信される場合です。この場合のKleisli射は、ハンドラを受け入れる関数を返します。これは「計算の残りの部分」を表します: 

\src{snippet23}
最終的に呼ばれるハンドラ \code{a -> r} は、最終結果型 \code{r} の結果を生成し、この結果は最後に返されます。継続は結果型によってパラメータ化されます。(実際には、これはしばしば何らかの種類の状態指標です。) 

Kleisli射が返すアクションを実行するためのヘルパー関数もあります。それはハンドラを取り、継続に渡します: 

\src{snippet24}
継続の合成は名高く難しいので、モナドを通じた、そして特に \code{do} 表記を通じた処理は極めて有利です。

bindの実装を理解しましょう。まずはシンプルなシグネチャを見てみましょう: 

\src{snippet25}
私たちの目標は、ハンドラ \code{(b -> r)} を取り、結果 \code{r} を生成する関数を作成することです。だからそれが私たちの出発点です: 

\src{snippet26}
ラムダの中で、私たちは適切なハンドラを持つ関数 \code{ka} を呼び出すことを望んでいます。このハンドラはラムダとして実装されます: 

\src{snippet27}
この場合、残りの計算にはまず \code{kab} で \code{a} を呼び出し、次に得られたアクション \code{kb} に \code{hb} を渡すことが含まれます: 

\src{snippet28}
ご覧のとおり、継続は内側から外側に合成されます。最終的なハンドラ \code{hb} は計算の最も内側の層から呼び出されます。こちらが完全なインスタンスです: 

\src{snippet29}

\subsection{対話型入力}

これは最も厄介な問題で、多くの混乱の原因となっています。明らかに、\code{getChar} のような関数がキーボードで入力された文字を返す場合、それは純粋ではあり得ません。しかし、それが文字をコンテナの中で返す場合はどうでしょうか？このコンテナから文字を抽出する方法がない限り、私たちはその関数が純粋だと主張することができます。あなたが \code{getChar} を呼び出すたびに、それは正確に同じコンテナを返します。概念的には、このコンテナはすべての可能な文字の重ね合わせを含んでいます。

もし量子力学に精通していれば、この類推を理解するのは問題ありません。それは、中を覗くことができないシュレーディンガーの猫が入っている箱のようなものです。箱は特別な組み込みの \code{IO} 関手を使用して定義されます。私たちの例では、\code{getChar} はKleisli射として宣言されることができます: 

\src{snippet30}
 (実際には、ユニット型からの関数は、戻り型の値を選ぶことと等価であるため、\code{getChar} の宣言は \code{getChar :: IO Char} に簡略化されます。) 

関手である \code{IO} は、\code{fmap} を使用してその内容を操作することを可能にします。そして、関手として、それは文字だけでなく、任意の型の内容を格納することができます。このアプローチの真の有用性は、Haskellで \code{IO} がモナドであると考えたときに明らかになります。それは、\code{IO} オブジェクトを生成するKleisli射を合成することができることを意味します。

Kleisli合成が \code{IO} オブジェクトの内容をのぞき見することを可能にすると思うかもしれません (量子論のアナロジーを続けるならば、「波動関数の崩壊」)。確かに、\code{getChar} を別のKleisli射、例えば文字を整数に変換するものと合成することができます。しかし、この第二のKleisli射は、この整数を \code{(IO\ Int)} として返すことしかできません。再び、あなたはすべての可能な整数の重ね合わせで終わるでしょう。そして、以下に続きます。シュレーディンガーの猫は決して袋から出ません。一度 \code{IO} モナドの中にいると、それから抜け出す方法はありません。 \code{runState} や \code{runReader} に相当するものは、\code{IO} モナドにはありません。\code{runIO} はありません！

では、もう一つのKleisli射でそれを合成する以外に、Kleisli射の結果、\code{IO} オブジェクトで何ができるでしょうか？まあ、それを \code{main} から返すことができます。Haskellでは、\code{main} は次のシグネチャを持っています: 

\src{snippet31}
そして、それをKleisli射として考える自由があります: 

\src{snippet32}
その観点から、Haskellプログラムは単に \code{IO} モナドでの1つの大きなKleisli射です。あなたはそれを小さなKleisli射からモナド的な合成を使用して構成することができます。それを何かするのはランタイムシステムに任されています (また、\code{IO} アクションと呼ばれます)。

射自体が純粋関数であることに注意してください --- それは純粋関数が一番下まで続いています。汚れた仕事はシステムに委ねられます。それが \code{main} から返された \code{IO} アクションを最終的に実行するとき、それはあらゆる種類のいやらしいことをします。例えば、ユーザー入力の読み取り、ファイルの変更、不快なメッセージの印刷、ディスクのフォーマットなどです。Haskellプログラムは決して自分の手を汚しません (まあ、それが \code{unsafePerformIO} を呼び出さない限りですが、それは別の話です)。

もちろん、Haskellが怠惰であるため、\code{main} はほぼ即座に戻り、汚れた仕事がすぐに始まります。純粋な計算の結果が要求され、必要に応じて評価されるのは、\code{IO} アクションの実行中です。従って、実際には、プログラムの実行は純粋な (Haskell) コードと汚れた (システム) コードの相互作用です。

\code{IO} モナドのもう一つの解釈は、さらに奇妙ですが、数学的モデルとして完全に理にかなっています。それはプログラム内のオブジェクトとして宇宙全体を扱うことです。概念的には、命令型モデルは宇宙を外部のグローバルオブジェクトとして扱うので、I/Oを実行する手続きはそのオブジェクトとの相互作用によって副作用を持っています。彼らは宇宙の状態を読み取り、変更することができます。

私たちは既に、関数型プログラミングで状態をどのように扱うかを知っています --- 私たちは状態モナドを使用します。しかし、宇宙の状態は単純な状態とは異なり、標準的なデータ構造を使用して簡単に記述することはできません。しかし、私たちがそれと直接的に相互作用しない限り、私たちはそれをしなくても済みます。存在すると仮定するだけで十分です、型 \code{RealWorld} があり、宇宙工学の何らかの奇跡によって、ランタイムがこの型のオブジェクトを提供することができると。 \code{IO} アクションは単なる関数です: 

\src{snippet33}
または \code{State} モナドの用語で: 

\src{snippet34}
ただし、\code{IO} モナドの \code{>=>} と \code{return} は言語に組み込まれていなければなりません。

\subsection{対話型出力}

同じ \code{IO} モナドは、対話型出力をカプセル化するために使用されます。 \code{RealWorld} はすべての出力デバイスを含むとされています。なぜ私たちは単にHaskellから出力関数を呼び出し、それらが何もしないふりをすることができないのか疑問に思うかもしれません。例えば、なぜ私たちは: 

\src{snippet35}
を持つのではなく、より単純な: 

\src{snippet36}
を持たないのでしょうか。二つの理由があります: Haskellは怠惰なので、使用されない出力 --- ここでは単位オブジェクト --- を持つ関数を決して呼び出しません。そして、怠惰でなかったとしても、それはまだそのような呼び出しの順序を自由に変更し、出力をめちゃくちゃにすることができます。Haskellで二つの関数の順次実行を強制する唯一の方法は、データ依存関係を通じてです。一方の関数の入力は、他方の関数の出力に依存する必要があります。\code{RealWorld} を \code{IO} アクション間で渡すことによって、シーケンシングが強制されます。

概念的には、このプログラムでは: 

\src{snippet37}
「World!」を印刷するアクションは、「Hello」がすでに画面にある宇宙を入力として受け取ります。それは画面に「Hello World!」がある新しい宇宙を出力として出力します。

\section{結論}

もちろん、私はモナド的プログラミングの表面をかすめただけです。モナドは、命令型プログラミングで通常副作用を使用して行われることを純粋関数で達成するだけでなく、高度な制御と型安全性を提供します。しかし、それらには欠点もあります。モナドに関する主な不満の一つは、それらが互いに容易に合成されないことです。確かに、モナド変換ライブラリを使用して、基本的なモナドのほとんどを組み合わせることができます。たとえば、状態と例外を組み合わせたモナドスタックを作成するのは比較的簡単ですが、任意のモナドを一緒に積み重ねるための公式はありません。
