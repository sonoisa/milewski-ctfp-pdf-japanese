% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{古}{代ギリシャ}の劇作家、エウリピデスはかつてこう言いました:「すべての人は、よく交わる仲間によって定義される。」関係によって私たちは定義される。圏論においてこれが真実である場所はない。特定の対象を圏内で一つだけにしたい場合、他の対象 (および自己) との関係のパターンを説明することによってのみこれを行うことができます。これらの関係は射によって定義されます。

圏論には、対象をそれらの関係に関して定義するための普遍構成と呼ばれる共通の構成法があります。これを行う一つの方法は、対象と射から構成された特定の形、あるパターンを選び、圏内でそのすべての発生を探すことです。それが十分に一般的なパターンであり、かつ圏が大きい場合、たくさんのヒットがあるでしょう。問題は、それらのヒットの中で何らかのランク付けを行い、最も適したものを選ぶことです。

このプロセスは、私たちがウェブ検索を行う方法を思い起こさせます。クエリはある種のパターンのようなものです。非常に一般的なクエリは大きなリコールをもたらします: たくさんのヒットがあります。その中には関連するものもあればそうでないものもあります。関連しないヒットを排除するために、クエリを洗練します。それによってその精度を高めます。最終的に、検索エンジンはヒットをランク付けし、望む結果がリストのトップに来ることを期待します。

\section{始対象}

最も単純な形は単一の対象です。明らかに、この形のインスタンスは、与えられた圏の対象の数と同じです。選択するには多すぎます。何らかのランク付けを行い、この階層のトップにある対象を見つけようと試みる必要があります。私たちの手元にある唯一の手段は射です。射を矢印と考えるなら、圏の一方の端から他方へと全体的な矢印の流れがあるかもしれません。これは、たとえば半順序のような順序圏で真実です。対象 $a$ が対象 $b$ よりも「より始まり側」であるということを、$a$ から $b$ への矢印 (射) がある場合に一般化することができます。そして、他のすべての対象に向かう矢印を持つ\emph{始対象}を定義します。明らかにそのような対象が存在するとは限らないのですが、それで問題ありません。より大きな問題は、そのような対象が多すぎるかもしれないことです: 再現率 (recall) は良いが、適合率 (precision) に欠けます。解決策は、順序圏からヒントを得ることです。順序圏は、任意の2つの対象の間に高々1つの射しか許さない: 1つの対象が他の対象よりも小さいか等しい一つの方法しかありません。これに導かれて始対象のこの定義に至ります:

\begin{quote}
  \textbf{始対象}は、圏内の任意の対象に向かって1つだけ射を持つ対象です。
\end{quote}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/initial.jpg}
\end{figure}

\noindent
しかし、これでも始対象の一意性 (存在する場合) を保証するわけではありません。しかし、次善のことを保証します: 同型\newterm{による一意性}。同型は圏論において非常に重要であり、その理由については間もなく話します。今のところ、同型による一意性が始対象の定義に「the」を使用することを正当化することに同意しましょう。

いくつかの例を挙げましょう: 半順序集合 (しばしば \newterm{poset} と呼ばれます) における始対象は、その最小要素です。いくつかの poset には始対象がありません。例えば、大小関係による射を持つすべての正と負の整数の集合です。

集合と関数の圏において、始対象は空集合です。空集合は Haskell の型 \code{Void} に対応し (C++には対応する型がありません)、\code{Void} から他の任意の型への一意の多相的関数は \code{absurd} と呼ばれます:

\src{snippet01}
\code{Void} を型の圏の始対象にするのは、この射の族です。

\section{終対象}

単一対象のパターンを続けてみましょうが、対象をランク付けする方法を変えます。対象 $a$ が対象 $b$ よりも「より終わり」であると言うことが、$b$ から $a$ への射がある場合に (矢印の方向が逆転したことに注意してください)。圏の中で他のどの対象よりも「より終わり」である対象を探します。再び、一意性を主張します:

\begin{quote}
  \textbf{終対象}は、圏内の任意の対象からそれに向かって1つだけ射を持つ対象です。
\end{quote}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/final.jpg}
\end{figure}

\noindent
そして再び、終対象は同型によって一意であり、それを間もなく示します。しかし、まずいくつかの例を見てみましょう。poset では、終対象が存在する場合、それは最大の対象です。集合の圏では、終対象は単集合です。私たちはすでに単集合について話しました。それは C++ の \code{void} 型と Haskell のユニット型 \code{()} に対応しています。それは唯一の値を持つ型です。C++では暗黙のうちに、Haskellでは明示的に、\code{()} として示されます。また、任意の型からユニット型への1つだけの純粋関数が存在することも確立しました:

\src{snippet02}
従って、終対象のすべての条件が満たされています。

この例では、一意性の条件が重要であることに注意してください。なぜなら、空集合を除いて、他のすべての集合 (実際にはそれらすべて) が各集合からの入ってくる射を持っているからです。例えば、次のようなブール値関数 (述語) があります:

\src{snippet03}
しかし \code{Bool} は終対象ではありません。少なくとも \code{Void} 以外の各型からもう1つ以上の \code{Bool} 値関数があります:

\src{snippet04}
一意性にこだわることで、終対象の定義を1つの型に正確に絞り込むことができます。

\section{双対性}

始対象と終対象を定義する方法の間には、明らかな対称性があります。唯一の違いは射の方向です。任意の圏 $\cat{C}$ に対して、すべての射を逆転させることによって\newterm{逆圏} $\cat{C}^\mathit{op}$ を定義することができます。逆圏は、同時に合成を再定義する限り、自動的に圏の要件を満たします。もともとの射 $f \Colon a \to b$ と $g \Colon b \to c$ が $h \Colon a \to c$ に合成され、$h = g \circ f$ であった場合、逆転した射 $f^\mathit{op} \Colon b \to a$ と $g^\mathit{op} \Colon c \to b$ は $h^\mathit{op} \Colon c \to a$ に合成され、$h^\mathit{op} = f^\mathit{op} \circ g^\mathit{op}$ になります。そして、恒等射を逆転させることは (冗談を言うと！) 無操作です。

双対性は、圏の非常に重要な性質です。なぜなら、それは圏論に取り組むすべての数学者の生産性を倍増させるからです。あなたが考案したすべての構成物には、その反対があります。そして、あなたが証明したすべての定理には、無料で1つもらえます。逆圏の構成物はしばしば「余 (co)」という接頭語が付けられるので、積と余積、モナドと余モナド、錐と余錐、極限と余極限などがあります。ただし、射を2回逆転させると元の状態に戻るため、余余モナドはありません。

それにより、終対象は逆圏における始対象であるということになります。

\section{同型}

プログラマとして、等価性を定義することが非自明な作業であることを私たちはよく知っています。2つの対象が等しいとはどういう意味ですか？ 彼らはメモリ内の同じ場所を占めなければならないのか？ (ポインタの等価性) それとも、すべてのコンポーネントの値が等しいことで十分でしょうか？ 2つの複素数が実部と虚部で表される場合と、大きさと角度で表される場合に等しいですか？ 数学者も等価性の意味を解明したわけではありません。彼らは提案的な等価性、内包的等価性、外延的等価性、ホモトピー型理論におけるパスとしての等価性など、複数の競合する等価性の定義を持っています。そして、それらは同型、さらに弱い概念である同値というより弱い概念を持っています。

直感的には、同型な対象は同じ形をしています。それぞれの対象の一部が一対一で他の対象の何らかの部分に対応しています。私たちの計測器具では、2つの対象は完璧なコピーです。数学的には、対象 $a$ から対象 $b$ への写像があり、対象 $b$ から対象 $a$ への写像があり、それらは互いに逆です。圏論では、写像を射に置き換えます。同型は、互いに逆である射のペア、または可逆な射です。

逆とは、合成と恒等射の観点で理解します。射 $g$ が射 $f$ の逆である場合、それらの合成は恒等射です。これは、2つの射を合成する2つの方法があるため、実際には2つの等式です: 

\src{snippet05}
始対象 (終対象) が同型によって一意であると言ったとき、私は任意の2つの始対象 (終対象) が同型であるという意味でした。それは実際には容易にわかります。2つの始対象 $i_{1}$ と $i_{2}$ を持っていると仮定します。$i_{1}$ が始対象であるので、$i_{1}$ から $i_{2}$ への一意の射 $f$ があります。同様に、$i_{2}$ が始対象であるので、$i_{2}$ から $i_{1}$ への一意の射 $g$ があります。これら2つの射の合成は何でしょうか？

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/uniqueness.jpg}
  \caption{この図のすべての射は一意です。}
\end{figure}

\noindent
合成 $g \circ f$ は $i_{1}$ から $i_{1}$ への射でなければなりません。しかし、$i_{1}$ は始対象なので、$i_{1}$ から $i_{1}$ への射はただ一つしかありません。私たちは圏にいるので、$i_{1}$ から $i_{1}$ への恒等射があることを知っています。そして、ただ一つの場所しかないので、それがそれでなければならない。従って $g \circ f$ は恒等射と等しいです。同様に、$f \circ g$ も恒等射と等しいです。なぜなら、$i_{2}$ から $i_{2}$ へ戻る射はただ一つしかありません。これにより、$f$ と $g$ は互いに逆でなければならないことが証明されます。従って、任意の2つの始対象は同型です。

この証明では、始対象からそれ自身への射の一意性を使用しました。それがなければ、私たちは「同型による一意性」の部分を証明することができません。しかし、$f$ と $g$ の一意性はなぜ必要なのでしょうか？ それは、始対象が同型によって一意であるだけでなく、\emph{一意の}同型によって一意であるからです。原理的には、2つの対象間に複数の同型が存在する可能性がありますが、ここではそうではありません。この「一意の同型による一意性」は、すべての普遍構成の重要な性質です。

\section{積}

次の普遍構成は、積です。2つの集合の直積が何であるかはわかっています: それはペアの集合です。しかし、積集合とその構成要素をつなぐパターンは何でしょうか？ それがわかれば、他の圏にそれを一般化することができます。

積からそれぞれの構成要素への2つの関数、射影があるということだけが言えます。Haskellでは、これら2つの関数はそれぞれ \code{fst} と \code{snd} と呼ばれ、ペアの第一コンポーネントと第二コンポーネントを選びます:

\src{snippet06}

\src{snippet07}
ここでは、引数に対するパターンマッチングによって関数が定義されています: 任意のペアにマッチするパターンは \code{(x, y)} で、そのコンポーネントを変数 \code{x} と \code{y} に抽出します。

これらの定義は、ワイルドカードの使用によってさらに単純化することができます: 

\src{snippet08}
C++では、たとえばテンプレート関数を使用します: 

\begin{snip}{cpp}
template<class A, class B> A
fst(pair<A, B> const & p) {
    return p.first;
}
\end{snip}
この非常に限られた知識を武器に、集合の圏で2つの集合 $a$ と $b$ の積の構成につながる対象と射のパターンを定義しようとします。このパターンは、対象 $c$ と $a$ と $b$ にそれぞれ接続された2つの射 $p$ と $q$ で構成されます: 

\src{snippet09}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/productpattern.jpg}
\end{figure}

\noindent
このパターンに適合するすべての $c$ は、積の候補と見なされます。それらはたくさんあるかもしれません。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/productcandidates.jpg}
\end{figure}

\noindent
例えば、2つの Haskell 型、\code{Int} と \code{Bool} を構成要素として選び、それらの積の候補のサンプリングを得ましょう。

こちらは一つ: \code{Int}。 \code{Int} は \code{Int} と \code{Bool} の積の候補と見なすことができますか？ はい、それは可能です。そして、その射影はこちらです: 

\src{snippet10}
それはかなり物足りないですが、基準に合っています。

こちらは別の例: \code{(Int, Int, Bool)}。それは3つの要素、または3つ組のタプルです。こちらはそれを正当な候補にする2つの射です (3つ組に対するパターンマッチングを使用しています) : 

\src{snippet11}
お気づきかもしれませんが、最初の候補は小さすぎます。それは積の \code{Int} の次元だけをカバーしています。一方、2番目は大きすぎます。それは \code{Int} の次元を不必要に複製しています。

しかし、私たちはまだ普遍構成のもう一方の部分、ランキングを探検していません。私たちは2つのパターンのインスタンスを比較することができるようにしたいです。候補の対象 $c$ とその2つの射影 $p$ と $q$ を、別の候補の対象 $c'$ とその2つの射影 $p'$ と $q'$ と比較したいです。$c$ が $c'$ よりも「良い」と言いたいのですが、そのためには $c'$ から $c$ への射 $m$ があることが不十分です。私たちは、その射影が $c'$ の射影よりも「より普遍的」、「より良い」であることも望みます。それが意味するのは、射影 $p'$ と $q'$ が $m$ を使って $p$ と $q$ から再構成できることです: 

\src{snippet12}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/productranking.jpg}
\end{figure}

\noindent
これらの等式を別の角度から見ると、$m$ が $p'$ と $q'$ を\emph{因数分解}します。これらの等式が自然数であり、ドットが乗算であると想像してください: $m$ は $p'$ と $q'$ に共通する因子です。

少し直感を養うために、ペア \code{(Int, Bool)} と2つの標準的な射影、\code{fst} と \code{snd} が実際には前に提示した2つの候補よりも\emph{良い}ことを示しましょう。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/not-a-product.jpg}
\end{figure}

\noindent
最初の候補のための写像 \code{m} は: 

\src{snippet13}
確かに、2つの射影、\code{p} と \code{q} は再構成できます:

\src{snippet14}
2番目の例のための \code{m} も同様に一意に決まります: 

\src{snippet15}
私たちは \code{(Int, Bool)} が2つの候補よりも良いことを示すことができました。逆が真実ではない理由を見てみましょう。 \code{fst} と \code{snd} を \code{p} と\code{q} から再構成するための何らかの \code{m'} を見つけることができますか？

\src{snippet16}
最初の例では、\code{q} は常に \code{True} を返し、私たちはペアの第二コンポーネントが \code{False} であるものがあることを知っています。\code{q} から \code{snd} を再構成することはできません。

第二の例は異なります: 私たちは \code{p} または \code{q} を実行した後でも十分な情報を保持していますが、\code{fst} と \code{snd} を因数分解する方法は複数あります。というのも、\code{p} と \code{q} の両方が三つ組の第二コンポーネントを無視するため、\code{m'} はそれに何を入れても構いません。以下のようにすることができます: 

\src{snippet17}

または
\src{snippet18}
などがあります。

すべてをまとめると、任意の型 \code{c} と2つの射影 \code{p} と \code{q} が与えられると、\code{c} から直積 \code{(a, b)} への一意の \code{m} が存在し、それらを因数分解します。実際、それは単に \code{p} と \code{q} をペアに組み合わせるだけです。

\src{snippet19}
これにより、直積 \code{(a, b)} が最適な一致となり、これは集合の圏におけるこの普遍構成が機能していることを意味します。任意の2つの集合の積を選びます。

今、集合について忘れて、同じ普遍構成を使用して任意の圏で2つの対象の積を定義しましょう。そのような積が常に存在するわけではありませんが、存在するときは、一意の同型まで一意です。

\begin{quote}
  2つの対象 $a$ と $b$ の\textbf{積}は、2つの射影を備えた対象 $c$ であり、他の任意の対象 $c'$ が2つの射影を備えている場合、それらの射影を因数分解する一意の射 $m$ が $c'$ から $c$ へ存在します。
\end{quote}

\noindent
因数分解する関数を生成する (高次の) 関数は、時々\newterm{因数分解器}と呼ばれます。私たちの場合、それは以下の関数です: 

\src{snippet20}

\section{余積}

圏論のすべての構成のように、積にも双対があり、余積と呼ばれます。積のパターンで射を逆転させると、2つの\emph{入射 (injection)}、\code{i} と \code{j} を備えた対象 $c$ に終わります。これらは $a$ と $b$ から $c$ への射です。

\src{snippet21}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/coproductpattern.jpg}
\end{figure}

\noindent
ランキングも逆転します: 対象 $c$ が入射 $i'$ と $j'$ を備えた対象 $c'$ よりも「良い」場合、$c$ から $c'$ への射 $m$ が存在し、その入射を因数分解します: 

\src{snippet22}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/coproductranking.jpg}
\end{figure}

\noindent
そのような対象の「最良」のもの、つまり他のどのパターンにも一意の射で結びつけるものは、余積と呼ばれ、存在する場合、一意の同型まで一意です。

\begin{quote}
  2つの対象 $a$ と $b$ の\textbf{余積}は、2つの入射を備えた対象 $c$ であり、他の任意の対象 $c'$ が2つの入射を備えている場合、それらの入射を因数分解する一意の射 $m$ が $c$ から $c'$ へ存在します。
\end{quote}

\noindent
集合の圏では、余積は2つの集合の\emph{非交和 (disjoint union)}です。$a$ と $b$ の非交和の要素は、$a$ の要素か $b$ の要素のいずれかです。2つの集合が重なる場合、非交和には共通部分の2つのコピーが含まれます。非交和の要素を、その起源を指定する識別子でタグ付けされていると考えることができます。

プログラマにとって、型の観点から余積を理解する方が簡単です。それは2つの型のタグ付きユニオンです。C++はユニオンをサポートしていますが、それらはタグ付けされていません。つまり、プログラムではどのユニオンメンバーが有効かどうかを何らかの方法で追跡する必要があります。タグ付きユニオンを作成するには、タグとしての列挙体を定義し、それをユニオンと組み合わせる必要があります。たとえば、\code{int} と \code{char const *} のタグ付きユニオンは、次のように実装することができます:

\begin{snip}{cpp}
struct Contact {
    enum { isPhone, isEmail } tag;
    union { int phoneNum; char const * emailAddr; };
};
\end{snip}
2つの入射は、コンストラクタまたは関数として実装することができます。例えば、こちらは最初の入射としての関数 \code{PhoneNum} です:

\begin{snip}{cpp}
Contact PhoneNum(int n) {
    Contact c;
    c.tag = isPhone;
    c.phoneNum = n;
    return c;
}
\end{snip}
これにより、整数が \code{Contact} に注入されます。

タグ付きユニオンは、\newterm{バリアント}とも呼ばれます。そして、boost ライブラリには、\code{boost::variant} として非常に一般的なバリアントの実装があります。

Haskellでは、任意のデータ型を縦棒で区切ったデータコンストラクタを使用してタグ付きユニオンに組み合わせることができます。\code{Contact} の例は、宣言に次のように翻訳されます:

\src{snippet23}
ここで、\code{PhoneNum} と \code{EmailAddr} は、コンストラクタ (入射) としても機能し、パターンマッチングのためのタグとしても機能します (後で詳しく説明します)。たとえば、これは電話番号を使用してコンタクトを作成する方法です:

\src{snippet24}
プリミティブペアとして Haskell に組み込まれている積の標準的な実装とは異なり、余積の標準的な実装は \code{Either} というデータ型で、標準 Prelude で次のように定義されています:

\src{snippet25}
これは2つの型、\code{a} と \code{b} にパラメータ化されており、2つのコンストラクタがあります: \code{a} 型の値を取る \code{Left} と、\code{b} 型の値を取る \code{Right} です。

積のために因数分解器を定義したように、余積のためにも定義することができます。候補の型 \code{c} と2つの候補の入射 \code{i} と \code{j} が与えられた場合、\code{Either} の因数分解器は因数分解関数を生成します:

\src{snippet26}

\section{非対称性}

私たちは2つの双対な定義セットを見てきました: 始対象の定義は射の方向を逆転させることによって終対象の定義から得られ、同様に、余積の定義は積の定義から得られます。それでも、集合の圏では始対象は終対象とは非常に異なり、余積は積と非常に異なります。後で見るように、積は乗法のように振る舞い、終対象は1の役割を果たし、一方で余積は和のように振る舞い、始対象は0の役割を果たします。特に有限集合の場合、積のサイズは個々の集合のサイズの積であり、余積のサイズはサイズの和です。

これは、射の反転に関して集合の圏が対称ではないことを示しています。

空集合は任意の集合に一意の射 (\code{absurd} 関数) を持っていますが、それに戻ってくる射はありません。一方、単集合は任意の集合から一意の射を持っていますが、それは (空集合を除いて) すべての集合に出ていく射も持っています。前に見たように、終対象からのこれらの出ていく射は、他の集合から要素を選ぶための非常に重要な役割を果たします (空集合には要素がないので、何も選ぶことはできません)。

単集合をユニット型 \code{()} として表し、さらに別の候補として積のパターンに使用することで、それを他のものとは区別します。それに2つの射影 \code{p} と \code{q} を装備します。それぞれが単集合から構成要素の集合のそれぞれに向かう関数です。積が普遍的であるため、単集合から積への (一意の) 射 \code{m} もまたあります。この射は積集合から具体的なペアを選び

出し、また2つの射影を因数分解します: 

\src{snippet27}
単集合の唯一の要素 \code{()} に作用するとき、これら2つの等式はなります: 

\src{snippet28}
\code{m ()} が \code{m} によって選ばれた積の要素であるので、これらの等式は \code{p} によって最初の集合から選ばれた要素、\code{p ()} がペアによって \code{m} によって選ばれたものの第一コンポーネントであることを教えてくれます。同様に、\code{q ()} は第二コンポーネントに等しいです。これは、積の要素が構成要素の集合の要素のペアであるという私たちの理解と完全に一致しています。

余積に対しては、そう単純な解釈はありません。単集合を余積の候補として試してみて、それから要素を抽出しようとするかもしれませんが、そこでは2つの入射がそれに入るのであって、2つの射影がそれから出てくるのではありません。彼らは彼らの源について何も教えてくれません (実際、私たちはそれらが入力パラメータを無視することを見ました)。同様に、余積から私たちの単集合への一意の射もそうです。集合の圏は、始対象から見たときと終対象から見たときとで非常に異なるように見えます。

これは集合の本質的な性質ではなく、$\Set$ において射として使用される関数の性質です。一般に、関数は非対称です。させてください説明します。

関数は、その始域のすべての要素に対して定義されなければなりません (プログラミングでは、これを\newterm{全関数}と呼びます) が、その全域をカバーする必要はありません。私たちは、始域から単集合への関数---単集合の中でただ1つの要素を選ぶ関数---などの極端なケースを見てきました。(実際には、空集合からの関数が真の極端です。) 始域のサイズが終域のサイズよりもはるかに小さい場合、私たちはしばしばそのような関数を、始域を終域に埋め込むと考えます。たとえば、単集合からの関数を使用して、その単一の要素を終域に埋め込むと考えることができます。私はそれらを\newterm{埋め込み}関数と呼びますが、数学者は反対を名付けることを好みます: その全域をしっかりと埋める関数は\newterm{全射}または\newterm{上への}と呼ばれます。

もう一つの非対称性の源は、関数が始域の多くの要素を終域の1つの要素にマッピングできるということです。それらはそれらを崩壊させることができます。極端なケースは、全集合を単集合にマッピングする関数です。あなたはそのような多相的な \code{unit} 関数を見ました。崩壊は合成によってのみ複合されることができます。2つの崩壊関数の合成は、個々の関数よりもさらに崩壊しています。数学者は非崩壊関数に名前を付けています: それらは\newterm{単射}または\newterm{一対一}と呼ばれます。

もちろん、埋め込みでも崩壊でもないいくつかの関数があります。それらは\newterm{全単射}と呼ばれ、それらは本当に対称的です。なぜなら、それらは可逆だからです。集合の圏では、同型は全単射と同じです。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        終対象が一意の同型まで一意であることを示してください。
  \item
        poset における2つの対象の積とは何ですか？ ヒント: 普遍構成を使ってください。
  \item
        poset における2つの対象の余積とは何ですか？
  \item
        お気に入りの言語 (Haskell以外) で Haskell の \code{Either} に相当する汎用型を実装してください。
  \item
        \code{Either} が次の2つの入射を備えた \code{int} よりも「良い」余積であることを示してください: 

        \begin{snip}{cpp}
int i(int n) { return n; }
int j(bool b) { return b ? 0: 1; }
\end{snip}

        ヒント: 関数

        \begin{snip}{cpp}
int m(Either const & e);
\end{snip}

        を定義して、\code{i} と \code{j} を因数分解してください。
  \item
        前の問題を引き続き: どうやって \code{int} が2つの入射 \code{i} と \code{j} を備えていても \code{Either} より「良い」余積にはなり得ないと主張しますか？
  \item
        まだ続けて: 以下の入射についてはどうでしょう？

        \begin{snip}{cpp}
int i(int n) {
    if (n < 0) return n;
    return n + 2;
}

int j(bool b) { return b ? 0: 1; }
\end{snip}
  \item
        \code{int} と \code{bool} の余積の劣った候補を考えてみてください。それが \code{Either} への複数の受け入れ可能な射を許容するため、それが \code{Either} より優れていることはありません。
\end{enumerate}

\section{参考文献}

\begin{enumerate}
  \tightlist
  \item
        The Catsters,
        \urlref{https://www.youtube.com/watch?v=upCSDIO9pjc}{Products and
          Coproducts} video.
\end{enumerate}


