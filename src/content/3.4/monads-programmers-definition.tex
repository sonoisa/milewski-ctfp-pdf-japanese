% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{プ}{ログラマ}はモナドについて様々な神話を作り上げています。それはプログラミングにおいて最も抽象的で難解な概念の一つとされています。それを「理解する」人とそうでない人がいます。多くの人にとって、モナドの概念を理解する瞬間は神秘的な体験のようなものです。モナドは多岐にわたる構造の本質を抽象化しているため、日常生活においてそれに相当する良い類似物がありません。私たちは暗闇の中を手探りで進むようなもので、盲目の人が象の異なる部分を触りながら勝ち誇って「これは綱だ」「これは木の幹だ」あるいは「これはブリトーだ」と叫ぶようなものです。

ここで真実を明らかにしましょう: モナドを取り巻く全ての神秘性は誤解から生まれています。モナドは非常にシンプルな概念です。混乱を招くのはモナドの応用の多様性です。

この投稿のための研究の一環として、ダクトテープ (いわゆるダックテープ) とその応用を調べました。これがいくつかの例です: 

\begin{itemize}
  \tightlist
  \item
        ダクトの封印
  \item
        アポロ13号のCO\textsubscript{2}スクラバーの修理
  \item
        イボ治療
  \item
        AppleのiPhone 4の通話落ち問題の修正
  \item
        プロムドレスの製作
  \item
        吊り橋の建設
\end{itemize}

\noindent
さて、ダクトテープが何かを知らないとして、このリストを基にそれを理解しようとしてください。幸運を祈ります！

そこで、私が追加したいのは「モナドは\ldots{}のようなもの」という陳腐な比喩のコレクションにもう一つアイテムを加えることです: モナドはダクトテープのようなものです。その応用は非常に多様ですが、その原理は非常にシンプルです: それは物事を結びつけます。より正確には、物事を合成します。

これは、特に手続き型の背景から来たプログラマがモナドを理解するのに苦労する理由を部分的に説明しています。問題は、私たちが関数合成という観点でプログラミングを考えることに慣れていないことです。これは理解しやすいことです。私たちはしばしば中間値に名前を付けるか、それらを直接関数から関数へと渡すのではなく、短い接着コードのセグメントをインライン化するか、補助関数に抽象化することを避けます。ここにCでのベクトル長関数の手続き型スタイルの実装があります: 

\begin{snip}{cpp}
double vlen(double * v) {
    double d = 0.0;
    int n;
    for (n = 0; n < 3; ++n)
        d += v[n] * v[n];
    return sqrt(d);
}
\end{snip}
これを関数合成を明示する (スタイリッシュな) Haskellのバージョンと比較してみてください: 

\src{snippet01}
 (ここで、より神秘的にするために、私は累乗演算子\code{(\^{})}をその第二引数に\code{2}を設定して部分適用しました。) 

私はHaskellのポイントフリースタイルが常に優れていると主張しているわけではありませんが、プログラミングにおいて私たちが行う全てのことの底には関数合成があります。そして、実際には関数を合成しているにも関わらず、Haskellはモナド的な合成のための手続き型スタイルの構文である\code{do}表記を提供しています。後ほどその使用方法を見ていきますが、まず、なぜそもそもモナド的な合成が必要なのかを説明しましょう。

\section{Kleisli圏}

以前、我々は通常の関数に装飾を施すことによって
\hyperref[kleisli-categories]{Writerモナド}
に到達しました。特にその装飾は、それらの戻り値を文字列とペアにすること、あるいは一般にモノイドの要素とペアにすることによって行われました。我々は今、そのような装飾が関手であることを認識できます: 

\src{snippet02}
その後、我々は装飾された関数、またはKleisli射の合成方法を見つけました。それらは形式としては以下のような関数です: 

\src{snippet03}
ログの蓄積は合成の内部で実装されました。

我々は今、Kleisli圏のより一般的な定義に備えています。我々は圏$\cat{C}$と自己関手$m$から始めます。対応するKleisli圏$\cat{K}$は$\cat{C}$と同じ対象を持ちますが、その射は異なります。$\cat{K}$内の二つの対象$a$と$b$の間の射は、元の圏$\cat{C}$内での射として実装されます: 
\[a \to m\ b\]
$a$と$b$の間の$\cat{K}$内のKleisli射を、$a$と$m\ b$の間ではなく射として扱うことが重要です。

私たちの例では、$m$は\code{Writer w}に特化されましたが、
ある固定されたモノイド\code{w}のためです。

Kleisli射は、それらに適切な合成を定義できる場合に限り、圏を形成します。合成が存在し、それが結合的であり、すべての対象に対する恒等射がある場合、関手$m$はモナドと呼ばれ、結果として得られる圏はKleisli圏と呼ばれます。

Haskellでは、Kleisli合成は魚演算子\code{>=>}を使用して定義され、恒等射は\code{return}と呼ばれる多相的関数です。ここにモナドの定義があります: 

\src{snippet04}
多くの同等のモナドの定義が存在し、これがHaskellのエコシステムでの主要なものではないことを念頭に置いてください。私はその概念的なシンプルさと直感的理解のためにこれを好みますが、プログラミングする際には他の定義の方が便利なこともあります。間もなくそれについて話し合いましょう。

この定式化では、モナド則は非常に簡単に表現できます。それらはHaskellで強制されることはありませんが、等式推論のために使用することができます。それらはKleisli圏のための標準的な合成則にすぎません: 

\begin{snip}{haskell}
(f >=> g) >=> h = f >=> (g >=> h) -- 結合則
return >=> f = f                  -- 左単位則
f >=> return = f                  -- 右単位則
\end{snip}
このような定義はまた、モナドが本当に何であるかを表現します: それは装飾された関数を合成する方法です。それは副作用や状態についてのものではありません。それは合成についてのものです。後ほど見るように、装飾された関数は様々な作用や状態を表現するために使用することができますが、それがモナドのためのものではありません。モナドは装飾された関数の一方の端を他方の端にくっつける粘着性のあるダクトテープです。

私たちの\code{Writer}例に戻ると、ログ関数 (\code{Writer}関手のKleisli射) は、\code{Writer}がモナドであるために圏を形成します: 

\src{snippet05}
モナド則は\code{w}のモノイド則が満たされる限り\code{Writer w}に対して満たされます (それらもHaskellで強制されることはありません)。

\code{Writer}モナドのために定義された便利なKleisli射があります。それは\code{tell}と呼ばれ、その唯一の目的はその引数をログに追加することです: 

\src{snippet06}
後ほど他のモナド的な関数の構成ブロックとしてそれを使用します。

\section{魚の解剖学}

異なるモナドに対する魚演算子の実装を行うとすぐに、多くのコードが繰り返されることが分かり、簡単にまとめることができます。始めに、二つの関数のKleisli合成は関数を返す必要がありますので、その実装は型\code{a}の引数を取るラムダで始まるかもしれません: 

\src{snippet07}
この引数でできる唯一のことは、それを\code{f}に渡すことです: 

\src{snippet08}
この時点で、私たちは型\code{m c}の結果を生成する必要がありますが、型\code{m b}のオブジェクトと関数\code{g :: b -> m c}が手元にあります。それを行うための関数を定義しましょう。この関数は\emph{bind}と呼ばれ、通常は中置演算子の形で書かれます: 

\src{snippet09}
各モナドに対して魚演算子を定義する代わりに、bindを定義することもできます。実際、標準的なHaskellのモナドの定義はbindを使用しています: 

\src{snippet10}
こちらは\code{Writer}モナドのためのbindの定義です: 

\src{snippet11}
確かに魚演算子の定義よりも短いですね。

さらに、\code{m}が関手であるという事実を利用してbindをさらに解体することができます。関数\code{a -> m b}を\code{m a}の内容に適用するために\code{fmap}を使用できます。これにより、\code{a}は\code{m b}に変わります。したがって、適用の結果は型\code{m (m b)}になります。これはまさに我々が求める結果型\code{m b}ではありませんが、近いです。必要なのは、\code{m}の二重適用を崩壊させるか平坦化する関数です。そのような関数は\code{join}と呼ばれます: 

\src{snippet12}
\code{join}を使って、bindを次のように書き換えることができます: 

\src{snippet13}
これによりモナドを定義する第三の方法がもたらされます: 

\src{snippet14}
ここでは、\code{m}が\code{Functor}であることを明示的に要求しています。先の二つのモナドの定義ではそれを要求する必要はありませんでした。なぜなら、魚演算子またはbind演算子をサポートする任意の型コンストラクタ\code{m}は自動的に関手であるからです。例えば、bindと\code{return}を使って\code{fmap}を定義することが可能です: 

\src{snippet15}
完全性のために、\code{Writer}モナドのための\code{join}はこちらです: 

\src{snippet16}

\section{\texttt{do}記法}

モナドを使ってコードを書く一つの方法は、Kleisli射を扱い、それらを魚演算子を使用して合成することです。このプログラミングスタイルは、ポイントフリースタイルの一般化です。ポイントフリーコードはコンパクトで、しばしば非常にエレガントです。しかし一般的には理解が難しく、暗号のようになりがちです。そのため、ほとんどのプログラマは関数引数と中間値に名前を付けることを好みます。

モナドを扱う場合、これは魚演算子よりもbind演算子を好むことを意味します。bindはモナド的な値を取り、モナド的な値を返します。プログラマはそれらの値に名前を付けることを選択できます。しかし、それはほとんど改善とは言えません。我々が本当に欲しいのは、モナド的コンテナに封じ込められているものではなく、通常の値として扱われるふりをすることです。それが手続き型コードの動作方法です --- 副作用、たとえばグローバルログの更新などはほとんどが見えないものです。そしてそれは\code{do}記法がHaskellで模倣するものです。

それでは、なぜ全ての副作用を見えなくするのであればモナドを全く使わないのでしょうか？なぜ手続き型言語に固執しないのでしょうか？答えは、モナドが副作用をより良く制御することを可能にするからです。例えば、\code{Writer}モナドのログは関数から関数へと渡され、決してグローバルに露出しません。ログを混乱させたり、データレースを生じさせる可能性はありません。また、モナド的コードは明確に区切られ、プログラムの残りの部分から隔離されています。

\code{do}記法はモナド的な合成のための単なるシンタックスシュガーです。表面上は手続き型コードのように見えますが、直接bindとラムダ式の連続に翻訳されます。

例えば、以前に\code{Writer}モナドのKleisli射の合成を説明するために使用した例を取り上げます。現在の定義を使用すると、これは次のように書き換えられます: 

\src{snippet17}
この関数は入力文字列の全ての文字を大文字に変換し、単語に分割し、その一方で行動のログを生成します。

\code{do}記法では次のようになります: 

\src{snippet18}
ここで、\code{upStr}は単なる\code{String}ですが、\code{upCase}は\code{Writer}を生成します: 

\src{snippet19}
これはコンパイラによって次のようにデシュガーされる\code{do}ブロックです: 

\src{snippet20}
\code{upCase}のモナド的な結果は\code{String}を取るラムダに束縛されます。この文字列の名前が\code{do}ブロックに現れます。次の行を読むとき: 

\src{snippet21}
私たちは\code{upStr}が\code{upCase s}の結果を「得る」と言います。

\code{tell}をインライン化すると、擬似手続き型スタイルはさらに顕著になります。\code{toWords}を\code{"toWords "}という文字列をログに記録する\code{tell}の呼び出しで置き換え、\code{upStr}を分割する\code{words}の結果を\code{return}で返す呼び出しに続けます。\code{words}は文字列を扱う通常の関数です。

\src{snippet22}
ここで、\code{do}ブロック内の各行は、デシュガーされたコード内の新しいネストされたbindを導入します: 

\src{snippet23}
\code{tell}はUnit値を生成するので、それを次のラムダに渡す必要はありません。モナド的な結果の内容を無視する (しかしその効果ではない --- ここではログへの貢献) ことはかなり一般的なので、その場合にbindを置き換える特別な演算子があります: 

\src{snippet24}
私たちのコードの実際のデシュガーは次のようになります: 

\src{snippet25}
一般的に、\code{do}ブロックはコードの残りの部分で利用可能になる新しい名前を導入する左射を使用する行 (またはサブブロック)、または純粋に副作用のために実行される行で構成されます。行の間には暗黙のbind演算子があります。ちなみに、Haskellでは\code{do}ブロックの書式をブレースとセミコロンに置き換えることが可能です。これはモナドをセミコロンをオーバーロードする方法として説明する正当化を提供します。

\code{do}記法のデシュガーにおけるラムダとbind演算子のネスティングは、各行の結果に基づいて\code{do}ブロックの残りの実行を影響させる効果を持ちます。この性質は、例えば例外をシミュレートするためなど、複雑な制御構造を導入するために使用することができます。

興味深いことに、\code{do}記法の同等物は、特にC++で、手続き型言語に適用されています。私が言及しているのは再開可能関数やコルーチンです。C++の\urlref{https://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/}{futuresがモナドを形成する}ことは秘密ではありません。それは継続モナドの一例であり、私たちはまもなくそれについて議論します。継続は非常に合成しにくいという問題があります。Haskellでは\code{do}記法を使用して「私のハンドラーがあなたのハンドラーを呼び出します」のスパゲティを、非常に手続き型のようなものに変換します。再開可能関数はC++で同じ変換を可能にします。そして同じメカニズムは、\urlref{https://bartoszmilewski.com/2014/04/21/getting-lazy-with-c/}{入れ子になったループのスパゲティ}をリスト内包表記または「ジェネレーター」に変換するために適用されることがありますが、それらは本質的にリストモナドのための\code{do}記法です。モナドの一元化された抽象化がなければ、これらの問題は通常、言語へのカスタム拡張によって個別に対処されます。Haskellでは、これはすべてライブラリを通じて処理されます。

