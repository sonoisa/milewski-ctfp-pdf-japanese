% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{型}{と関数}の圏はプログラミングにおいて重要な役割を果たします。そこで、型とは何か、そしてなぜ必要なのかについて話しましょう。

\section{誰が型を必要とするのか？}

型付けにおける、静的 vs. 動的、強い vs. 弱いに関しては、その利点を巡って様々な議論があります。これらの選択を一つの思考実験で説明しましょう。何百万匹の猿がコンピュータのキーボードでランダムにキーを打ち、プログラムを生成し、コンパイルし、そして実行する姿を想像してください。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/img_1329.jpg}
\end{figure}

\noindent
マシン語では、猿によって生成されたバイトの任意の組み合わせが受け入れられ、実行されます。しかし、高級言語を使うと、ありがたいことにコンパイラが字句的、文法的なエラーを検出してくれます。多くの猿はバナナを失いますが、残ったプログラムは有用である可能性が高くなります。型チェックは、意味を成さないプログラムに対するもう一つの障壁を提供します。さらに、動的型付け言語では型の不一致が実行時に発見される一方、強い静的型チェックが行われる言語では、型の不一致がコンパイル時に発見され、実行される前に多くの不正なプログラムが排除されます。

したがって、問題は私たちが猿を喜ばせたいのか、それとも正しいプログラムを作りたいのかということです。

猿のタイピング実験での通常の目標はシェイクスピアの全作品を生み出すことです。スペルチェッカーや文法チェッカーが実験ループの中にあれば、勝算が劇的に上がります。型チェッカーの類似物は、ロミオが人間であると宣言されたら、彼が葉を生やしたり、彼の強力な重力場が光子を閉じ込めたりしないこと確認することで、さらにその上を行くでしょう。

\section{型とは合成可能性に関すること}

圏論は射の合成に関する理論です。しかし、どの二つの射も合成できるわけではありません。一つの射のターゲット対象が次の射のソース対象と同じでなければなりません。プログラミングでは、一つの関数の結果を別の関数に渡します。ターゲット関数がソース関数によって生成されたデータを正しく解釈できない場合、プログラムは動作しません。両端がマッチしなければ合成は機能しません。言語の型システムが強ければ強いほど、このマッチを記述し、機械的に検証できるようになります。

強い静的型チェックに対する唯一のまともな反論は、それが意味的に正しいプログラムを排除してしまう可能性があるということです。実際には、これは極めてまれにしか起こりませんし、いずれにせよ、どんな言語も型システムを迂回する何らかの方法を提供しています。Haskellでさえも\code{unsafeCoerce}があります。しかし、このような手段は慎重に使用するべきです。Franz Kafkaのキャラクター、Gregor Samsaは、巨大な虫に変身するときに型システムを破壊し、その結果は皆さんも知っての通りです。

もう一つよく耳にする反論は、型付けがプログラマに多大な負担を課すというものです。私自身、C++でイテレータの宣言をいくつか書かなければならなかった後、この感情に同情することができました。ただし、\newterm{型推論}と呼ばれる技術があり、コンパイラは、ほとんどの型をそれらが使われている文脈から推論することができます。C++では、変数を\code{auto}と宣言し、コンパイラにその型を決定させることができます。

Haskellでは、まれな場合を除き、型アノテーションの記載は完全に任意です。それでも、プログラマは書く傾向があります。なぜなら、それらはコードの意味について多くを語り、コンパイルエラーを理解しやすくするからです。Haskellではプロジェクトを始めるときにまず型の設計を行うのが一般的慣習になっています。\sloppy{その後、型アノテーションが実装を駆動し、コンパイラによって強制されるコメントになります。}

強い静的型付けは、コードをテストしない言い訳としてよく使われます。時々、Haskellのプログラマによる「コンパイルが通ったのなら、それは正しいに違いない」という発言を耳にしているかもしれません。もちろん、型が正しいということをもって、正しい出力を生み出す、正しいプログラムであることが保証されるわけではありません。この無謀な態度の結果、複数の研究において、Haskellが一般に期待されるほどコードの品質で他の言語よりも大きく抜きん出ているわけではないことが判りました。営利目的の場面では、バグ修正のプレッシャーは一定の品質レベルまでに留まるようです。その品質レベルはすべてソフトウェア開発の経済性とエンドユーザーの許容範囲に関係するものであり、プログラミング言語や方法論とはほとんど関係がありません。より良い基準は、予定よりも遅れたプロジェクトの数、または機能が大幅に減った状態で納品されたプロジェクト数を測定することでしょう。

単体テストが強い型付けを置き換えることができるという議論については、強い型付け言語での一般的なリファクタリングのプラクティスを考えてみましょう。題材は、特定の関数の引数の型を変更することです。強い型付け言語では、その関数の宣言を変更し、その後、ビルドが通らなかったすべての部分を修正するだけで済みます。弱い型付け言語では、関数が前とは異なるデータを期待するようになった事実を呼び出し元に伝播させることができません。単体テストは一部の不一致を捉えるかもしれませんが、テストはほぼ常に確率的であり、決定的ではありません。証明の代用にするにはテストは貧弱です。

\section{型とは？}

型の最もシンプルな直感的理解は、それらが値の集合であるということです。型\code{Bool} (Haskellでは具体的な型は大文字で始まることを思い出してください) は、二つの要素\code{True}と\code{False}からなる集合です。型\code{Char}は、\code{a}や\code{ą}のようなすべてのUnicode文字の集合です。

集合は有限であることも無限であることもあります。型\code{String}、これは\code{Char}のリストの別名ですが、無限集合の例です。

\code{x}を\code{Integer}と宣言するとき: 

\src{snippet01}
これは整数集合の要素であると言っているのです。
\code{Integer}はHaskellでは無限集合であり、任意精度の算術を行うために使用できます。マシン型に対応する有限集合\code{Int}もあります。これはC++の\code{int}のようなものです。

型と集合のこの同一視にはいくつかの微妙な問題があります。循環定義を含む多相的関数や、すべての集合の集合は手に入らないという事実に関する問題です。しかし、約束しましたが、私は数学について厳密であることはありません。素晴らしいことに、$\Set$と呼ばれる集合の圏があり、私たちはそれを使います。$\Set$では、対象は集合であり、射 (矢印) は関数です。

$\Set$は非常に特別な圏です。なぜなら、実際にその対象の中を覗いて多くの直感を得ることができるからです。例えば、空集合には要素がないことを知っています。特別な単集合（一つの要素のみからなる集合）があることも知っています。関数が一つの集合の要素を別の集合の要素にマップすることを知っています。それは二つの要素を一つにマップすることはできますが、一つの要素を二つにマップすることはできません。恒等関数が集合の各要素をそれ自身にマップすることを知っています、などなど。計画は徐々にこれらすべての情報を忘れていき、その代わりにすべての概念を純粋に圏論的な用語、つまり対象と射の観点から表現することです。

理想的な世界では、Haskellの型は集合であり、Haskellの関数は集合間の数学的関数であると単純に言えばいいのですが、ひとつだけ小さな問題があります。数学的な関数はコードを実行しません --- 答えを知っているだけです。Haskell関数は答えを計算しなければなりません。答えが有限ステップ数で得られる場合は問題ありません --- その数がいかに大きくても。しかし、再帰を含む計算があり、それらは決して停止しない可能性があります。Haskellから停止しない関数を取り除くことはできません。なぜなら、停止する関数と停止しない関数を区別することは決定不能だからです --- 有名な停止問題です。そのため、コンピュータ科学者は、\newterm{ボトム}と呼ばれ\code{\_|\_}やUnicode文字$\bot$で書かれる特別な値で型を拡張するという天才的な、または視点によっては大胆なアイデアを思いつきました。この「値」は、停止しない計算に対応します。従って、関数が次のように宣言されている場合: 

\src{snippet02}
これは\code{True}か\code{False}、または\code{\_|\_}を返すかもしれません。
\code{\_|\_}は、これが決して停止しないことを意味します。

興味深いことに、ボトムを型システムの一部として受け入れるなら、すべてのランタイムエラーをボトムとして扱い、また、関数が明示的にボトムを返すことを許可するようにすると便利です。後者は通常、次のように式\code{undefined}を使用して行われます: 

\src{snippet03}
この定義は型チェックを通過します。なぜなら、\code{undefined}はボトムに評価され、そして、ボトムは\code{Bool}を含む任意の型のメンバーであるからです。さらに次のように書くこともできます: 

\src{snippet04}
 (\code{x}がありません) なぜなら、ボトムは型\code{Bool -> Bool}のメンバーでもあるからです。

ボトムを返す可能性のある関数は部分関数と呼ばれ、すべての可能な引数に対して正式な結果を返す全関数と対比されます。

ボトムがあるため、Haskellの型と関数の圏は$\Set$ではなく$\Hask$として言及されることがあります。理論的な観点から、これは終わることのない複雑さの源です。ですので、この点において私は肉切り包丁を使い、この議論の筋を切り落とします。実用的な観点からは、停止しない関数とボトムを無視し、$\Hask$を正当な$\Set$として扱っても構いません。\footnote{Nils Anders Danielsson,
  John Hughes, Patrik Jansson, Jeremy Gibbons, \href{http://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf}{
    Fast and Loose Reasoning is Morally Correct}. この論文は、ほとんどの文脈でボトムを無視することを正当化してくれます。}

\section{なぜ数学的モデルが必要なのか？}

プログラマとして、あなたは使用しているプログラミング言語の構文と文法に精通しているでしょう。言語のこれらの側面は通常、言語仕様書の一番最初に形式的記法を用いて記述されています。しかし、言語の意味、すなわち意味論を記述することははるかに困難です。それには多くのページを必要とし、十分に形式的であることは稀で、大体は不完全です。そのため、プログラミング言語に精通した経験豊富なエンジニアの間で終わりのない議論が交わされ、言語標準の細かな点の解釈に特化した本という小規模な産業が存在しています。

言語の意味論を記述するための形式的ツールがありますが、その複雑さのため、実際に使われている巨大なプログラミング言語にではなく、主に簡略化された学術研究用言語に対して使用されています。そのようなツールの一つである\newterm{操作的意味論 (operational semantics)}は、プログラム実行のメカニズムについて記述します。それは、形式化・理想化されたインタープリタを定義します。C++のような産業的な言語の意味論は、通常、「抽象機械」という名前の非形式的な操作的推論を使用して記述されます。

問題は、操作的意味論を使用してプログラムに関する証明を行うのが困難であるということです。プログラムが持つ性質を示すためには、理想化されたインタープリタを用いて本質的に「実行」しなければなりません。

プログラマが正確性の形式的証明を決してしないことに問題はありません。私たちは常に自身が正しいプログラムを書いていると「思って」います。キーボードの前に座って、「さて、数行のコードを投げてみて何が起こるか見てみよう」と言う人はいません。私たちは書いたコードが望ましい結果を生み出す特定のアクションを実行すると思っています。それがそうでない場合、私たちは普通とても驚きます。つまり、私たちは書いたプログラムについて常に推論しているのです。そして、私たちは通常それを頭の中でインタープリタを実行することによって行なっています。ただ、すべての変数を追跡するのは本当に難しいです。コンピュータはプログラムの実行が得意ですが、人間はそうではありません！もし私たちがそうだったら、私たちはコンピュータを必要としませんでした。

しかし、代わりがあります。それは\newterm{表示的意味論 (denotational semantics)}と呼ばれ、数学に基づいています。表示的意味論では、プログラミングのすべての構成に対してその数学的解釈が与えられます。それにより、プログラムの特性について証明したければ、数学の定理を証明するだけです。定理の証明は難しいと思うかもしれませんが、しかし実際は、何千年もの間、人類は数学的方法を作り上げてきたので、利用できる知識がたくさん蓄積されています。また、プロの数学者が証明するような定理に比べれば、プログラミングで遭遇する問題は、自明ではないにせよ、通常極めて単純なものであることがほとんどです。

Haskellにおける階乗関数の定義を考えてみましょう。Haskellは表示的意味論にとても適する言語です: 

\src{snippet05}
式\code{{[}1..n{]}}は\code{1}から\code{n}までの整数のリストです。
関数\code{product}はリストのすべての要素を掛け合わせます。これは数学の教科書から持ってきた階乗の定義そっくりです。これとC言語のものを比較してみましょう: 

\begin{snip}{c}
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
\end{snip}
これ以上、何か言う必要はありますか？

オーケー、これは安直な一撃だったことは先に認めましょう！階乗関数には明らかな数学的表現があります。鋭い読者は尋ねるかもしれません。キーボードから文字を読み取る、またはネットワークを介してパケットを送信するといったものの数学的モデルは何ですかと。長い間、それはおそらくかなり複雑な説明につながる厄介な質問でした。表示的意味論は、便利なプログラムを書くために不可欠な多くの重要なタスクには最適ではないようであり、そして、それらは操作的意味論では簡単に扱うことができました。その突破口は圏論から来ました。
Eugenio Moggiは、計算効果をモナドにマッピングできることを発見しました。これは、表示的意味論に新たな命を吹き込み、純粋関数型プログラムをより使いやすくするだけでなく、伝統的なプログラミングにも新たな光を当てる重要な発見でした。もっと圏論の道具を導入した後に、モナドについて話すことにします。

プログラミングに関する数学的モデルを持つことの重要な利点の一つは、ソフトウェアの正確性の形式的証明を行えるということです。これは、消費者向けソフトウェアを書いているときはそれほど重要ではないかもしれませんが、プログラミングの領域には失敗の代償が法外に大きい場合や、人命に関わる場合があります。そこまででなくても、あなたは医療システム用Webアプリケーションを書くときに、Haskell標準ライブラリの関数やアルゴリズムは正確性の証明付きであるという考えに感謝するかもしれません。

\section{純粋関数と汚い関数}

C++や他の命令型言語で私たちが関数と呼ぶものは、数学者が関数と呼ぶものと同じではありません。数学的な関数は単に値から値への写像です。

プログラミング言語で数学的な関数を実装できます。そのような関数は、入力値が与えられると出力値を計算します。数の二乗を生成する関数はおそらく入力値をそれ自身で乗算します。それは呼ばれるたびに、そして同じ入力で呼ばれるたびに、同じ出力を生成することが保証されます。月の位相と共に数の二乗が変わるようなことはありません。

また、数の二乗を計算することが、あなたの犬に美味しいおやつを配るといった副作用を持っているべきではありません。そのような「関数」は数学的な関数として簡単にモデル化することができません。

プログラミング言語で、同じ入力が与えられたときに常に同じ結果を生成し、副作用がない関数は\newterm{純粋関数 (pure function)}と呼ばれます。Haskellのような純粋関数型言語では、すべての関数が純粋です。そのため、これらの言語に表示的意味論を与えて、圏論を使ってモデル化することは容易です。他の言語については、常に、自身を純粋なサブセットに制限したり、副作用を分けて推論したりすることができます。後ほど、モナドがどのようにして純粋関数のみを使用してあらゆる種類の副作用をモデル化できるかを見ていきます。従って、実際には、数学的な関数に自身を制限することで失うものは一切ありません。

\section{型の例}

一度、型が集合であると思うと、かなり風変わりな型を考えることができます。例えば、空集合に対応する型は何でしょうか？いいえ、それはC++の\code{void}ではありません。ですが、この型はHaskellでは\code{Void}と呼ばれています。これはどんな値も持たない型です。あなたは\code{Void}を受け取る関数を定義することはできますが、それを決して呼び出すことはできません。それを呼び出すためには、\code{Void}型の値を提供しなければならず、そんなものは存在しません。この関数が返すことができるものに制限はまったくありません。任意の型を返すことができます (ただし、それは決して呼び出されないため、実際には返すことはありません)。言い換えれば、それは返り値の型において多相的な関数です。Haskellでは次のように名付けています: 

\src{snippet06}
 (思い出してください。\code{a}は任意の型を表す型変数です。) この名前（和訳:不合理）は偶然ではありません。型と関数のより深い解釈が、Curry-Howard対応と呼ばれる論理の観点からあります。型\code{Void}は偽を表し、関数\code{absurd}の型は、ラテンの格言「ex falso sequitur quodlibet」、つまり「偽からは何でも導ける」に対応します。

次は、単集合に対応する型です。それはただ1つ可能な値を持つ型です。値の意味はただ「存在する」のみです。すぐにはそう思えないかもしれませんが、これはC++の\code{void}です。この型からとこの型への関数を考えてみてください。\code{void}からの関数は常に呼び出すことができます。純粋関数であれば、常に同じ結果を返します。下記はそのような関数の例です: 

\begin{snip}{c}
int f44() { return 44; }
\end{snip}
あなたはこの関数が「無」を受け取ると思うかもしれませんが、私たちがさっき見たように、「無」を受け取る関数は、「無」を表す値が存在しないため、決して呼び出すことができません。では、この関数は何を受け取るのでしょうか？概念的には、何か唯一のインスタンスであればよいダミー値を受け取ります。そのため、私たちはその値について明示的に言及する必要はありません。しかし、Haskellではこの値に対する記号があります。空の丸括弧\code{()}です。面白い偶然で (それとも偶然ではないのでしょうか？)、void型の関数の呼び出しはC++とHaskellで同じように見えます。また、Haskellの簡潔さを愛するために、同じ記号\code{()}が、単集合に対応する型、コンストラクタ、および唯一の値を表すために使用されます。そして、Haskellでは関数はこうなります: 

\src{snippet07}
最初の行は、\code{f44}が「Unit」と発音する型\code{()}から\code{Integer}型への関数であるという宣言です。2行目は\code{f44}の定義であり、Unit型の唯一のコンストラクタ、つまり\code{()}にパターンマッチをして、数値44を生成します。この関数を呼び出すにはUnit値\code{()}を与えます: 

\begin{snip}{c}
f44 ()
\end{snip}
Unitを受け取るすべての関数は、ターゲット型から単一の要素を選ぶことと同等であることに注意してください (ここでは、\code{Integer} 44を選ぶこと)。実際、\code{f44}を数44の異なる表現と考えることもできます。これは、集合の要素について直接言及する代わりに、関数 (射) に関する話に置き換える方法の一例です。Unit型から任意の型$A$への関数は、集合$A$の要素と一対一の対応関係にあります。

返り値が\code{void}型の関数、もしくはHaskellで返り値がUnit型の関数はどうでしょうか？C++ではそのような関数は副作用のために使用されますが、これらが数学的な意味での本当の関数ではないことはわかっています。Unitを返す純粋な関数は何もせず、引数を破棄します。

数学的には、集合$A$から単集合への関数は、$A$のすべての要素をその単集合の単一要素に写像します。すべての$A$に対して、そのような関数はただ一つだけ存在します。これは\code{Integer}用のその関数です：

\src{snippet08}
これに任意の整数を与えると、Unitが返ってきます。簡潔さの精神から、Haskellではワイルドカードパターンであるアンダースコアを、捨てられる引数に対して使用することができます。この方法により名前を考えずに済みます。そのため、上記は次のように書き換えることができます: 

\src{snippet09}
この関数の実装は、それに渡された値に依存しないだけでなく、引数の型にも依存しないことに注意してください、

任意の型に対して同じ方程式で実装できる関数は、パラメトリック多相性を持つと言われます。あなたは具体的な型の代わりに型パラメータを使って1つの方程式でそのような関数の全ての族を実装することができます。任意の型からUnit型への多相的関数を何と呼ぶべきか？もちろん\code{unit}と呼びます: 

\src{snippet10}
C++では、この関数を次のように書きます: 

\begin{snip}{cpp}
template<class T>
void unit(T) {}
\end{snip}
次に、型の分類の中で二要素集合があります。C++では\code{bool}と呼ばれ、Haskellでは予測どおりに\code{Bool}と呼ばれます。違いは、C++の\code{bool}は組み込み型であるのに対し、Haskellでは次のように定義できます: 

\src{snippet11}
(この定義の読み方は、\code{Bool}は\code{True}か\code{False}のどちらかであるということです。) 原理的には、C++でも列挙型としてブール型を定義することができます: 

\begin{snip}{cpp}
enum bool {
    true,
    false
};
\end{snip}
しかし、C++の\code{enum}は実は整数です。C++11の``\code{enum class}''を代わりに使用することができますが、その場合はその値をクラス名で修飾する必要があります。つまり、\code{bool::true}や\code{bool::false}といった形式で、それを使用するすべてのファイルに適切なヘッダを含める必要があります。

\code{Bool}からの純粋関数はターゲット型から2つの値を選びます。\code{True}に対応する1つの値と\code{False}に対応するもう1つの値です。

\code{Bool}への関数は\newterm{述語 (predicate)}と呼ばれます。例えば、Haskellライブラリ\code{Data.Char}は\code{isAlpha}や\code{isDigit}のような述語でいっぱいです。C++には\code{isalpha}や\code{isdigit}を定義する同様のライブラリがありますが、これらはブール型ではなく\code{int}を返します。実際の述語は\code{std::ctype}で定義され、\code{ctype::is(alpha, c)}や\code{ctype::is(digit, c)}などの形式を取ります。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        お気に入りの言語で高階関数 (または関数オブジェクト) \code{memoize} (和訳:メモ化) を定義してください。この関数は純粋関数\code{f}を引数として取り、\code{f}とほとんど同じように振る舞う関数を返しますが、元の関数を各引数に対して一度だけ呼び出し、結果を内部に保存し、その後同じ引数で呼び出されるたびにこの保存された結果を返します。メモ化された関数は、そのパフォーマンスを見ることで元の関数と区別することができます。例えば、評価に長い時間がかかる関数をメモ化してみてください。最初にそれを呼び出したときは結果を待たなければなりませんが、同じ引数による後の呼び出しでは、結果が即座に得られるはずです。
  \item
        標準ライブラリのランダムな数を生成するために通常使用する関数をメモ化してみてください。うまくいきますか？
  \item
        ほとんどのランダム数生成器はシードで初期化することができます。シードを取り、そのシードでランダム数生成器を呼び出し、結果を返す関数を実装してください。その関数をメモ化してください。うまくいきますか？
  \item
        以下のC++関数のどれが純粋ですか？それらをメモ化し、メモ化されたものと、そうでないものそれぞれについて複数回呼び出したときに何が起こるかを観察してください。

        \begin{enumerate}
          \tightlist
          \item
                本文中の例の階乗関数
          \item
                \begin{minted}{cpp}
std::getchar()
\end{minted}
          \item
                \begin{minted}{cpp}
bool f() {
    std::cout << "Hello!" << std::endl;
    return true;
}
\end{minted}
          \item
                \begin{minted}{cpp}
int f(int x) {
    static int y = 0;
    y += x;
    return y;
}
\end{minted}
        \end{enumerate}
  \item
        \code{Bool}から\code{Bool}への異なる関数はいくつありますか？それらをすべて実装できますか？
  \item
        対象が型\code{Void}、\code{()} (Unit)、\code{Bool}のみである圏の図を描いてください。射はこれらの型間のすべての可能な関数に対応します。
        そして関数の名前で射をラベル付けしてください。
\end{enumerate}
