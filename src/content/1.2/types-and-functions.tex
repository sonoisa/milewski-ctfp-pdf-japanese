% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{型}{と関数}の圏はプログラミングにおいて重要な役割を果たします。そこで、型とは何か、そしてなぜ必要なのかについて語りましょう。

\section{誰が型を必要とするのか？}

静的対動的、強い対弱い型付けに関しては、その利点を巡って様々な議論があります。これらの選択を一つの思考実験で説明しましょう。コンピュータのキーボードでランダムにキーを打ち、プログラムを生成し、コンパイルし、そして実行する何百万もの猿を想像してください。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/img_1329.jpg}
\end{figure}

\noindent
マシン語では、猿によって生成されたバイトの任意の組み合わせが受け入れられ、実行されます。しかし、高級言語を使うと、コンパイラが字句的、文法的なエラーを検出できることに感謝します。多くの猿はバナナを失いますが、残ったプログラムは有用である可能性が高くなります。型チェックは、意味を成さないプログラムに対するもう一つの障壁を提供します。さらに、動的型付け言語では型の不一致がランタイムで発見されますが、強く静的に型チェックされた言語では、型の不一致がコンパイル時に発見され、実行される前に多くの不正なプログラムを排除します。

したがって、問題は私たちが猿を喜ばせたいのか、それとも正しいプログラムを作りたいのかということです。

猿のタイピング実験での通常の目標はシェイクスピアの全作品を生産することです。スペルチェッカーや文法チェッカーがループ内にいれば、オッズが劇的に上がります。型チェッカーの類似物は、ロミオが人間と宣言されたら、葉を生やしたり、強力な重力場で光子を捕らえたりすることがないようにさらに確実にします。

\section{型は合成可能性についてです}

圏論は射を合成することについてです。しかし、どの二つの射も合成できるわけではありません。一つの射のターゲット対象が次の射のソース対象と同じでなければなりません。プログラミングでは、一つの関数の結果を別の関数に渡します。対象関数がソース関数によって生成されたデータを正しく解釈できない場合、プログラムは動作しません。両端が合致しなければ合成は機能しません。言語の型システムが強ければ強いほど、このマッチを記述し、機械的に検証できるようになります。

強い静的型チェックに対する唯一の真剣な反論は、それが意味的に正しいいくつかのプログラムを排除する可能性があるということです。実際には、これは極めてまれにしか起こりませんし、いずれにせよ、すべての言語は型システムをバイパスする何らかの方法を提供しています。Haskellでさえも\code{unsafeCoerce}があります。しかし、このような装置は慎重に使用するべきです。フランツ・カフカのキャラクター、グレゴール・ザムザは、巨大な虫に変態するときに型システムを破壊し、その結果は皆さんも知っての通りです。

もう一つよく耳にする反論は、型付けがプログラマに多大な負担を課すというものです。私自身、C++でイテレータのいくつかの宣言を書かなければならなかった後では、この感情に同情することができました。ただし、\newterm{型推論}と呼ばれる技術があり、コンパイラが使用される文脈からほとんどの型を推論させることができます。C++では、変数を\code{auto}と宣言し、コンパイラにその型を決定させることができます。

Haskellでは、まれな場合を除き、型アノテーションは完全にオプショナルです。それでも、プログラマはそれらを使用する傾向があります。なぜなら、それらはコードの意味論について多くを語り、コンパイルエラーを理解しやすくするからです。Haskellではプロジェクトを始めるときに型を設計することが一般的な慣習です。\sloppy{後に、型アノテーションは実装を指導し、コンパイラによって強制されるコメントになります。}

強い静的型付けは、コードをテストしない言い訳としてよく使われます。時々、Haskellのプログラマから「コンパイルされれば、それは正しいに違いない」という話を聞くかもしれません。もちろん、型が正しいということは、出力が正しいということを保証するものではありません。この無謀な態度の結果、いくつかの研究では、Haskellが一般に期待されるほどコードの品質で他の言語よりも強く抜け出ていないことがわかりました。商業環境では、バグを修正する圧力は特定の品質レベルまでしか適用されず、それはソフトウェア開発の経済とエンドユーザーの許容とはほとんど関係がなく、プログラミング言語や方法論とはほとんど関係がありません。より良い基準は、予定より遅れるプロジェクトの数、または大幅に機能が削減されて納品されるプロジェクトの数を測定することです。

単体テストが強い型付けを置き換えることができるという議論については、強く型付けされた言語での一般的なリファクタリングの練習を考えてみましょう: 特定の関数の引数の型を変更すること。強く型付けされた言語では、その関数の宣言を変更し、その後すべてのビルドブレークを修正するだけで済みます。弱く型付けされた言語では、関数が異なるデータを期待するという事実を呼び出し元に伝播させることができません。単体テストは一部の不一致を捉えるかもしれませんが、テストはほぼ常に確率的であり、決定的ではありません。テストは証明の貧弱な代替です。

\section{型とは何か？}

型の最もシンプルな直感は、それらが値の集合であるということです。型\code{Bool} (Haskellでは具体的な型は大文字で始まることを思い出してください) は、\code{True}と\code{False}の二つの要素からなる集合です。型\code{Char}は、\code{a}や\code{ą}のようなすべてのUnicode文字の集合です。

集合は有限であることも無限であることもあります。型\code{String}、これは\code{Char}のリストの別名ですが、無限集合の例です。

\code{x}を\code{Integer}と宣言するとき: 

\src{snippet01}
私たちは、それが整数の集合の要素であると言っています。\code{Integer}はHaskellでは無限集合であり、任意精度の算術を行うために使用できます。マシン型に対応する有限集合\code{Int}もあります。これはC++の\code{int}のようなものです。

型と集合のこの識別には、多相関数を含む循環定義や、すべての集合の集合を持つことができないという事実など、いくつかの微妙な問題があります。しかし、約束しましたが、私は数学に厳密であることはありません。素晴らしいことに、集合の圏があり、それは$\Set$と呼ばれ、私たちはそれと単に作業します。$\Set$では、対象は集合であり、射 (矢印) は関数です。

$\Set$は非常に特別な圏です。なぜなら、実際にその対象の中を覗いて多くの直感を得ることができるからです。例えば、空集合には要素がないことを知っています。特別な単集合があることも知っています。関数が一つの集合の要素を別の集合の要素にマップすることを知っています。それらは二つの要素を一つにマップすることはできますが、一つの要素を二つにマップすることはできません。恒等関数が集合の各要素をそれ自身にマップすることを知っています、などなど。計画は徐々にこれらすべての情報を忘れていき、その代わりにすべての概念を純粋に圏論的な用語、つまり対象と射の観点から表現することです。

理想的な世界では、Haskellの型は集合であり、Haskellの関数は集合間の数学的関数であると単純に言えばいいのですが、ひとつだけ小さな問題があります。数学的な関数はコードを実行しません --- 答えを知っているだけです。Haskell関数は答えを計算しなければなりません。答えが有限ステップ数で得られる場合は問題ありません --- その数がいかに大きくても。しかし、再帰を含む計算があり、それらは決して終了しない可能性があります。Haskellから非終了関数を禁止することはできません。なぜなら、終了する関数と非終了関数を区別することは決定不能だからです --- 有名な停止問題です。そのため、計算機科学者は、型を\newterm{ボトム}と呼ばれる特別な値で拡張するという天才的、または視点によっては大胆なアイデアを思いつきました。この「値」は、非終了計算に対応します。従って、関数が次のように宣言されている場合: 

\src{snippet02}
それは\code{True}、\code{False}、または\code{\_|\_}を返すかもしれません。後者は、それが決して終了しないことを意味します。

興味深いことに、ボトムを型システムの一部として受け入れると、すべてのランタイムエラーをボトムとして扱い、関数が明示的にボトムを返すことを許可することが便利です。後者は通常、次の式を使用して行われます: 

\src{snippet03}
この定義は型チェックを通過します。なぜなら、\code{undefined}はボトムに評価され、ボトムは\code{Bool}を含む任意の型のメンバーだからです。あなたはさらに書くことができます: 

\src{snippet04}
 (\code{x}なしで) なぜなら、ボトムは型\code{Bool -> Bool}のメンバーでもあるからです。

ボトムを返す可能性のある関数は部分関数と呼ばれ、有効な結果をすべての可能な引数に対して返す全関数と対比されます。

ボトムのために、Haskellの型と関数の圏は$\Set$ではなく$\Hask$として言及されることがあります。理論的な観点から、これは絶えず続く複雑さの源です。ですので、この点においては私は私の料理人のナイフを使い、この議論の線を終わらせます。実用的な観点からは、非終了関数とボトムを無視し、$\Hask$を正当な$\Set$として扱っても構いません。\footnote{Nils Anders Danielsson,
  John Hughes, Patrik Jansson, Jeremy Gibbons, \href{http://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf}{
    Fast and Loose Reasoning is Morally Correct}. この論文は、ほとんどの文脈でボトムを無視することの正当化を提供します。}

\section{なぜ数学的モデルが必要なのか？}

プログラマとして、あなたは使用しているプログラミング言語の構文と文法に非常に精通しています。言語のこれらの側面は通常、言語の仕様の最初に公式な表記を使って記述されています。しかし、言語の意味、すなわち意味論を記述することははるかに困難です。それは多くのページを取り、めったに十分に形式的ではなく、ほとんど完全ではありません。これが、言語弁護士間の絶え間ない議論と、言語標準の微妙な点の注釈に捧げられた本の全業界につながります。

言語の意味論を記述するための公式なツールがありますが、その複雑さのため、実際のプログラミングの巨人ではなく、簡略化されたアカデミック言語で主に使用されています。そのようなツールの一つである\newterm{操作的意味論}は、プログラム実行のメカニズムを記述します。それは、形式化された理想化されたインタプリターを定義します。産業的な言語の意味論、例えばC++は、通常「抽象マシン」という用語で非公式な操作的推論を使用して記述されます。

問題は、操作的意味論を使用してプログラムについてのことを証明するのが非常に難しいということです。プログラムの特性を示すためには、基本的に理想化されたインタープリターを通して「実行」しなければなりません。

プログラマが

正確性の正式な証明を決して行わないとしても、私たちは常に正しいプログラムを書いていると「思って」います。キーボードに座って、「さて、数行のコードを投げて何が起こるか見てみましょう」と言う人は誰もいません。私たちは書いたコードが望ましい結果を生成する特定のアクションを実行すると考えています。それがそうでない場合、私たちは通常かなり驚きます。つまり、私たちは書いたプログラムについて常に推論しているのです、そして、私たちは通常それを頭の中でインタプリターを実行することによって行います。変数を追跡するのは本当に難しいだけです。コンピューターはプログラムを実行するのが得意です --- 人間はそうではありません！もし私たちがそうだったら、私たちはコンピュータを必要としませんでした。

しかし、代わりがあります。それは\newterm{表示的意味論}と呼ばれ、数学に基づいています。表示的意味論では、すべてのプログラミング構造にその数学的解釈が与えられます。それにより、プログラムの特性を証明したい場合は、数学的定理を証明するだけです。定理証明が難しいと思うかもしれませんが、実際は、何千年もの間、人類は数学的方法を構築してきたので、利用できる蓄積された知識がたくさんあります。また、専門の数学者が証明する種類の定理と比べると、プログラミングで遭遇する問題は通常かなり単純で、場合によっては自明です。

Haskellにおける階乗関数の定義を考えてみましょう。これは表示的意味論にかなり適している言語です: 

\src{snippet05}
式\code{{[}1..n{]}}は\code{1}から\code{n}までの整数のリストです。
関数\code{product}はリストのすべての要素を掛け合わせます。これは数学のテキストから取った階乗の定義のようなものです。これをCで比較してみましょう: 

\begin{snip}{c}
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
\end{snip}
これ以上言う必要がありますか？

さて、私が最初に認めるとしましょう、これは安いショットでした！階乗関数には明らかな数学的表現があります。鋭い読者は尋ねるかもしれません: キーボードから文字を読み取る、またはネットワークを介してパケットを送信するといった、数学的モデルは何ですか？長い間、それはおそらくかなり複雑な説明につながる厄介な質問でした。表示的意味論は、便利なプログラムを書くために不可欠な多くの重要なタスクに最適ではないようであり、それらは操作的意味論によって簡単に取り組むことができました。突破口は圏論から来ました。
Eugenio Moggiは、計算効果をモナドにマッピングすることができることを発見しました。これは、表示的意味論に新たな命を吹き込み、純粋関数型プログラムをより使いやすくし、伝統的なプログラミングに新たな光を当てるだけでなく、重要な観察でした。私たちがより多くの圏論的ツールを開発するときに、モナドについて話します。

プログラミングのための数学的モデルを持つことの重要な利点の一つは、ソフトウェアの正確性の形式的証明を実行することが可能であるということです。これは、消費者向けソフトウェアを書いているときはそれほど重要ではないかもしれませんが、失敗の代償が法外である、または人命にかかわるプログラミングの領域があります。しかし、健康システムのためのWebアプリケーションを書いているときでさえ、Haskell標準ライブラリの関数やアルゴリズムが正確性の証明を伴っているという考えを歓迎するかもしれません。

\section{純粋関数と汚い関数}

C++や他の任意の命令型言語で私たちが関数と呼ぶものは、数学者が関数と呼ぶものと同じものではありません。数学的な関数は単に値から値へのマッピングです。

プログラミング言語で数学的な関数を実装することができます: そのような関数は、入力値を与えられると出力値を計算します。数の二乗を生成する関数はおそらく入力値をそれ自身で乗算します。それは呼ばれるたびに、そして同じ入力で呼ばれるたびに、同じ出力を生成することが保証されます。月の位相と共に数の二乗は変わりません。

また、数の二乗を計算することがあなたの犬に美味しいおやつを配る副作用を持っているべきではありません。そのような「関数」は数学的な関数として簡単にモデル化することができません。

プログラミング言語で、同じ入力が与えられたときに常に同じ結果を生成し、副作用がない関数は\newterm{純粋関数}と呼ばれます。純粋関数型言語であるHaskellでは、すべての関数が純粋です。そのため、これらの言語に表示的意味論を与え、圏論を使ってモデル化することが容易です。他の言語については、自分自身を純粋なサブセットに制限するか、副作用を別に推論することが常に可能です。後ほど、モナドがどのようにして純粋関数のみを使用してあらゆる種類の副作用をモデル化することができるかを見ていきます。従って、数学的な関数に自分たちを制限することで、実際には何も失うことはありません。

\section{型の例}

一度に型が集合であると認識すると、かなり風変わりな型を考えることができます。例えば、空集合に対応する型は何でしょうか？いいえ、それはC++の\code{void}ではありませんが、この型はHaskellでは\code{Void}と呼ばれています。それはどんな値も持たない型です。あなたは\code{Void}を取る関数を定義することができますが、それを決して呼び出すことはできません。それを呼び出すためには、\code{Void}型の値を提供しなければならず、そんなものは存在しません。この関数が返すことができるものに制限はまったくありません。それは任意の型を返すことができます (ただし、それが決して呼び出されないため、実際には返すことはありません) 。言い換えれば、それは返り値の型において多相的な関数です。Haskellersはそれに名前をつけます: 

\src{snippet06}
 (思い出してください、\code{a}は任意の型を表すことができる型変数です。) この名前は偶然ではありません。型と関数のより深い解釈が、Curry-Howard対応と呼ばれる論理の観点からあります。型\code{Void}は偽を表し、関数\code{absurd}の型は、ラテンの格言「ex falso sequitur quodlibet」、つまり偽からは何でも導かれる、に対応します。

次は、単集合に対応する型です。それはただ「存在する」1つの可能な値を持つ型です。これをすぐに認識できないかもしれませんが、それはC++の\code{void}です。この型からとこの型への関数を考えてみてください。 \code{void}からの関数は常に呼び出すことができます。純粋関数であれば、常に同じ結果を返します。ここにそのような関数の例があります: 

\begin{snip}{c}
int f44() { return 44; }
\end{snip}
あなたはこの関数が「何も取らない」と思うかもしれませんが、私たちがちょうど見たように、「何も」を取る関数は、それを呼び出すための値が「何も」代表しないため、決して呼び出すことができません。では、この関数は何を取るのでしょうか？概念的には、それは唯一のインスタンスが存在するダミー値を取ります。従って、私たちはそれを明示的に言及する必要はありません。しかし、Haskellではこの値に対するシンボルがあります: 空の丸括弧、\code{()}。ですから、面白い偶然に (それとも偶然ではないのでしょうか？) 、void型の関数の呼び出しはC++とHaskellで同じように見えます。また、Haskellの簡潔さを愛するために、同じシンボル\code{()}が、

単集合に対応する型、コンストラクタ、および唯一の値を表すために使用されます。だから、ここにHaskellでのこの関数があります: 

\src{snippet07}
最初の行は、\code{f44}が型\code{()}、つまり「Unit型」から\code{Integer}型への関数であると宣言します。2行目は\code{f44}を定義し、Unit型の唯一のコンストラクタ、つまり\code{()}にパターンマッチングをして、数値44を生成します。この関数を呼び出すにはUnit値\code{()}を提供します: 

\begin{snip}{c}
f44 ()
\end{snip}
Unit型から任意の型$A$への関数は、その集合$A$の要素と一対一の対応関係にあることに注意してください。

Unitを返す関数、つまりHaskellではUnitを返す型についてはどうでしょうか？C++ではこのような関数は副作用のために使用されますが、私たちはそれらが数学的な意味での実際の関数ではないことを知っています。Unitを返す純粋関数は何もしません: それはその引数を破棄します。

数学的には、集合$A$から単集合への関数は、$A$のすべての要素をその単集合の単一要素にマップします。すべての$A$に対して、正確に1つのそのような関数があります。ここに\code{Integer}のためのその関数があります: 

\src{snippet08}
あなたはそれに任意の整数を与え、それはあなたにUnitを返します。簡潔さの精神で、Haskellはワイルドカードパターンであるアンダースコアを、捨てられる引数に対して使用することを許可します。この方法で、それに名前を発明する必要はありません。ですから、上記は次のように書き換えることができます: 

\src{snippet09}
この関数の実装は、それに渡された値に依存しないだけでなく、引数の型にも依存しません。

任意の型に対して同じ公式で実装できる関数は、パラメトリック多相性を持つと言われます。あなたは具体的な型の代わりに型パラメータを使って1つの方程式でそのような関数の全ての族を実装することができます。任意の型からUnit型への多相関数を何と呼ぶべきか？もちろん\code{unit}と呼びます: 

\src{snippet10}
C++では、この関数を次のように書きます: 

\begin{snip}{cpp}
template<class T>
void unit(T) {}
\end{snip}
次に、型の分類の中で二要素集合があります。C++では\code{bool}と呼ばれ、予測可能にHaskellでは\code{Bool}と呼ばれます。違いは、C++の\code{bool}は組み込み型であるのに対し、Haskellでは次のように定義できます: 

\src{snippet11}
 (この定義の読み方は、\code{Bool}が\code{True}か\code{False}のどちらかであるということです。) 原則として、C++でも列挙型としてブール型を定義することが可能です: 

\begin{snip}{cpp}
enum bool {
    true,
    false
};
\end{snip}
しかし、C++の\code{enum}は実は整数です。C++11の``\code{enum class}''を代わりに使用することができますが、その場合はその値をクラス名で修飾する必要があります。つまり、\code{bool::true}や\code{bool::false}といった形式で、それを使用するすべてのファイルに適切なヘッダを含める必要があります。

\code{Bool}からの純粋関数は、ターゲット型から、\code{True}に対応する1つの値と\code{False}に対応する別の1つの値を選びます。

\code{Bool}への関数は\newterm{述語}と呼ばれます。例えば、Haskellライブラリ\code{Data.Char}は\code{isAlpha}や\code{isDigit}のような述語でいっぱいです。C++には\code{isalpha}や\code{isdigit}を定義する同様のライブラリがありますが、これらはBooleanではなく\code{int}を返します。実際の述語は\code{std::ctype}で定義され、\code{ctype::is(alpha, c)}、\code{ctype::is(digit, c)}などの形式を取ります。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        お気に入りの言語で高階関数 (または関数オブジェクト) \code{memoize}を定義してください。この関数は純粋関数\code{f}を引数として取り、\code{f}とほとんど同じように振る舞う関数を返しますが、元の関数を各引数に対して一度だけ呼び出し、結果を内部に保存し、その後同じ引数で呼び出されるたびにこの保存された結果を返します。メモ化された関数は、そのパフォーマンスを見ることで元の関数と区別することができます。例えば、評価に長い時間がかかる関数をメモ化してみてください。最初にそれを呼び出したときは結果を待たなければなりませんが、同じ引数で後続の呼び出しでは、結果を即座に得るはずです。
  \item
        標準ライブラリのランダムな数を生成するために通常使用する関数をメモ化してみてください。うまくいきますか？
  \item
        ほとんどのランダム数生成器はシードで初期化することができます。シードを取り、そのシードでランダム数生成器を呼び出し、結果を返す関数を実装してください。その関数をメモ化してください。うまくいきますか？
  \item
        以下のC++関数のどれが純粋ですか？それらをメモ化し、複数回呼び出したときに何が起こるかを観察してください: メモ化されたものとそうでないもの。

        \begin{enumerate}
          \tightlist
          \item
                本文中の例の階乗関数。
          \item
                \begin{minted}{cpp}
std::getchar()
\end{minted}
          \item
                \begin{minted}{cpp}
bool f() {
    std::cout << "Hello!" << std::endl;
    return true;
}
\end{minted}
          \item
                \begin{minted}{cpp}
int f(int x) {
    static int y = 0;
    y += x;
    return y;
}
\end{minted}
        \end{enumerate}
  \item
        \code{Bool}から\code{Bool}への異なる関数はいくつありますか？それらをすべて実装できますか？
  \item
        対象が型\code{Void}、\code{()} (Unit) 、\code{Bool}のみである圏の図を描いてください。これらの型間のすべての可能な関数に対応する射で、そして関数の名前で射をラベル付けしてください。
\end{enumerate}
