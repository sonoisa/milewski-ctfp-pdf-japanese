% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{様}{々な}例について学ぶことで、圏についての深い理解が得られます。圏はあらゆる形や大きさで存在し、思いがけない場所に現れることがあります。まずは非常に単純なものから始めましょう。

\section{無対象}

最も単純な圏は対象がないもので、従って、射もありません。それ自体では非常に寂しい圏ですが、他の圏の文脈では重要かもしれません。例えば、全ての圏の圏 (実際に存在します) の文脈では。空集合が意味を持つなら、空の圏が意味を持たない理由はないでしょう？

\section{単純なグラフ}

対象を射で結びつけることにより、圏を構成することができます。任意の有向グラフから始めて、それを圏にするためにさらに射を追加していくことを想像してみてください。まず、各ノードに恒等射を追加します。次に、一方の終わりが他方の始まりと一致する (別の言葉でいうと、\newterm{合成可能な (composable)}) 任意の2つの射について、それらの合成として機能する新しい射を追加します。新しい射を追加するたびに、他の射 (恒等射を除く) および自身との合成について考慮する必要があります。通常、無限に多くの射になりますが、それは問題ありません。

このプロセスを別の方法で見ると、あなたはグラフの各ノードに対応する対象を持ち、合成可能なグラフのエッジのすべての可能な\newterm{連鎖 (chain)}を射として持つ圏を作成していると言えます。(恒等射も長さゼロの特別な連鎖とみなすことができます。)

このような圏は、与えられたグラフによって生成される\newterm{自由圏 (free category)}と呼ばれます。これは自由構成 (free construction)、つまりは、与えられた構造を最小限のアイテムで拡張してその規則 (ここでは圏の規則) を満たすプロセスの一つの例です。後で更に多くの例を見ることになります。

\section{順序}

そして今度は全く違うものです！射が対象間の関係を表す圏です。ここでは「以下 (等しいか小さい) 」という関係を扱います。これが実際に圏であるか確認してみましょう。恒等射はありますか？すべての対象は自身以下ですから大丈夫！合成はありますか？もし \(a \leqslant b\) かつ \(b \leqslant c\) ならば \(a \leqslant c\) ですから大丈夫！合成は結合的ですか？大丈夫！このような関係を持つ集合は\newterm{前順序 (preorder)}と呼ばれ、前順序は確かに圏です。

また、もし \(a \leqslant b\) かつ \(b \leqslant a\) ならば \(a\) が \(b\) と同じでなければならないという追加条件を満たす、より強い関係もあります。それは\newterm{半順序 (partial order)}と呼ばれます。

最後に、任意の2つの対象が何らかの方法で互いに関連しているという条件を課すことができます。それによって得られるものは\newterm{線形順序 (linear order)}または\newterm{全順序 (total order)}と呼ばれます。

これらの順序集合を圏として特徴付けしましょう。前順序は、任意の対象 \(a\) から任意の対象 \(b\) への射が高々1つだけ存在する圏です。このような圏の別名は「痩せた圏 (thin category)」です。前順序は痩せた圏です。

圏 \(\cat{C}\) における対象 \(a\) から対象 \(b\) への射の集合は\newterm{ホム集合 (hom-set)}と呼ばれ、\(\cat{C}(a, b)\) (または、時には \(\mathbf{Hom}_{\cat{C}}(a, b)\)) と表記されます。従って、前順序のすべてのホム集合は空か単集合のいずれかです。それには対象 \(a\) から \(a\) への射の集合であるホム集合 \(\cat{C}(a, a)\) も含まれますが、これは任意の前順序で単一要素、つまり恒等射のみを含む必要があります。しかし、前順序には循環が存在する可能性があります。循環は半順序では禁止されます。

前順序、半順序、および全順序を認識できることは非常に重要です。なぜなら、それらはソートに関連しているからです。クイックソート、バブルソート、マージソートなどのソートアルゴリズムは、全順序でのみ正しく機能するからです。半順序はトポロジカルソートを使用してソートできます。

\section{集合としてのモノイド}

モノイド (monoid) は恥ずかしいくらい単純ですが、驚くほど強力な概念です。それは基本的な算術の背後に存在する概念です。加算と乗算の両方がモノイドを形成します。モノイドはプログラミングにおいて至る所に存在します。文字列、リスト、畳み込み可能なデータ構造、並行プログラミングのfuture、関数型リアクティブプログラミングのイベントなどとして現れます。

伝統的に、モノイドは二項演算を持つ集合として定義されます。この演算に要求されるのは、それが結合的であることと、単位のように振る舞う特別な要素があることだけです。

例えば、ゼロを含む自然数は、加算の下でモノイドを形成します。結合性とは、次のようなことを意味します。
\[(a + b) + c = a + (b + c)\]
(つまり、数を足すときに括弧を省略できるということです。) 

中立要素 (neutral element、単位要素) はゼロです。なぜなら: 
\[0 + a = a\]
そして
\[a + 0 = a\]
であるからです。2番目の方程式は冗長です。なぜなら加算は可換 \(a + b = b + a\) です。しかし、可換性はモノイドの定義にはありません。例えば、文字列の連結は可換ではありませんが、それでもモノイドを形成します。ちなみに、文字列の連結における中立要素は空文字列であり、元の文字列を変えることなく、前後のどちら側にも付け加えることができます。

Haskellではモノイドのための型クラスを定義できます --- それは \code{mempty} と呼ばれる中立要素と \code{mappend} と呼ばれる二項演算のある型です:

\src{snippet01}
2引数関数の型シグネチャ \code{m -> m -> m} は最初は奇妙に見えるかもしれませんが、
Curry化について議論した後なら完全に納得できるでしょう。複数の矢印を持つシグネチャは、2つの基本的な方法で解釈することができます。一つは、複数の引数を持つ関数としてであり、右端の型が戻り値であるとみます。もう一つは、1つの引数 (左端のもの) を持つ関数としてであり、関数を返すとみます。後者の解釈は \code{m -> (m -> m)} のように括弧 (これは冗長です。矢印は右結合的ですから) を追加することで強調されることがあります。
この解釈については後ほど振り返ります。

注意として、Haskellでは \code{mempty} と \code{mappend} のモノイド的な性質 (つまり、\code{mempty} が中立であり、\code{mappend} が結合的であるという事実) を表現する方法がありません。これらが満たされることを保証するのはプログラマの責任です。

HaskellのクラスはC++のクラスほど侵襲的ではありません。新しい型を定義するとき、そのクラスを前もって指定する必要はありません。いくらでも指定を先延ばしにして、後から型が何かのクラスのインスタンスであると宣言できる自由があります。例として、\code{String} を \code{mempty} と \code{mappend} の実装を提供することでモノイドとして宣言してみましょう (これは実際、標準のPreludeでも行われます): 

\src{snippet02}
ここでは、\code{String} が文字のリストであるため、リストの連結演算子 \code{(++)} を再利用しています。

Haskellの構文について補足: どんな中置演算子も、括弧で囲むことにより2引数関数に変換することができます。2つの文字列があれば、\code{++} を間に挿入することによりそれらを連結することができます: 

\begin{snip}{haskell}
"Hello " ++ "world!"
\end{snip}
あるいは、括弧で囲んだ \code{(++)} に2つの引数としてそれらを渡すこともできます: 

\begin{snip}{haskell}
(++) "Hello " "world!"
\end{snip}
関数への引数はコンマで区切られられず、括弧で括られることもないことに注意してください。(これはHaskellを学ぶ際に慣れるのが最も難しいことかもしれません。) 

Haskellでは、次のように関数同士の等式を表現できることを強調しておきます。

\begin{snip}{haskell}
mappend = (++)
\end{snip}
概念的には、これは関数が生成する値の等価性を表現することとは異なります。例えば: 

\begin{snip}{haskell}
mappend s1 s2 = (++) s1 s2
\end{snip}
前者は圏 $\Hask$ (もしくは、ボトム、つまり永遠に終わらない計算を無視するならば $\Set$) における射の等式に翻訳されます。このような等式は、より簡潔であるだけでなく、しばしば他の圏に一般化することもできます。後者は\newterm{外延的 (extensional)}等式と呼ばれ、任意の2つの入力文字列に対して、\code{mappend} と \code{(++)} の出力が同じであるという事実を述べています。引数の値は時々\newterm{ポイント (点)} (例: $f$ の点 $x$ での値) と呼ばれるため、これはポイントワイズ (point-wise) 等式と呼ばれます。引数を指定しない関数の等式は、\newterm{ポイントフリー (point-free)}といいます。(ちなみに、ポイントフリー等式には、点で表現される関数の合成が含まれることが多くあるため、初学者は少し混乱するかもしれません。) 

C++でモノイドを宣言するのに一番近い方法は、C++20標準のコンセプト機能を使用するものでしょう。

\begin{snip}{cpp}
template<class T>
struct mempty;

template<class T>
T mappend(T, T) = delete;

template<class M>
concept Monoid = requires (M m) {
    { mempty<M>::value() } -> std::same_as<M>;
    { mappend(m, m) } -> std::same_as<M>;
};
\end{snip}
最初の定義は、各特殊化に対して中立要素を保持するための構造です。

キーワード \code{delete} は、デフォルト値が定義されていないことを意味します。ケースバイケースで指定される必要があるということです。そういうことで、\code{mappend} にはデフォルト値がありません。

コンセプト \code{Monoid} は、与えられた型 \code{M} に対して適切な \code{mempty} と \code{mappend} の定義が存在するかどうかをチェックします。

Monoidコンセプトのインスタンス化は、適切な特殊化とオーバーロードを提供することでなされます: 

\begin{snip}{cpp}
template<>
struct mempty<std::string> {
    static std::string value() { return ""; }
};

template<>
std::string mappend(std::string s1, std::string s2) {
    return s1 + s2;
}
\end{snip}

\section{圏としてのモノイド}

以上のものは集合の要素の観点からのモノイドの「よく知られた」定義です。しかし、ご存知のように、圏論では集合とその要素から離れて、その代わりに対象と射を用いた議論を目指します。そこで少し視点を変えて、二項演算子の適用を、集合の周りを「移動する」あるいは「シフトする」ものとして考えてみましょう。

例えば、すべての自然数に5を加える演算があります。これは0を5に、1を6に、2を7といったように写像します。これは自然数の集合で定義された関数です。よし、これで関数と集合を用意できました。一般的に、任意の数 $n$ に対応して、$n$ を加える関数「$n$ の加算関数」が存在します。

加算関数はどのように合成されますか？5を加える関数と7を加える関数の合成は、12を加える関数です。従って、加算関数の合成は加算の規則と等価な存在になります。よし、これで加算を関数の合成に置き換えることができました。

しかし、待ってください、もっとあります。中立要素、ゼロの加算関数もあります。ゼロの加算は何も動かしませんので、自然数の集合の恒等関数です。

私があなたに伝統的な加算の規則を与える代わりに、その情報を一切失わずに、同じく加算関数の合成則を与えることができます。加算関数の合成は関数の合成が結合的であるため、結合的であることに注意してください。そして、恒等関数に対応するゼロ加算関数もあります。

勘の良い読者なら、整数から加算関数への写像が \code{mappend} の型シグネチャの2番目の解釈、つまり \code{m -> (m -> m)} から導かれることに気づいたかもしれません。このことは \code{mappend} がモノイド集合の要素を、その集合に作用する関数に写像することを示しています。

さて、自然数の集合を扱っているということを忘れて、それを単一の対象とたくさんの射 (加算関数たち) の塊として考えてみてください。モノイドは単一の対象の圏です。実際、モノイドという名前は、単一を意味するギリシャ語の \emph{mono} から来ています。すべてのモノイドは、適切な合成則に従う射の集合を持つ単一の対象の圏として記述することができます。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/monoid.jpg}
\end{figure}

\noindent
文字列の連結は興味深いケースです。なぜなら、右アペンダー (文字列の右側に追加する関数) と左アペンダー (文字列の左側に追加する関数。あるいは、もしあなたがそう呼びたいなら、\emph{プリペンダー}) を定義する選択肢があるからです。その2つのモデルの合成表は互いに鏡のように逆さになります。「foo」の後に「bar」をアペンドすることは、「bar」をプリペンドした後に「foo」をプリペンドすることに相当することは簡単に納得できるでしょう。

すべての圏論的なモノイド --- 単一対象の圏 --- が、二項演算を備えた集合的なモノイドを一意に定めるか疑問を持ったかもしれません。実は、単一対象の圏から常に集合を抽出することができます。この集合は、私たちの例では加算関数としての射の集合です。言い換えれば、圏 \(\cat{M}\) の単一対象 \(m\) のホム集合 \(\cat{M}(m, m)\) を持っています。私たちはこの集合内で簡単に二項演算を定義できます。集合の2つの要素のモノイド的積は、それらの要素に対応する射の合成結果に対応する要素です。2つの \(\cat{M}(m, m)\) の要素 \(f\) と \(g\) が与えられたとき、それらの積は合成 \(f \circ g\) に対応します。合成は常に存在します。なぜなら、これらの射のソースとターゲットは同じ対象だからです。そしてそれは圏の規則によって結合的です。恒等射はこの積の中立要素です。従って、私たちは常に圏としてのモノイドから集合としてのモノイドを復元することができます。すべての意図と目的において、それらは同一です。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/monoidhomset.jpg}
  \caption{モノイドのホム集合は、射としても、集合内の点としても見ることができる。}
\end{figure}

\noindent
数学者にとっては一つ気になる小さな疑問があります。射が必ずしも集合を形成する必要はないということです。圏の世界には、集合よりも大きいものが存在します。任意の2つの対象間の射が集合を形成する圏は、局所的に小さい (locally small) と呼ばれます。私が約束したように、そのような微妙さをほとんど無視するつもりですが、記録に残しておくべきだと思いました。

圏論における多くの興味深い現象の根底には、ホム集合の要素を、合成則に従う射として、または集合内の点として見ることができるという事実があります。今回は $\cat{M}$ の射の合成が集合 $\cat{M}(m, m)$ 内のモノイダル積に変換されました。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        以下から自由圏を生成してみましょう。

        \begin{enumerate}
          \tightlist
          \item
                ノードが1つでエッジがないグラフ
          \item
                ノードが1つで、1つの (有向) エッジがあるグラフ (ヒント: このエッジは自分自身と合成できます) 
          \item
                2つのノードとそれらの間に単一の矢印があるグラフ
          \item
                単一のノードと、アルファベット文字が刻印された26本の矢印があるグラフ: a, b, c \ldots{} z
        \end{enumerate}
  \item
        これはどのような種類の順序ですか？

        \begin{enumerate}
          \tightlist
          \item
                包含関係による集合の集合。集合 $A$ が集合 $B$ に包含されるとは、$A$ のすべての要素が $B$ の要素でもある場合のことです。
          \item
                次のサブタイピング関係によるC++型。\code{T1} が \code{T2} のサブタイプであるとは、\code{T1} へのポインターを \code{T2} へのポインターを期待する関数に渡すことができ、コンパイルエラーを引き起こさない場合のことです。
        \end{enumerate}
  \item
        \code{Bool} が \code{True} と \code{False} の2つの値の集合であることを考慮して、演算子 \code{\&\&} (AND) と \code{||} (OR) のそれぞれに関して、1つずつ (集合論的) モノイドが形成されることを示してください。
  \item
        AND演算子を持つ \code{Bool} モノイドを圏として表現してください。射とその合成則をリストアップしてください。
  \item
        3を法とする加算をモノイド圏として表現してください。
\end{enumerate}

