% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{圏}{を}学ぶことで、様々な例を通して実際に圏についての深い理解が得られます。圏はあらゆる形や大きさで存在し、思いがけない場所に現れることがあります。まずは非常に単純なものから始めましょう。

\section{対象なし}

最も単純な圏は、対象も射もゼロの圏です。それ自体では非常に寂しい圏ですが、他の圏の文脈では重要かもしれません。例えば、全ての圏の圏 (実際に存在します) の文脈では。空集合が意味を持つなら、空の圏が意味を持たない理由はありません。

\section{単純なグラフ}

対象を射で結びつけることにより、圏を構成することができます。任意の有向グラフから始めて、それを圏にするためにさらに射を追加していくことを想像してみてください。まず、各ノードに恒等射を追加します。次に、一方の終わりが他方の始まりと一致する (つまり、合成可能な) 任意の2つの射について、それらの合成として機能する新しい射を追加します。新しい射を追加するたびに、他の射 (恒等射を除く) および自身との合成を考慮する必要があります。通常、無限に多くの射になりますが、それは問題ありません。

このプロセスを別の方法で見ると、あなたはグラフの各ノードに対応する対象を持ち、合成可能なグラフのエッジのすべての可能なチェーンを射として持つ圏を作成していると言えます。 (恒等射も長さゼロのチェーンとして考慮することもできます。) 

このような圏は、与えられたグラフによって生成される自由圏と呼ばれます。これは自由構成の例であり、与えられた構造を最小限のアイテムで拡張してその規則 (ここでは圏の規則) を満たすプロセスです。将来的には、それについてさらに多くの例を見るでしょう。

\section{順序}

そして今、完全に異なるものです！射が対象間の関係、すなわち小さいか等しい関係である圏について考えましょう。それが実際に圏であるかどうかを確認してみましょう。恒等射はありますか？すべての対象は自身に対して小さいか等しいです: チェック！合成はありますか？もし \(a \leqslant b\) かつ \(b \leqslant c\) ならば \(a \leqslant c\): チェック！合成は結合的ですか？チェック！このような関係を持つ集合は前順序と呼ばれ、前順序は確かに圏です。

また、もし \(a \leqslant b\) かつ \(b \leqslant a\) ならば \(a\) が \(b\) と同じでなければならないという追加条件を満たす、より強い関係もあります。それは半順序と呼ばれます。

最後に、任意の2つの対象が何らかの方法で互いに関連しているという条件を課すことができます。それによって得られるのは線形順序または全順序です。

これらの順序付けられた集合を圏として特徴付けましょう。前順序は、任意の対象 \(a\) から任意の対象 \(b\) への射が高々1つだけ存在する圏です。このような圏の別名は「痩せた圏」です。前順序は痩せた圏です。

圏 \(\cat{C}\) における対象 \(a\) から対象 \(b\) への射の集合はホム集合と呼ばれ、\(\cat{C}(a, b)\) (または、時には \(\mathbf{Hom}_{\cat{C}}(a, b)\)) と表記されます。したがって、前順序のすべてのホム集合は空か単集合のいずれかです。それには対象 \(a\) から \(a\) への射の集合であるホム集合 \(\cat{C}(a, a)\) も含まれますが、これは任意の前順序で単一要素、つまり恒等射のみを含む必要があります。しかし、前順序にはサイクルが存在する可能性があります。サイクルは半順序では禁止されています。

前順序、半順序、および全順序を認識できることは非常に重要です。なぜなら、それらはソートに関連しているからです。クイックソート、バブルソート、マージソートなどのソートアルゴリズムは、全順序でのみ正しく機能します。半順序はトポロジカルソートを使用してソートできます。

\section{モノイドとしての集合}

モノイドは恥ずかしく単純ですが、驚くほど強力な概念です。それは基本的な算術の背後にある概念です: 加算と乗算の両方がモノイドを形成します。モノイドはプログラミングにおいて至る所に存在します。文字列、リスト、折りたたみ可能なデータ構造、並行プログラミングのフューチャー、関数型リアクティブプログラミングのイベントなどとして現れます。

伝統的に、モノイドは二項演算を持つ集合として定義されます。この演算に要求されるのは、それが結合的であり、それに関して振る舞いのような特別な要素があることだけです。

例えば、ゼロを含む自然数は、加算の下でモノイドを形成します。結合性とは、次のようなことを意味します: 
\[(a + b) + c = a + (b + c)\]
 (つまり、数を加算するときには括弧を省略できます。) 

中立要素 (neutral element、単位要素) はゼロです。なぜなら: 
\[0 + a = a\]
そして
\[a + 0 = a\]
2番目の方程式は冗長です。なぜなら加算は可換 \(a + b = b + a\) ですが、可換性はモノイドの定義の一部ではありません。例えば、文字列の連結は可換ではありませんが、それでもモノイドを形成します。ちなみに、文字列の連結における中立要素は空文字列であり、文字列のどちらの側にも付け加えても変わりません。

Haskellではモノイドのための型クラスを定義できます --- それは中立要素を \code{mempty} と呼び、二項演算を \code{mappend} と呼ぶ型です: 

\src{snippet01}
2引数関数の型シグネチャ、
\code{m -> m -> m} は最初は奇妙に見えるかもしれませんが、
Curry化について話し合った後には完全に理解できるでしょう。複数の矢印を持つシグネチャを2つの基本的な方法で解釈することができます: 複数の引数を持つ関数として、右端の型が戻り値であるか、あるいは1つの引数 (左端のもの) を持つ関数として、関数を返すものとしてです。後者の解釈は、矢印が右結合であるために冗長である括弧を追加することで強調されることがあります: \code{m -> (m -> m)}。
この解釈については後ほど戻ってきます。

Haskellでは、\code{mempty} と \code{mappend} のモノイダルな性質 (つまり、\code{mempty} が中立であり、\code{mappend} が結合的であるという事実) を表現する方法がありません。それらが満たされていることを保証するのはプログラマの責任です。

HaskellのクラスはC++のクラスほど侵襲的ではありません。新しい型を定義するとき、そのクラスを前もって指定する必要はありません。いくらでも先延ばしにして、後から任意の型をいくつかのクラスのインスタンスであると宣言する自由があります。例として、\code{String} を \code{mempty} と \code{mappend} の実装を提供することでモノイドとして宣言しましょう (これは標準のPreludeであなたのために行われます) : 

\src{snippet02}
ここでは、\code{String} が文字のリストであるため、リストの連結演算子 \code{(++)} を再利用しています。

Haskellの構文について: どんな中置演算子も、括弧で囲むことにより2引数関数に変換することができます。2つの文字列があれば、\code{++} を間に挿入することによりそれらを連結することができます: 

\begin{snip}{haskell}
"Hello " ++ "world!"
\end{snip}
あるいは、括弧で囲んだ \code{(++)} に2つの引数としてそれらを渡すこともできます: 

\begin{snip}{haskell}
(++) "Hello " "world!"
\end{snip}
関数への引数はコンマで区切られられず、括弧で囲まれません。 (これはHaskellを学ぶ際に慣れるのが最も難しいことの一つかもしれません。) 

Haskellが関数の等価性を表現することを許すことを強調することが価値があります。例えば、次のように表現します: 

\begin{snip}{haskell}
mappend = (++)
\end{snip}
概念的には、これは関数が生成する値の等価性を表現することとは異なります。例えば: 

\begin{snip}{haskell}
mappend s1 s2 = (++) s1 s2
\end{snip}
前者は圏 $\Hask$ (もしくは、bottoms、つまり永遠に終わらない計算を無視するならば $\Set$) における射の等価性に翻訳されます。このような等式は、より簡潔であり、しばしば他の圏に一般化することができます。後者は拡張的等価性と呼ばれ、任意の2つの入力文字列に対して、\code{mappend} と \code{(++)} の出力が同じであるという事実を述べています。引数の値が時々ポイント (例: $f$ の $x$ での値) と呼ばれるため、これはポイントワイズ等価性と呼ばれます。引数を指定せずに関数の等価性を述べることは、ポイントフリーとして記述されます。 (ちなみに、ポイントフリー等式はしばしば関数の合成を含みますが、これは初学者にとっては少し混乱するかもしれません。) 

C++でモノイドを宣言する最も近い方法は、C++20標準のコンセプト機能を使用することです。

\begin{snip}{cpp}
template<class T>
struct mempty;

template<class T>
T mappend(T, T) = delete;

template<class M>
concept Monoid = requires (M m) {
    { mempty<M>::value() } -> std::same_as<M>;
    { mappend(m, m) } -> std::same_as<M>;
};
\end{snip}
最初の定義は、各特殊化に対して中立要素を保持する構造です。

\code{delete} キーワードは、デフォルト値が定義されていないことを意味します: それはケースバイケースで指定される必要があります。同様に、\code{mappend} にはデフォルトがありません。

コンセプト \code{Monoid} は、与えられた型 \code{M} に対して適切な \code{mempty} と \code{mappend} の定義が存在するかどうかをテストします。

Monoidコンセプトのインスタンス化は、適切な特殊化とオーバーロードを提供することによって達成することができます: 

\begin{snip}{cpp}
template<>
struct mempty<std::string> {
    static std::string value() { return ""; }
};

template<>
std::string mappend(std::string s1, std::string s2) {
    return s1 + s2;
}
\end{snip}

\section{モノイドとしての圏}

それは集合とその要素から離れて、対象と射について話すことを目指している圏論を知っているように、「二項演算を適用する」ということは集合内で「動かす」または「シフトする」ことを意味すると少し考え方を変えてみましょう。

例えば、すべての自然数に5を加える操作があります。それは0を5に、1を6に、2を7にマッピングします。それは自然数の集合で定義された関数です。良いです: 私たちは関数と集合を持っています。一般的に、任意の数 $n$ に対して、$n$ を加える関数、「$n$ の加算関数」があります。

加算関数はどのように合成されますか？5を加える関数と7を加える関数の合成は、12を加える関数です。したがって、加算関数の合成は加算の規則と等価にすることができます。それも良いです: 私たちは加算を関数の合成に置き換えることができます。

しかし、待ってください、もっとあります: 中立要素、ゼロの加算関数もあります。ゼロを加えることは何も動かしません、それでそれは自然数の集合の恒等関数です。

私があなたに伝統的な加算の規則を与える代わりに、私は同じくらいの情報を失うことなく、加算関数の合成則を与えることができます。注意してください、加算関数の合成は関数の合成が結合的であるため、結合的です。そして私たちは、恒等関数に対応するゼロ加算関数を持っています。

気付くかもしれない識者は、整数から加算関数へのマッピングが \code{mappend} の型シグネチャの2番目の解釈、つまり

 \code{m -> (m -> m)} から従うと指摘するかもしれません。それは私たちに \code{mappend} がモノイド集合の要素をその集合上で作用する関数にマッピングすることを教えています。

さて、あなたが自然数の集合を扱っているという事実を忘れて、それを単一の対象、射の束である塊として考えてみてください。モノイドは単一の対象の圏です。実際、モノイドという名前は、単一を意味するギリシャ語の \emph{mono} から来ています。すべてのモノイドは、適切な合成則に従う射の集合を持つ単一の対象の圏として記述することができます。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/monoid.jpg}
\end{figure}

\noindent
文字列の連結は興味深いケースです。なぜなら、私たちは右アペンダーと左アペンダー (あるいはプレペンダー、もしあなたが望むなら) を定義する選択肢を持っているからです。2つのモデルの合成テーブルは互いに逆転します。あなたは簡単に自分自身を納得させることができます: 「foo」の後に「bar」を追加することは、「bar」をプレペンドした後に「foo」をプレペンドすることに相当します。

あなたは、すべての圏論的モノイド --- 単一対象の圏 --- が一意の二項演算を備えた集合のモノイドを定義するかどうかという質問をするかもしれません。実は、単一対象の圏から常に集合を抽出することができます。この集合は、私たちの例の加算関数である射の集合です。言い換えれば、圏 \(\cat{M}\) の単一対象 \(m\) のホム集合 \(\cat{M}(m, m)\) を持っています。私たちはこの集合内で二項演算を簡単に定義することができます: 2つの集合要素のモノイダル積は、対応する射の合成に対応する要素です。2つの \(\cat{M}(m, m)\) の要素 \(f\) と \(g\) を与えられれば、それらの積は合成 \(f \circ g\) に対応します。合成は常に存在します。なぜなら、これらの射のソースとターゲットは同じ対象だからです。そしてそれは圏の規則によって結合的です。恒等射はこの積の中立要素です。したがって、私たちは常に圏モノイドから集合モノイドを復元することができます。すべての意図と目的において、彼らは同一です。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/monoidhomset.jpg}
  \caption{モノイドホム集合が射として、そして集合内の点として見られる。}
\end{figure}

\noindent
数学者が摘むべきちょっとした難点があります: 射が必ずしも集合を形成する必要はありません。圏の世界には、集合よりも大きいものが存在します。任意の2つの対象間の射が集合を形成する圏は、局所的に小さいと呼ばれます。私は約束したように、そのような微妙さをほとんど無視するつもりですが、記録に残しておくべきだと思いました。

圏論における多くの興味深い現象の根底には、ホム集合の要素を、合成則に従う射として、または集合内の点として見ることができるという事実があります。ここでは、$\cat{M}$ の射の合成が集合 $\cat{M}(m, m)$ 内のモノイダル積に変換されます。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        以下から自由圏を生成してみましょう: 

        \begin{enumerate}
          \tightlist
          \item
                ノードが1つでエッジがないグラフ
          \item
                ノードが1つで1つの (有向) エッジがあるグラフ (ヒント: このエッジは自分自身と合成できます) 
          \item
                2つのノードとそれらの間に単一の矢印があるグラフ
          \item
                単一のノードとアルファベットの文字でマークされた26の矢印があるグラフ: a, b, c \ldots{} z.
        \end{enumerate}
  \item
        これはどのような種類の順序ですか？

        \begin{enumerate}
          \tightlist
          \item
                含まれる関係による集合の集合: 集合 \(A\) が集合 \(B\) に含まれるのは、\(A\) のすべての要素が \(B\) の要素でもある場合です。
          \item
                次のサブタイピング関係によるC++型: \code{T1} が \code{T2} のサブタイプである場合、\code{T1} へのポインターを \code{T2} へのポインターを期待する関数に渡すことができ、コンパイルエラーを引き起こさない。
        \end{enumerate}
  \item
        \code{Bool} が \code{True} と \code{False} の2つの値の集合であることを考慮して、それがそれぞれ演算子 \code{\&\&} (AND) と \code{||} (OR) に関して2つの (集合論的) モノイドを形成することを示してください。
  \item
        AND演算子を持つ \code{Bool} モノイドを圏として表現します: 射とその合成則をリストアップしてください。
  \item
        3を法とする加算をモノイド圏として表現します。
\end{enumerate}

