% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{圏}{論}のほとんどの構成は、数学の他のより具体的な領域からの結果の一般化です。積、余積、モノイド、指数などは、圏論が知られる前から知られていました。それらは数学の異なる分野で異なる名前で知られていたかもしれません。集合論におけるデカルト直積、順序論におけるミート、論理学における論理積 — これらはすべて圏論的積の抽象的なアイデアの具体的な例です。

この点で、米田の補題は他の数学の分野でほとんどまたは全く前例のない一般的な圏についての包括的な声明として際立っています。いくつかは、その最も近い類似物は群論のCayleyの定理です (すべての群はいくつかの集合の置換群と同型です)。

米田の補題の設定は、任意の圏$\cat{C}$と、$\cat{C}$から$\Set$への関手$F$とを合わせたものです。前の節で、いくつかの$\Set$値関手が表現可能である、つまりホム関手と同型であることを見ました。米田の補題は、すべての$\Set$値関手が自然変換を通じてホム関手から得られ、そのような変換を明示的に列挙すると言っています。

自然変換について話したとき、自然性条件がかなり制限的である可能性があると述べました。ある対象における自然変換のコンポーネントを定義すると、自然性はそれを射を通じて別の対象に「輸送」するのに十分強力かもしれません。ソースとターゲットの圏の対象間の射が多ければ多いほど、自然変換のコンポーネントを輸送するための制約が多くなります。$\Set$は非常に射が豊富な圏です。

米田の補題は、ホム関手と任意の他の関手$F$との間の自然変換が、たった一点、つまり$\id_a$における$\alpha_a$の単一の値を指定することによって完全に決定されることを教えてくれます。自然性条件から残りの自然変換がただちに従います。

だから、米田の補題に関わる二つの関手の間の自然性条件を見直しましょう。最初の関手はホム関手です。それは$\cat{C}$の任意の対象$x$を射の集合$\cat{C}(a, x)$に写像します — $a$は$\cat{C}$の固定された対象です。また、任意の射$f$を$x \to y$から$\cat{C}(a, f)$に写像することも見ました。

二番目の関手は任意の$\Set$値関手$F$です。

これら二つの関手間の自然変換を$\alpha$と呼びましょう。$\Set$で作業しているので、自然変換のコンポーネント、例えば$\alpha_x$や$\alpha_y$は単なる集合間の通常の関数です: 
\begin{gather*}
  \alpha_x \Colon \cat{C}(a, x) \to F x \\
  \alpha_y \Colon \cat{C}(a, y) \to F y
\end{gather*}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/yoneda1.png}
\end{figure}

\noindent
そしてこれらが単なる関数であるので、私たちは特定の点でのそれらの値を見ることができます。しかし、集合$\cat{C}(a, x)$の中の点とは何でしょうか？ここが重要な観察です: 集合$\cat{C}(a, x)$の中の全ての点もまた$a$から$x$への射$h$です。

だから$\alpha$に対する自然性の四角形: 
\[\alpha_y \circ \cat{C}(a, f) = F f \circ \alpha_x\]
は、$h$に作用するとき、点ごとに次のようになります: 
\[\alpha_y (\cat{C}(a, f) h) = (F f) (\alpha_x h)\]
前の節から射$f$に対するホム関手$\cat{C}(a,-)$の作用は前合成として定義されたことを思い出してください: 
\[\cat{C}(a, f) h = f \circ h\]
それによって次のようになります: 
\[\alpha_y (f \circ h) = (F f) (\alpha_x h)\]
この条件がどれほど強いかは、$x = a$の場合に特化することによって見ることができます。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/yoneda2.png}
\end{figure}

\noindent
その場合$h$は$a$から$a$への射になります。少なくとも一つのそういう射、$h = \id_a$があることがわかっています。それを挿入しましょう: 
\[\alpha_y f = (F f) (\alpha_a \id_a)\]
ただちに何が起こったかに気づいてください: 左側は$\cat{C}(a, y)$の任意の要素$f$に対する$\alpha_y$の作用です。そしてそれは$\id_a$における$\alpha_a$の単一の値によって完全に決定されます。私たちはそのような任意の値を選ぶことができ、それは自然変換を生成します。$\alpha_a$の値は$F a$の集合にありますから、$F a$の任意の点はいくつかの$\alpha$を定義することができます。

逆に、$\cat{C}(a, -)$から$F$への任意の自然変換$\alpha$が与えられたら、それを$\id_a$で評価して$F a$の中の点を得ることができます。

これによって米田の補題が証明されました: 

\begin{quote}
  $\cat{C}(a, -)$から$F$への自然変換と$F a$の要素との間には一対一の対応関係があります。
\end{quote}
言い換えれば、
\[\cat{Nat}(\cat{C}(a, -), F) \cong F a\]
あるいは、$\cat{C}$と$\Set$の間の関手圏に対する表記$[\cat{C}, \Set]$を使えば、自然変換の集合はその圏のホム集合であり、次のように書くことができます: 
\[[\cat{C}, \Set](\cat{C}(a, -), F) \cong F a\]
この対応関係が実際には自然同型であることを後で説明します。

この結果についていくらか直感を得ましょう。最も驚くべきことは、全体の自然変換がただ一つの核となる点: $\id_a$でそれに割り当てる値から結晶化するということです。それは自然性条件に従ってその点から広がります。それは$\cat{C}$の$\Set$への像を溢れさせます。だからまず、$\cat{C}(a, -)$の下での$\cat{C}$の像が何であるかを考えましょう。

まず$a$自身の像から始めましょう。ホム関手$\cat{C}(a, -)$の下で、$a$は集合$\cat{C}(a, a)$に写像されます。他方、関手$F$の下では、それは集合$F a$に写像されます。自然変換$\alpha_a$のコンポーネントは$\cat{C}(a, a)$から$F a$へのいくつかの関数です。集合$\cat{C}(a, a)$の中の一点、$\id_a$に対応する点に注目しましょう。それがただの集合の中の点であるという事実を強調するために、それを$p$と呼びましょう。コンポーネント$\alpha_a$は$p$を$F a$の中のいくつかの点$q$に写像すべきです。任意の$q$の選択が一意の自然変換につながることを示します。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/yoneda3.png}
\end{figure}

\noindent
最初の主張は、一つの点$q$の選択が残りの関数$\alpha_a$を一意に決定するということです。確かに、$\cat{C}(a, a)$の中の他の任意の点$p'$を選びましょう。それは$a$から$a$へのいくつかの射$g$に対応します。そして、ここで米田の補題の魔法が起こります: $g$は集合$\cat{C}(a, a)$の中の点$p'$として見ることができます。同時に、それは集合間の二つの\emph{関数}を選択します。確かに、ホム関手の下で、射$g$は関数$\cat{C}(a, g)$に写像され、$F$の下で$F g$に写像されます。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/yoneda4.png}
\end{figure}

\noindent
今、$\cat{C}(a, g)$が私たちの元の$p$、すなわち$\id_a$に対応するものに作用することを考えましょう。それは前合成として定義されます、$g \circ \id_a$、それは$g$に等しく、私たちの点$p'$に対応します。だから射$g$は、$p$に作用すると$p'$を生成する関数に写像されます、それは$g$です。私たちは一周しました！

今、$F g$が$q$に作用することを考えましょう。それは$F a$の中のいくつかの点$q'$です。自然性の四角形を完成させるために、$p'$は$\alpha_a$の下で$q'$に写像されなければなりません。私たちは任意の$p'$ (任意の$g$) を選んで、$\alpha_a$の下でのその写像を導き出しました。関数$\alpha_a$はそうして完全に決定されます。

$a$に接続されている$\cat{C}$の任意の対象$x$に対して、$\alpha_x$も一意に決定されるという第二の主張があります。推論は類似していますが、今度は2つの追加の集合、$\cat{C}(a, x)$と$F x$があり、$a$から$x$への射$g$はホム関手の下で次のように写像されます: 
\[\cat{C}(a, g) \Colon \cat{C}(a, a) \to \cat{C}(a, x)\]
そして$F$の下では: 
\[F g \Colon F a \to F x\]
再び、$\cat{C}(a, g)$が私たちの$p$に作用することは前合成によって与えられます: $g \circ \id_a$、それは$\cat{C}(a, x)$の中の点$p'$に対応します。自然性は$\alpha_x$が$p'$に作用する値を決定します: 
\[q' = (F g) q\]
$p'$が任意であったので、関数$\alpha_x$全体がそうして決定されます。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/yoneda5.png}
\end{figure}

\noindent
$a$に接続がない$\cat{C}$の対象があった場合はどうでしょうか？それらはすべて$\cat{C}(a, -)$の下で単一の集合 --- 空集合に写像されます。空集合は集合の圏の始対象です。それはこの集合から任意の他の集合への一意の関数があることを意味します。この関数を\code{absurd}と呼びます。だからここでも、自然変換のコンポーネントに対して選択の余地はありません: それは\code{absurd}以外にはありえません。

米田の補題を理解する一つの方法は、$\Set$値関手間の自然変換が関数の族であり、関数は一般的に情報を損失するものであることを認識することです。関数は情報を崩壊させるかもしれませんし、その終域の一部だけを覆うかもしれません。損失がない唯一の関数は可逆なもの、つまり同型です。それに続いて、最良の構造を保持する$\Set$値関手は表現可能なものです。それらはホム関手か、ホム関手に自然に同型な関手です。任意の他の関手$F$は、情報を失う変換を通じてホム関手から得られます。そのような変換は情報を失うだけでなく、関手$F$の$\Set$における像のごく一部しか覆わないかもしれません。

\section{Haskellでの米田}

すでにHaskellでホム関手に出会いました、それはreader関手の仮面をかぶっています: 

\src{snippet01}
Readerは射 (ここでは関数) を前合成によって写像します: 

\src{snippet02}
米田の補題は、Reader関手が任意の他の関手に自然に写像できると教えてくれます。

自然変換は多相的関数です。だから、関手\code{F}が与えられたら、私たちはReader関手からそれに対する写像を持っています: 

\src{snippet03}
通常、\code{forall}は省略可能ですが、自然変換のパラメトリック多相性を強調するために、私はそれを明示的に書くのが好きです。

米田の補題は、これらの自然変換が\code{F a}の要素と一対一に対応していることを教えてくれます: 

\begin{snipv}
forall x . (a -> x) -> F x \ensuremath{\cong} F a
\end{snipv}
この等式の右側は、私たちが通常データ構造と考えるものです。関手を一般化されたコンテナとしての解釈を覚えていますか？\code{F a}は\code{a}のコンテナです。しかし、左側は関数を引数として取る多相的関数です。米田の補題は、二つの表現が等価である、つまり同じ情報を含んでいることを教えてくれます。

これを言い換えると: 私にこの型の多相的関数を与えてください: 

\src{snippet04}
そして私は\code{a}のコンテナを生成します。トリックは、米田の補題の証明で使用したものと同じです: この関数を\code{id}で呼び出して、\code{F a}の要素を得ます: 

\src{snippet05}
逆もまた真です: \code{F a}の型の値が与えられた場合: 

\src{snippet06}
誰かが正しい型の多相的関数を定義できます: 

\src{snippet07}
二つの表現間を簡単に行き来することができます。

複数の表現を持つ利点は、一方が他方よりも組み合わせやすいか、あるいはいくつかの応用においてより効率的である可能性があることです。

この原理の最も単純な例は、しばしばコンパイラ開発に使用されるコード変換です: 継続渡しスタイルまたは\acronym{CPS}です。それは、恒等関手に米田の補題を適用した最も単純な応用です。\code{F}を恒等関手で置き換えると: 

\begin{snipv}
forall r . (a -> r) -> r \ensuremath{\cong} a
\end{snipv}
この公式の解釈は、任意の型\code{a}が\code{a}を受け取る「ハンドラー」を取る関数に置き換えられるということです。ハンドラーは\code{a}を受け入れて残りの計算を行う関数です。  (型\code{r}は通常、何らかの種類の状態コードをカプセル化します。) 

このプログラミングスタイルは、UI、非同期システム、および並行プログラミングで非常に一般的です。CPSの欠点は、制御の反転が含まれることです。コードはプロデューサーとコンシューマー (ハンドラー) の間で分割され、容易に組み合わせることができません。状態フルハンドラーが交錯するスパゲッティコードの悪夢に慣れている人は誰でも、Webプログラミングをある程度以上行ったことがあるでしょう。後で見るように、関手とモナドの賢明な使用は、CPSの組成特性のいくつかを復元することができます。

\section{余米田}

いつものように、射の方向を反転することによってボーナス構造を得ます。米田の補題は、逆圏$\cat{C}^\mathit{op}$に適用され、反変関手間の写像を与えます。

同等に、私たちは、私たちのホム関手の代わりにターゲット対象を固定することによって、余米田の補題を導出することができます。私たちは$\cat{C}$から$\Set$への反変ホム関手$\cat{C}(-, a)$を得ます。余米田の補題の反変版は、この関手から任意の他の反変関手$F$への自然変換と$F a$の集合の要素との間に一対一の対応を確立します: 
\[\cat{Nat}(\cat{C}(-, a), F) \cong F a\]
これがHaskell版の余米田の補題です: 

\begin{snipv}
forall x . (x -> a) -> F x \ensuremath{\cong} F a
\end{snipv}
いくつかの文献では、反変版が米田の補題と呼ばれていることに注意してください。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        Haskellでの米田同型を形成する二つの関数\code{phi}と\code{psi}が互いに逆であることを示してください。

        \begin{snip}{haskell}
phi :: (forall x . (a -> x) -> F x) -> F a
phi alpha = alpha id

psi :: F a -> (forall x . (a -> x) -> F x)
psi fa h = fmap h fa
\end{snip}
  \item
        対象はあるが、恒等射以外の射がない離散圏に対して、米田の補題はどのように機能しますか？
  \item
        単位のリスト\code{{[}(){]}}は、その長さ以外の情報を含みません。したがって、データ型として、それは整数のエンコーディングと見なすことができます。空リストはゼロを、一つの要素のリスト\code{{[}(){]}} (値であり型ではありません) は一を、そして以下同様です。リスト関手に対する米田の補題を使用して、このデータ型の別の表現を構成してください。
\end{enumerate}

\section{参考文献}

\begin{enumerate}
  \tightlist
  \item
        \urlref{https://www.youtube.com/watch?v=TLMxHB19khE}{Catsters}のビデオ。
\end{enumerate}

