% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{型}{を}組み合わせる基本的な方法として、積と余積を見てきました。日常的なプログラミングでの多くのデータ構造は、これら二つの仕組みを使って構成できることがわかります。これは重要な実践的な意味を持ちます。データ構造の多くの特性は合成可能です。例えば、基本型の値の等価性を比較する方法と、これを積型や余積型に一般化する方法を知っていれば、複合型の等価演算子の導出を自動化できます。Haskellでは等価性、比較、文字列への変換およびその逆変換などを、複合型の大部分に対して自動的に導出できます。

プログラミングにおける積型と和型をもう少し詳しく見てみましょう。

\section{積型}

プログラミング言語における二つの型の積の標準的な実装はペアです。Haskellではペアはプリミティブな型コンストラクタです; C++では標準ライブラリで定義された比較的複雑なテンプレートです。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/pair.jpg}
\end{figure}

\noindent
ペアは厳密には可換ではありません:  \code{(Int, Bool)} のペアは \code{(Bool, Int)} のペアに置き換えることはできませんが、同じ情報を持っています。しかし、同型性を考慮すれば可換です --- この同型性は \code{swap} 関数 (自身の逆関数である) によって与えられます: 

\src{snippet01}
これらの二つのペアを、同じデータを異なる形式で格納していると考えることができます。これはビッグエンディアンとリトルエンディアンのようなものです。

任意の数の型を積に組み合わせることができますが、ペアをペアの中に入れ子にする方法よりも簡単な方法があります: 入れ子になったペアはタプルと等価です。これは異なる方法でペアを入れ子にすることが同型であるという事実の帰結です。例えば、\code{a}、\code{b}、そして\code{c} という三つの型をこの順番で積に組み合わせたい場合、二つの方法でこれを行うことができます: 

\src{snippet02}

または
\src{snippet03}
これらの型は異なります --- 一方を他方が期待する関数に渡すことはできません --- しかし、その要素は一対一の対応を持ちます。一方を他方に写像する関数があります: 

\src{snippet04}
そして、この関数は可逆です: 

\src{snippet05}
したがって、これは同型です。これらは単に同じデータを異なる方法で再パッケージングする異なる方法です。

型の積の生成を、型に対する二項演算として解釈することができます。その観点から、上記の同型はモノイドで見た結合則に非常に似ています: 
\[(a * b) * c = a * (b * c)\]
ただし、モノイドの場合、二つの積の組み合わせ方は等価でしたが、ここでは「同型上で等しい」だけです。

同型を受け入れることができ、厳密な等価性にこだわらない場合、さらに進んでUnit型 \code{()} を、1が乗算の単位要素であるのと同じ方法で積の単位として示すことができます。確かに、ある型 \code{a} の値と単位のペアリングは、いかなる情報も追加しません。型: 

\src{snippet06}
は \code{a} と同型です。ここに同型があります: 

\src{snippet07}

\src{snippet08}
これらの観察は、集合の圏 $\Set$ が\newterm{モノイダル圏}であると言うことによって形式化できます。これは、対象 (ここではデカルト積を取る) を乗算できる意味で、圏でありながらもモノイドです。モノイダル圏について、そして完全な定義については後で詳しく説明します。

特に、和型と組み合わせる場合、Haskellで積型を定義するより一般的な方法があります。これは複数の引数を持つ名前付きコンストラクタを使用します。例えば、ペアは次のように代替的に定義できます: 

\src{snippet09}
ここで、\code{Pair a b} は他の二つの型、\code{a} と \code{b} によってパラメータ化された型の名前であり、\code{P} はデータコンストラクタの名前です。二つの型を \code{Pair} 型コンストラクタに渡すことでペア型を定義します。適切な型の二つの値をコンストラクタ \code{P} に渡すことでペア値を構成します。例えば、\code{String} と \code{Bool} のペアとして \code{stmt} という値を定義しましょう: 

\src{snippet10}
最初の行は型宣言です。これは、\code{Pair} の型コンストラクタを使用し、\code{a} と \code{b} を \code{Pair} の汎用定義で置き換える \code{String} と \code{Bool} を使用します。二行目は、データコンストラクタ \code{P} に具体的な文字列と具体的なブール値を渡すことによって実際の値を定義します。型コンストラクタは型を構成するために使用され、データコンストラクタは値を構成するために使用されます。

型とデータコンストラクタの名前空間がHaskellで分かれているため、両方に同じ名前が使われることがよくあります、例えば: 

\src{snippet11}
そして十分に目を細めると、組み込みのペア型もこの種の宣言の変形であると見なすことができます。ここでは名前 \code{Pair} が二項演算子 \code{(,)} に置き換えられています。実際には、\code{(,)} を他の名前付きコンストラクタのように使用し、接頭辞記法を使用してペアを作成することができます: 

\src{snippet12}
同様に、\code{(,,)} を使用して三つ組を作成し、それ以降も同様です。

汎用ペアやタプルの代わりに、特定の名前付き積型を定義することもできます、例えば: 

\src{snippet13}
これは単に \code{String} と \code{Bool} の積ですが、それ自体の名前とコンストラクタが与えられています。この宣言スタイルの利点は、同じ内容でも異なる意味と機能を持ち、互いに置換できない多くの型を定義できることです。

タプルや複数引数コンストラクタを使用したプログラミングは、どのコンポーネントが何を表しているかを追跡することが雑然としており、エラーが発生しやすいものです。コンポーネントに名前を付けることがしばしば望ましいです。名前付きフィールドを持つ積型は、Haskellで\newterm{レコード}と呼ばれ、Cで\code{struct}と呼ばれます。

\section{レコード}

簡単な例を見てみましょう。私たちは、二つの文字列、名前と記号; そして整数、原子番号; を一つのデータ構造に結合することで化学元素を記述したいと思います。タプル \code{(String, String, Int)} を使用して、どのコンポーネントが何を表しているかを覚えておくことができます。コンポーネントはパターンマッチングによって抽出され、次のような関数で行われます。この関数は、元素の記号がその名前の接頭辞であるかどうかをチェックします (例えば、\textbf{He} が \textbf{Helium} の接頭辞であるように) : 

\src{snippet14}
このコードはエラーが発生しやすく、読みにくく、メンテナンスが困難です。レコードを定義する方がずっと良いでしょう: 

\src{snippet15}
二つの表現は、以下の二つの変換関数によって証明されるように、互いに同型です。これらはお互いの逆です: 

\src{snippet16}

\src{snippet17}
レコードフィールドの名前は、これらのフィールドにアクセスする関数としても機能します。たとえば、\code{atomicNumber e} は \code{e} から \code{atomicNumber} フィールドを取り出します。\code{atomicNumber} を関数として使用すると、型: 

\src{snippet18}
\code{Element} のレコード構文を使うと、関数 \code{startsWithSymbol} はより読みやすくなります: 

\src{snippet19}
Haskellのトリックを使って、関数 \code{isPrefixOf} を逆引用符で囲んで中置演算子に変え、ほとんど文のように読むことができるようにすることもできます: 

\src{snippet20}
この場合、括弧は省略できます。なぜなら、中置演算子は関数呼び出しよりも優先順位が低いからです。

\section{和型}

集合の圏における積が積型を生じるように、余積も和型を生じます。Haskellで和型の典型的な実装は次のようになります: 

\src{snippet21}
そして、ペアと同様に、\code{Either}も可換です (同型性まで) し、入れ子にすることができ、入れ子の順序は関係ありません (同型性まで) 。例えば、三つ組の和の等価物を定義することができます: 

\src{snippet22}
等々。

実際、集合の圏 $\Set$ は余積に関しても (対称的な) モノイダル圏です。二項演算の役割は不連続和によって演じられ、単位要素の役割は始対象によって演じられます。型の観点では、\code{Either} がモノイダル演算子として、\code{Void}、すなわち住人のいない型がその中立要素として機能します。\code{Either} をプラスと考え、\code{Void} をゼロと考えることができます。実際に、\code{Void} を和型に加えてもその内容は変わりません。例えば: 

\src{snippet23}
は \code{a} と同型です。それはこの型の \code{Right} バージョンを構成する方法がないためです --- \code{Void} の値は存在しません。 \code{Either a Void} の唯一の住人は \code{Left} コンストラクタを使って構成され、単に \code{a} 型の値をカプセル化しています。したがって、象徴的に $a + 0 = a$ です。

和型はHaskellではかなり一般的ですが、そのC++の等価物であるunionやvariantはあまり一般的ではありません。その理由はいくつかあります。

まず、最も単純な和型は単なる列挙型であり、C++では \code{enum} を使って実装されます。Haskellの和型の等価物: 

\src{snippet24}
のC++版は次のようになります: 

\begin{snip}{cpp}
enum { Red, Green, Blue };
\end{snip}
さらに単純な和型: 

\src{snippet25}
はC++のプリミティブな \code{bool} です。

値の存在または不在をエンコードする単純な和型は、空の文字列、負の数、nullポインタなどの特別なトリックや「不可能な」値を使ってC++でさまざまに実装されています。この種のオプショナリティは、意図的であれば、Haskellでは \code{Maybe} 型を使って表現されます: 

\src{snippet26}
\code{Maybe} 型は二つの型の和です。二つのコンストラクタを個別の型に分離すると、最初のものは次のようになります: 

\src{snippet27}
これは \code{Nothing} と呼ばれる値を一つ持つ列挙型です。言い換えると、それは単集合であり、Unit型 \code{()} と同等です。二番目の部分: 

\src{snippet28}
は単に型 \code{a} をカプセル化しています。私たちは、\code{Maybe} を次のようにエンコードできたでしょう: 

\src{snippet29}
より複雑な和型は、しばしばC++でポインタを使用して偽装されます。ポインタはnullであるか、または特定の型の値を指しているかのどちらかです。例えば、(再帰的な)和型として定義できるHaskellのリスト型: 

\src{snippet30}
は、空リストを実装するためのnullポインタのトリックを使用してC++に翻訳することができます: 

\begin{snip}{cpp}
template<class A>
class List { 
    Node<A> * _head;
public:
    List() : _head(nullptr) {} // Nil
    List(A a, List<A> l)       // Cons
      : _head(new Node<A>(a, l))
    {}
};
\end{snip}
二つのHaskellコンストラクタ \code{Nil} と \code{Cons} は、同様の引数 (\code{Nil} にはなし、\code{Cons} には値とリスト) を持つ二つのオーバーロードされた \code{List} コンストラクタに翻訳されます。和型の二つのコンポーネントを区別するためにタグを必要としない代わりに、 \code{\_head} の特別な \code{nullptr} 値を使用して \code{Nil} をエンコードします。

しかし、HaskellとC++の型の主な違いは、Haskellのデータ構造が不変であることです。特定のコンストラクタを使ってオブジェクトを作成すると、そのオブジェクトは永遠にどのコンストラクタが使われたか、どの引数がそれに渡されたかを覚えています。したがって、 \code{Just "energy"} として作成された \code{Maybe} オブジェクトは決して \code{Nothing} にはなりません。同様に、空のリストは永遠に空であり、3つの要素を持つリストは常に同じ3つの要素を持ちます。

この不変性が構成を可逆にします。オブジェクトが与えられたら、それを構成に使用されたパーツまで常に分解することができます。この分解はパターンマッチングで行われ、コンストラクタはパターンとして再利用されます。コンストラクタの引数、もしあれば、変数 (または他のパターン) に置き換えられます。

\code{List} データ型には二つのコンストラクタがあるため、任意の \code{List} の分解は、それらのコンストラクタに対応する二つのパターンを使います。一つは空の \code{Nil} リストにマッチし、もう一つは \code{Cons} で構成されたリストにマッチします。例えば、ここに \code{List} 上の単純な関数の定義があります: 

\src{snippet31}
\code{maybeTail} の定義の最初の部分は、パターンとして \code{Nil} コンストラクタを使用し、\code{Nothing} を返します。二番目の部分は、\code{Cons} コンストラクタをパターンとして使用します。最初のコンストラクタ引数をワイルドカードで置き換えます。なぜなら、私たちはそれに興味がないからです。 \code{Cons} への二番目の引数は変数 \code{t} に束縛されます (これらのものを変数と呼びますが、厳密に言えば、それらは決して変化しません: 一度式に束縛されると、変数は決して変わりません) 。返り値は \code{Just t} です。今、あなたの \code{List} がどのように作成されたかに応じて、それは一つの節にマッチします。それが \code{Cons} を使って作成された場合、それに渡された二つの引数が回収されます (そして最初のものが破棄されます) 。

さらに複雑な和型は、C++で多型クラス階層を使用して実装されます。共通の祖先を持つクラスの族は、一つの変種型として理解することができます。その中で、vtableは隠されたタグとして機能します。Haskellではコンストラクタにパターンマッチングを行い、特殊なコードを呼び出すことが行われるのと同様のことが、C++ではvtableポインタに基づいて仮想関数への呼び出しをディスパッチすることで達成されます。

\code{union} がC++で和型としてあまり使われない理由は、そこに入れることができるものに重大な制限があるためです。コピー構造体を持つ \code{std::string} をunionに入れることさえできません。

\section{型の代数}

個別に取り扱うと、積型と和型は多様な有用なデータ構造を定義するために使用することができますが、2つを組み合わせることから真の強みが生まれます。再び、構成の力を呼び出しています。

これまでに発見したことを要約してみましょう。我々は、\code{Void} を中立要素とする和型と、Unit型 \code{()} を中立要素とする積型という、2つの可換モノイダル構造を型システムの下に見てきました。それらを加算と乗算に類似させて考えたいと思います。この類推では、\code{Void} はゼロに、単位、\code{()} は一に相当するでしょう。

この類推をどこまで伸ばすことができるか見てみましょう。例えば、ゼロによる乗算はゼロを与えるのか？言い換えれば、一つのコンポーネントが \code{Void} である積型は \code{Void} と同型ですか？例えば、\code{Int} と \code{Void} のペアを作成することは可能でしょうか？

ペアを作成するためには2つの値が必要です。整数を簡単に思いつくことはできますが、 \code{Void} 型の値はありません。したがって、任意の型 \code{a} に対して、型 \code{(a, Void)} は住人がいない --- 値がない --- したがって \code{Void} と同等です。言い換えれば、$a \times 0 = 0$ です。

加算と乗算を結び付けるもう一つのことは分配則です: 
\[a \times (b + c) = a \times b + a \times c\]
これも積型と和型のために成り立ちますか？はい、それは成り立ちます --- いつものように、通常は同型性までです。左辺に対応する型は: 

\src{snippet32}
そして右辺に対応する型は: 

\src{snippet33}
一方向への変換を行う関数はこちらです: 

\src{snippet34}
そして、もう一方向への変換を行う関数はこちらです: 

\src{snippet35}
\code{case of} 文は関数内でのパターンマッチングに使用されます。各パターンは矢印に続いて、パターンがマッチした時に評価される式が続きます。例えば、値を持って \code{prodToSum} を呼び出す場合: 

\src{snippet36}
\code{e} は \code{case e of} で \code{Left "Hi!"} と等しくなります。それはパターン \code{Left y} と一致し、\code{"Hi!"} を \code{y} として置き換えます。既に \code{x} に \code{2} と一致させているため、\code{case of} 節の結果、そして関数全体の結果は、期待通り \code{Left (2, "Hi!")} になります。

これら二つの関数が互いに逆であることを証明するつもりはありませんが、それらについて考えると、そうでなければならないとわかります！それらはただ二つのデータ構造の内容を単純に再パッケージングしているだけです。同じデータ、ただ異なるフォーマットです。

これらのような互いに結びついたモノイドには数学者が名前をつけています: それを\newterm{半環}と呼びます。それは完全な\newterm{環}ではありません、なぜなら我々は型の減算を定義することができないからです。それがなぜ半環は時々\newterm{rig}、つまり「n (negative、否定的) なしの環」と呼ばれるのかという理由です。しかしながら、それを除いて、我々は自然数についての声明、それがrigを形成するという声明を型についての声明に翻訳することから多くの利益を得ることができます。ここに興味のあるいくつかのエントリーの翻訳表があります: 

\begin{longtable}[]{@{}ll@{}}
  \toprule
  数字      & 型\tabularnewline
  \midrule
  \endhead
  $0$          & \code{Void}\tabularnewline
  $1$          & \code{()}\tabularnewline
  $a + b$      & \code{Either a b = Left a | Right b}\tabularnewline
  $a \times b$ & \code{(a, b)} または \code{Pair a b = Pair a b}\tabularnewline
  $2 = 1 + 1$  & \code{data Bool = True | False}\tabularnewline
  $1 + a$      & \code{data Maybe = Nothing | Just a}\tabularnewline
  \bottomrule
\end{longtable}

\noindent
リスト型はかなり興味深いです、なぜならそれは方程式の解として定義されているからです。我々が定義している型は方程式の両側に現れます: 

\src{snippet37}
もし我々が通常の置換を行い、また \code{List a} を \code{x} と置き換えると、我々は方程式を得ます: 

\begin{Verbatim}
  x = 1 + a * x
\end{Verbatim}
我々は伝統的な代数的手法を使用してそれを解くことはできません、なぜなら我々は型を減算したり除算したりすることができないからです。しかし、我々は右辺の \code{x} を \code{(1 + a*x)} と置き換え、分配則を使って続ける一連の置換を試みることができます。これは以下のシリーズにつながります: 

\begin{Verbatim}
  x = 1 + a*x
  x = 1 + a*(1 + a*x) = 1 + a + a*a*x
  x = 1 + a + a*a*(1 + a*x) = 1 + a + a*a + a*a*a*x
  ...
  x = 1 + a + a*a + a*a*a + a*a*a*a...
\end{Verbatim}
我々は無限の積 (タプル) の和で終わります、それは次のように解釈されます: リストは空、\code{1} であるか、単一要素、\code{a} であるか、ペア、\code{a*a} であるか、三つ組、\code{a*a*a} であるか、等々…まさにリストがそうです --- \code{a} の列！

リストにはそれ以上のものがあり、我々は関手と不動点について学んだ後にリストと他の再帰的データ構造に戻ってきます。

記号変数を使った方程式の解法、それが代数です！それがこれらの型に彼らの名前を与えるものです: 代数的データ型。

最後に、型の代数の非常に重要な解釈について言及するべきです。二つの型 \code{a} と \code{b} の積は \code{a} \emph{と} \code{b} の両方の値を含まなければならないことに注意してください、これは両方の型が居住されていなければならないことを意味します。一方で二つの型の和は、 \code{a} \emph{または} \code{b} の値を含むので、それらの一つが居住されていれば十分です。\emph{and} と \emph{or} の論理も半環を形成し、それも型理論にマッピングすることができます: 

\begin{longtable}[]{@{}ll@{}}
  \toprule
  論理                & 型\tabularnewline
  \midrule
  \endhead
  $\mathit{false}$     & \code{Void}\tabularnewline
  $\mathit{true}$      & \code{()}\tabularnewline
  $a \mathbin{||} b$   & \code{Either a b = Left a | Right b}\tabularnewline
  $a \mathbin{\&\&} b$ & \code{(a, b)}\tabularnewline
  \bottomrule
\end{longtable}

\noindent
この類似はより深く、論理と型理論の間のCurry-Howard対応の基礎を形成しています。我々は関数型について話すときにそれに戻ってきます。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        \code{Maybe a} と \code{Either () a} の間の同型を示してください。
  \item
        Haskellで定義された和型をこちらです: 

        \begin{snip}{haskell}
data Shape = Circle Float 
           | Rect Float Float
\end{snip}
        \code{Shape} に対して行動するような関数、例えば \code{area} を定義したいとき、我々は二つのコンストラクタに対してパターンマッチングを行います: 

        \begin{snip}{haskell}
area :: Shape -> Float
area (Circle r) = pi * r * r
area (Rect d h) = d * h
\end{snip}
        C++またはJavaで \code{Shape} をインターフェースとして実装し、\code{Circle} と \code{Rect} の二つのクラスを作成してください。\code{area} を仮想関数として実装してください。
  \item
        前の例に引き続き: \code{Shape} の周囲を計算する \code{circ} という新しい関数を簡単に追加できます。我々は \code{Shape} の定義に触れることなくそれを行うことができます: 

        \begin{snip}{haskell}
circ :: Shape -> Float
circ (Circle r) = 2.0 * pi * r
circ (Rect d h) = 2.0 * (d + h)
\end{snip}
        あなたのC++またはJavaの実装に \code{circ} を追加してください。元のコードのどの部分に触れましたか？
  \item
        さらに進んで: 新しい形状、\code{Square} を \code{Shape} に追加し、必要なすべての更新を行ってください。HaskellとC++またはJavaではどのコードに触れなければならなかったか？ (あなたがHaskellプログラマでなくても、変更はかなり明白であるはずです。) 
  \item
        同型の違いを除いて (up to isomorphism)、型に対して $a + a = 2 \times a$ が成り立つことを示してください。私たちの翻訳表によれば、$2$ が \code{Bool} に対応することを思い出してください。
\end{enumerate}

