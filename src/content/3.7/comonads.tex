% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{モ}{ナド}を理解した今、射を反転させ逆圏で作業することで、双対性の恩恵を受けて余モナドを自由に得ることができます。

基本的に、モナドはKleisli射の合成に関するものです: 

\src{snippet01}
ここで、\code{m}はモナドである関手です。余モナドについては、文字\code{w} (\code{m}の逆さ) を使い、余Kleisli射を以下の型の射として定義できます: 

\src{snippet02}
余Kleisli射のための魚オペレータの類似物は以下のように定義されます: 

\src{snippet03}
余Kleisli射が圏を形成するためには、\code{extract}と呼ばれる恒等的な余Kleisli射も必要です: 

\src{snippet04}
これは\code{return}の双対です。また、結合則と左右の恒等則を課す必要があります。すべてをまとめると、Haskellで余モナドを定義することができます: 

\src{snippet05}
実際には、後ほど見るように、わずかに異なる基本要素を使用します。

では、プログラミングにおける余モナドの使用法は何でしょうか？

\section{余モナドでのプログラミング}

モナドと余モナドを比較してみましょう。モナドは\code{return}を使って値をコンテナに入れる方法を提供します。それはコンテナ内に保存された値や値へのアクセスを提供しません。もちろん、モナドを実装するデータ構造はその内容にアクセスを提供するかもしれませんが、それはボーナスと考えられます。モナドから値を抽出する共通のインターフェースはありません。そして、その内容を決して公開しない\code{IO}モナドの例を見てきました。

一方、余モナドはそこから単一の値を抽出する手段を提供します。それは値を挿入する手段を提供しません。ですから、余モナドをコンテナと考えるなら、それは常に内容で満たされており、中身を覗くことができます。

Kleisli射が値を取り、何らかの文脈を加えた結果を生成するように --- それは文脈を加えることです --- 余Kleisli射は文脈全体と一緒に値を取り、結果を生成します。それは\newterm{文脈的計算}の体現です。

\section{積型余モナド}

Readerモナドを覚えていますか？読み取り専用環境\code{e}へのアクセスが必要な計算を実装するためにそれを導入しました。そのような計算は以下の形式の純粋関数として表されます: 

\src{snippet06}
私たちはCurry化を使ってそれらをKleisli射に変換しました: 

\src{snippet07}
しかし、これらの関数はすでに余Kleisli射の形をしています。それらの引数をより便利な関手形式に整理しましょう: 

\src{snippet08}
合成オペレータを簡単に定義できます。合成している射に同じ環境を利用可能にします: 

\src{snippet09}
\code{extract}の実装は単純に環境を無視します: 

\src{snippet10}
驚くべきことに、積型余モナドはReaderモナドとまったく同じ計算を実行するために使用することができます。ある意味で、余モナドの環境実装はより自然です --- それは「文脈における計算」の精神に従います。一方、モナドは\code{do}表記の便利な構文を持っています。

Readerモナドと積型余モナドの間のつながりはさらに深く、Reader関手が積関手の右随伴であるという事実に関係しています。一般的には、余モナドはモナドとは異なる計算の概念をカバーします。後でさらに多くの例を見るでしょう。

任意の積型、タプルやレコードを含む、\code{Product}余モナドを一般化するのは簡単です。

\section{合成の解剖}

双対化のプロセスを続けると、モナド的な結合やjoinを双対化することができます。代わりに、魚オペレータの解剖に使用したプロセスを繰り返すことができます。このアプローチはより啓蒙的に思えます。

出発点は、合成オペレータが\code{w a}を取り、\code{c}を生成する余Kleisli射を生成する必要があるという実現です。唯一の方法で\code{c}を生成するには、\code{w b}型の引数に第二の関数を適用することです: 

\src{snippet11}
しかし、どのようにして\code{w b}型の値を生成し、それを\code{g}に供給することができるでしょうか？私たちが使用できるのは、型\code{w a}の引数と関数\code{f :: w a -> b}です。
その解決策は、結合の双対であるextendを定義することです: 

\src{snippet12}
\code{extend}を使って合成を実装できます: 

\src{snippet13}
次に、\code{extend}を解剖できるかどうかを考えるかもしれません。関数\code{w a -> b}を引数\code{w a}に適用するだけでいいのではないかと誘惑されるかもしれませんが、その結果の\code{b}を\code{w b}に変換する方法がないことにすぐ気づきます。覚えておいてください、余モナドは値を持ち上げる手段を提供しません。この点で、モナドの類似構造では\code{fmap}を使いました。ここで\code{fmap}を使う唯一の方法は、\code{w (w a)}型のものを手元に持っている場合です。もし私たちが\code{w a}を\\ \code{w (w a)}に変換できればいいのです。そして、便利なことに、それはまさに\code{join}の双対です。それを\code{duplicate}と呼びます: 

\src{snippet14}
したがって、モナドの定義と同様に、余モナドには余Kleisli射、\code{extend}、または\code{duplicate}を使用する3つの同等の定義があります。以下は、\code{Control.Comonad}ライブラリから直接取られたHaskellの定義です: 

\src{snippet15}
\code{extend}と\code{duplicate}のデフォルト実装が提供されているため、どちらか一方をオーバーライドするだけで済みます。

これらの関数の背後にある直感は、一般的に余モナドを\code{a}型の値で満たされたコンテナと考えることに基づいています (積型余モナドはちょうど一つの値の特殊なケースでした) 。easily accessible through \code{extract}という「現在の」値があります。余Kleisli射は現在の値に焦点を当てた計算を実行しますが、周囲のすべての値にアクセスできます。Conwayのライフゲームを考えてみてください。各セルには値が含まれています (通常は単に\code{True}または\code{False}) 。ライフゲームの余モナドは「現在の」セルに焦点を当てたセルのグリッドに相当します。

それでは\code{duplicate}は何をしますか？それは余モナドのコンテナ\code{w a}を取り、コンテナのコンテナ\code{w (w a)}を生成します。各コンテナが\code{w a}内の異なる\code{a}に焦点を当てているという考えです。ライフゲームであれば、外側のグリッドの各セルに、異なるセルに焦点を当てた内側のグリッドが含まれます。

そして\code{extend}を見てください。それは余Kleisli射と\code{a}の\code{w a}で満たされた余モナドのコンテナを取ります。それはそれらのすべての\code{a}に計算を適用し、それらを\code{b}に置き換えます。結果は\code{b}で満たされた余モナドのコンテナです。\code{extend}は一つ一つの\code{a}に焦点を移動させ、それらのそれぞれに余Kleisli射を適用することでこれを行います。ライフゲームでは、余Kleisli射は現在のセルの新しい状態を計算します。そのためには、そのコンテキスト --- おそらく最も近い隣人 --- を見ることになります。\code{extend}のデフォルト実装はこのプロセスを示しています。最初に\code{duplicate}を呼び出してすべての可能な焦点を生成し、それからそれぞれに\code{f}を適用します。

\section{ストリーム余モナド}

コンテナの一つの要素から別の要素に焦点を移動するこのプロセスは、無限ストリームの例で最もよく示されます。そのようなストリームはリストのようなものですが、空のコンストラクタがありません: 

\src{snippet16}
それは自明に\code{Functor}です: 

\src{snippet17}
ストリームの焦点はその最初の要素なので、こちらが\code{extract}の実装です: 

\src{snippet18}
\code{duplicate}は異なる要素に焦点を当てたストリームのストリームを生成します。

\src{snippet19}
最初の要素は元のストリームで、二番目の要素は元のストリームの尾です。三番目の要素はその尾で、以下同様に無限に続きます。

こちらが完全なインスタンスです: 

\src{snippet20}
これはストリームを見る非常に機能的な方法です。命令型言語では、ストリームを一つの位置にシフトする\code{advance}メソッドから始めるかもしれません。ここでは、\code{duplicate}は一気にすべてのシフトされたストリームを生成します。Haskellの遅延評価はこれを可能にし、さらに望ましいものにします。もちろん、\code{Stream}を実用的にするためには、\code{advance}の類似物も実装します: 

\src{snippet21}
しかし、それは余モナドインターフェースの一部ではありません。

デジタル信号処理に何らかの経験があるなら、ストリームの余Kleisli射はただのデジタルフィルタであることがすぐにわかります。そして、\code{extend}はフィルタリングされたストリームを生成します。

簡単な例として、移動平均フィルタを実装しましょう。こちらはストリームの最初の\code{n}要素を合計する関数です: 

\src{snippet22}
こちらはストリームの最初の\code{n}要素の平均を計算する関数です: 

\src{snippet23}
部分適用された\code{average n}は余Kleisli射なので、全体のストリームに\code{extend}することができます: 

\src{snippet24}
結果は移動平均のストリームです。

ストリームは一方向、一次元の余モナドの例です。それは簡単に双方向にしたり、二次元以上に拡張することができます。

\section{圏論的に余モナドを定義する}

圏論で余モナドを定義することは、双対性を利用することで直截的な演習です。モナドと同様に、私たちは自己関手\code{T}から始めます。モナドを定義する2つの自然変換$\eta$と$\mu$は、余モナドに対して単純に逆転します: 
\begin{align*}
  \varepsilon & \Colon T \to I   \\
  \delta      & \Colon T \to T^2
\end{align*}
これらの変換のコンポーネントは\code{extract}と\code{duplicate}に対応します。余モナド則はモナド則の鏡像です。ここに大きな驚きはありません。

次に、随伴からモナドを導出します。双対性は随伴を逆転させます: 左随伴は右随伴になり、その逆もまた然りです。そして、$R \circ L$の合成がモナドを定義するので、$L \circ R$は余モナドを定義するはずです。随伴の余単位: 
\[\varepsilon \Colon L \circ R \to I\]
は、実際には余モナドの定義で見るのと同じ$\varepsilon$です---または、Haskellの\code{extract}としてのコンポーネントとしてです。随伴の単位: 
\[\eta \Colon I \to R \circ L\]
を使用して、$L \circ R$の中間に$R \circ L$を挿入し、$L \circ R \circ L \circ R$を生成することができます。$T$から$T^2$を作ることが$\delta$を定義し、それが余モナドの定義を完成させます。

また、モナドがモノイドであることも見てきました。この言明の双対は、余モノイドの使用を必要とするので、何が余モノイドですか？単一対象圏としてのモノイドの元の定義は、何か興味深いものに双対化されません。すべての自己射の方向を逆にしても、別のモノイドが得られます。しかし、モナドへの私たちのアプローチで、私たちはモノイダル圏における対象としてのモノイドのより一般的な定義を使用しました。その構造は二つの射に基づいていました: 
\begin{align*}
  \mu  & \Colon m \otimes m \to m \\
  \eta & \Colon i \to m
\end{align*}
これらの射の逆転はモノイダル圏内の余モノイドを生成します: 
\begin{align*}
  \delta      & \Colon m \to m \otimes m \\
  \varepsilon & \Colon m \to i
\end{align*}
Haskellで余モノイドの定義を書くことができます: 

\src{snippet25}
しかし、それはかなり自明です。明らかに\code{destroy}はその引数を無視します。

\src{snippet26}
\code{split}は単なる関数のペアです: 

\src{snippet27}
次に、モノイドの単位則に双対する余モノイド則を考えます。

\src{snippet28}
ここで、\code{lambda}と\code{rho}はそれぞれ左単位子と右単位子です (モノイダル圏の定義を参照してください) 。定義を差し込むと、\code{g = id}を得ます。同様に、二番目の規則は\code{f = id}に展開されます。結論として: 

\src{snippet30}
これはHaskell (および、一般的には圏$\Set$) では、すべての対象が自明な余モノイドであることを示しています。

幸いなことに、余モノイドを定義するための他のより興味深いモノイダル圏があります。その一つは自己関手の圏です。そして、モナドが自己関手の圏のモノイドであるように、

\begin{quote}
  余モナドは自己関手の圏の余モノイドです。
\end{quote}

\section{ストア余モナド}

もう一つの重要な余モナドの例は、状態モナドの双対です。それは余状態余モナドまたは、代替的にストア余モナドと呼ばれます。

以前に、状態モナドは指数関数を定義する随伴によって生成されることを見ました: 
\begin{align*}
  L z & = z\times{}s      \\
  R a & = s \Rightarrow a
\end{align*}
私たちは同じ随伴を使って余状態余モナドを定義します。余モナドは$L \circ R$の合成によって定義されます: 
\[L (R a) = (s \Rightarrow a)\times{}s\]
これをHaskellに翻訳すると、左側に\code{Product}関手、右側に\code{Reader}関手を持つ随伴から始めます。\code{Product}の後に\code{Reader}を組み合わせることは、次の定義と同等です: 

\src{snippet31}
随伴の余単位を対象$a$で取ると、射は以下のようになります: 
\[\varepsilon_a \Colon ((s \Rightarrow a)\times{}s) \to a\]
または、Haskellの表記で: 

\src{snippet32}
これが私たちの\code{extract}になります: 

\src{snippet33}
随伴の単位: 

\src{snippet34}
は部分的に適用されたデータコンストラクタとして書き直すことができます: 

\src{snippet35}
$\delta$、または\code{duplicate}を、水平合成として構成します: 
\begin{align*}
  \delta & \Colon L \circ R \to L \circ R \circ L \circ R \\
  \delta & = L \circ \eta \circ R
\end{align*}
最左端の$L$を通して$\eta$をこっそりと通す必要があります。それは\code{Product}関手であるため、$\eta$、または\code{Store f}をペアの左側要素に作用させることを意味します (それが\code{Product}に対する\code{fmap}が行うことです) 。私たちは得ます: 

\src{snippet36}
 ($\delta$の式で、$L$と$R$は恒等自然変換を表し、そのコンポーネントは恒等射です。) 

こちらが\code{Store}余モナドの完全な定義です: 

\src{snippet37}
あなたは\code{Reader}部分の\code{Store}を、\code{a}の一般化されたコンテナとして考えるかもしれません。それは\code{s}型の要素を使ってキー付けされています。例えば、\code{s}が\code{Int}であれば、\code{Reader Int a}は\code{a}の無限双方向ストリームです。\code{Store}はこのコンテナをキー型の値と組み合わせます。この場合、\code{extract}はこの整数を使用して無限ストリームをインデックス化します。第二のコンポーネントの\code{Store}を現在の位置と考えることができます。

この例を続けると、\code{duplicate}は\code{Int}でインデックス付けされた新しい無限ストリームを作成します。このストリームにはストリームが要素として含まれます。特に、現在の位置では、元のストリームが含まれます。しかし、他の\code{Int} (正または負) をキーとして使用した場合、その新しいインデックスに位置するシフトされたストリームを取得します。

一般的に、\code{extract}が\code{duplicate}された\code{Store}に作用するとき、それは元の\code{Store}を生成します (実際には、余モナドの恒等則は\code{extract . duplicate = id}を述べています) 。

\code{Store}余モナドは、\code{Lens}ライブラリの理論的基礎として重要な役割を果たします。概念的には、\code{Store s a}余モナドは、型\code{s}をインデックスとして使用してデータ型\code{a}の特定の部分構造に「焦点を当てる」 (レンズのように) ことのアイデアを包含します。特に、型が: 

\src{snippet38}
の関数は、次のペアの関数と等価です: 

\src{snippet39}
\code{a}が積型の場合、\code{set}は\code{a}内の\code{s}型のフィールドを設定しながら、\code{a}の変更されたバージョンを返すとして実装することができます。同様に、\code{get}は\code{a}から\code{s}フィールドの値を読み取るために実装することができます。次のセクションでこれらのアイデアをさらに探求します。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        \code{Store}余モナドを使用してConwayのライフゲームを実装してください。
        ヒント: \code{s}にどんな型を選びますか？
\end{enumerate}


