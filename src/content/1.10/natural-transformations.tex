% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{関}{手}について、それが圏間の構造を保つ写像として機能することを話しました。

関手はある圏を別の圏に「埋め込む」ものです。それは多くのものを一つにまとめることはありますが、接続を断つことはありません。関手を使って、ある圏を別の圏内でモデル化していると考えることができます。ソース圏は、ターゲット圏の一部分の構造のためのモデル、設計図として機能します。

\begin{figure}[H]
  \centering\includegraphics[width=0.4\textwidth]{images/1_functors.jpg}
\end{figure}

\noindent
ある圏を別の圏に埋め込む方法は多くあります。時にはそれらは同等のものもあれば、全く異なるものもあります。一つはソース圏全体を一つの対象に収縮させるかもしれませんが、別のものは各対象を異なる対象に、各射を異なる射に写像するかもしれません。同じ設計図が多くの異なる方法で実現されるのです。自然変換はこれらの実現を比較するのに役立ちます。関手の写像です --- それらの関手的性質を保持する特別な写像です。

圏$\cat{C}$ と $\cat{D}$ の間の関手 $F$ と $G$ を考えてください。$\cat{C}$ のただ一つの対象 $a$ に注目すると、それは二つの対象、$F a$ と $G a$ に写像されます。したがって、関手の写像は $F a$ を $G a$ に写像するべきです。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/2_natcomp.jpg}
\end{figure}

\noindent
$F a$ と $G a$ は同じ圏 $\cat{D}$ の対象であることに注意してください。同じ圏の対象間の写像は、圏の性質に逆らってはなりません。我々は対象間に人工的な接続を作りたくありません。したがって、既存の接続、すなわち射を使用するのが\emph{自然}です。自然変換は射の選択です: 各対象 $a$ に対して、$F a$ から $G a$ への一つの射を選びます。自然変換を $\alpha$ と呼ぶと、この射は $\alpha$ の $a$ における\newterm{コンポーネント}、または $\alpha_a$ と呼ばれます。

\[\alpha_a \Colon F a \to G a\]
$a$ は $\cat{C}$ の対象であるのに対し、$\alpha_a$ は $\cat{D}$ の射であることを念頭に置いてください。

もし $a$ について、$F a$ と $G a$ の間に $\cat{D}$ に射が存在しない場合、$F$ と $G$ の間に自然変換は存在しません。

もちろん、これは話の半分だけです。なぜなら関手は対象だけでなく射も写像するからです。では、自然変換はそれらの写像とはどのように関わるのでしょうか？射の写像は固定されています --- $F$ と $G$ の間の任意の自然変換の下で、$F f$ は $G f$ に変換されなければなりません。さらに、二つの関手による射の写像は、それと整合する自然変換を定義する際の選択肢を大きく制限します。$\cat{C}$ の二つの対象 $a$ と $b$ の間の射 $f$ を考えてみましょう。それは二つの射、$F f$ と $G f$ に $\cat{D}$ で写像されます: 

\begin{gather*}
  F f \Colon F a \to F b \\
  G f \Colon G a \to G b
\end{gather*}
自然変換 $\alpha$ は、\emph{D}で図式を完成させる二つの追加の射を提供します: 

\begin{gather*}
  \alpha_a \Colon F a \to G a \\
  \alpha_b \Colon F b \to G b
\end{gather*}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/3_naturality.jpg}
\end{figure}

\noindent
これで $F a$ から $G b$ への二つの方法があります。それらが等しいことを確かめるために、任意の $f$ に対して成り立つ\newterm{自然性条件}を課さなければなりません: 

\[G f \circ \alpha_a = \alpha_b \circ F f\]
自然性条件はかなり厳しい要求です。例えば、もし射 $F f$ が可逆なら、自然性は $\alpha_b$ を $\alpha_a$ の項で決定します。それは $f$ に沿って $\alpha_a$ を\emph{輸送}します: 

\[\alpha_b = (G f) \circ \alpha_a \circ (F f)^{-1}\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/4_transport.jpg}
\end{figure}

\noindent
もし二つの対象の間に一つ以上の可逆射が存在するなら、これらの輸送は全て一致しなければなりません。一般に、射は可逆でないことが多いですが、二つの関手間に自然変換が存在する可能性は決して保証されていません。そのため、自然変換によって関連付けられる関手の希少性や豊富さは、それらが操作する圏の構造について多くのことを教えてくれるかもしれません。極限や米田の補題について話をするときに、その例をいくつか見ることになります。

自然変換をコンポーネントごとに見ると、それは対象を射に写像すると言えます。自然性条件のために、それは射を可換な四角形に写像するとも言えます --- $\cat{C}$ の各射について $\cat{D}$ に一つの可換な自然性の四角形があります。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/naturality.jpg}
\end{figure}

\noindent
自然変換のこの性質は、多くの圏論的構成に非常に便利で、それらはしばしば可換図式を含んでいます。関手の賢明な選択によって、多くのこれらの可換性条件は自然性条件に変換することができるかもしれません。極限、余極限、そして随伴について話をするときに、その例をいくつか見ることになります。

最後に、自然変換は関手の同型を定義するために使用することができます。二つの関手が自然に同型であると言うことは、ほとんど同じであると言うようなものです。\newterm{自然同型}は、そのコンポーネントが全て同型 (可逆射) である自然変換として定義されます。

\section{多相的関数}

プログラミングにおける関手 (具体的には、自己関手) の役割について話しました。それらは型を型に写像する型コンストラクタに相当します。関手は関数も関数に写像しますが、この写像は\code{fmap} (またはC++での\code{transform}、\code{then}など) という高階関数によって実装されます。

自然変換を構成するには、ここでは型、\code{a}の対象から始めます。ある関手、\code{F}はそれを型 $F a$ に写像します。別の関手、\code{G}はそれを $G a$ に写像します。自然変換\code{alpha}の\code{a}におけるコンポーネントは、$F a$ から $G a$ への関数です。擬似Haskellで: 

\begin{snipv}
alpha\textsubscript{a} :: F a -> G a
\end{snipv}
自然変換は、全ての型 \code{a} に対して定義される多相的関数です: 

\src{snippet01}
\code{forall a} は Haskell ではオプションです (実際には、言語拡張 \code{ExplicitForAll} をオンにする必要があります) 。通常、このように書きます: 

\src{snippet02}
心に留めておくべきことは、これは実際には \code{a} によってパラメータ化された関数の族であるということです。これは Haskell 構文の簡潔さの別の例です。C++ での同様の構造は少し冗長になるでしょう: 

\begin{snip}{cpp}
template<class A> G<A> alpha(F<A>);
\end{snip}
Haskell の多相的関数と C++ のジェネリック関数の間には、これらの関数が実装され、型検査される方法に反映されているより深い違いがあります。Haskell では、多相的関数はすべての型に対して一様に定義されなければなりません。一つの公式がすべての型にわたって機能しなければなりません。これは\newterm{パラメトリック多相性}と呼ばれます。

一方、C++ はデフォルトで\newterm{アドホック多相性}をサポートしています。これは、テンプレートがすべての型に対して正しく定義される必要がないことを意味します。テンプレートが与えられた型で機能するかどうかは、具体的な型が型パラメータに代入されるインスタンス化の時に決定されます。型チェックは遅延され、残念ながらしばしば理解しがたいエラーメッセージを引き起こします。

C++ にはまた、異なる型に対して同じ関数の異なる定義を可能にする関数のオーバーロードとテンプレートの特殊化のメカニズムもあります。Haskell では、この機能は型クラスと型の族によって提供されます。

Haskell のパラメトリック多相性は意外な結果を持ちます: 型が: 

\src{snippet03}
ここで、\code{F} と \code{G} は関手で、任意の多相的関数は自然性条件を自動的に満たします。ここで、圏論的な記法で ($f$ は関数 $f \Colon a \to b$ です) : 

\[G f \circ \alpha_a = \alpha_b \circ F f\]
Haskell では、関手 \code{G} 上の射 \code{f} の作用は \code{fmap} を使用して実装されます。まず、明示的な型注釈を使って擬似Haskellで書きます: 

\begin{snipv}
fmap\textsubscript{G} f . alpha\textsubscript{a} = alpha\textsubscript{b} . fmap\textsubscript{F} f
\end{snipv}
型推論のため、これらの注釈は必要ありません、そして次の方程式が成立します: 

\begin{snip}{text}
fmap f . alpha = alpha . fmap f
\end{snip}
これはまだ本物の Haskell ではありません --- 関数の等価性はコードで表現できないからです --- しかし、それはプログラマが等式推論に使用したり、コンパイラが最適化を実装するために使用できる恒等式です。

Haskell における自然性条件の自動性は「無料の定理」と関連しています。Haskell で自然変換を定義するために使用されるパラメトリック多相性は、すべての型にわたって一つの公式を課すという非常に強い制約を課します。これらの制約は、そのような関数に関する等式定理に変換されます。関手を変換する関数の場合、無料の定理は自然性条件です。\footnote{
  無料の定理についてもっと読むことができます
  ブログ \href{https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/}{``Parametricity:
    Money for Nothing and Theorems for Free}.''}

関手を Haskell で考える一つの方法は、それらを一般化されたコンテナと見なすことです。この類推を続けて、自然変換を考えることができます。それは一つのコンテナの内容を別のコンテナに再梱包するためのレシピです。我々はアイテム自体に触れてはいけません: 私たちはそれらを変更したり、新しいものを作成したりしてはいけません。私たちはただ、それらを新しいコンテナに (時には複数回) コピーするだけです。

自然性条件は、アイテムを最初に \code{fmap} を通して変更し、後で再梱包するか、あるいは最初に再梱包してから、新しいコンテナの独自の実装でアイテムを変更するか、どちらを行っても問題がないという声明です。これら二つのアクション、再梱包と \code{fmap} は直交しています。「一方は卵を動かし、もう一方はそれらを茹でます。」

Haskell での自然変換のいくつかの例を見てみましょう。最初は、リスト関手と \code{Maybe} 関手の間です。リストが空でない場合に限り、リストの先頭を返します: 

\src{snippet04}
これは \code{a} に多相的な関数です。それはどんな型 \code{a} に対しても制限なく機能するので、パラメトリック多相性の一例です。したがって、それは二つの関手間の自然変換です。しかし、自然性条件を確認するために、私たち自身を納得させるために、それを検証しましょう。

\src{snippet05}
考慮すべき二つのケースがあります。空リスト: 

\src{snippet06}

\src{snippet07}
そして空でないリスト: 

\src{snippet08}

\src{snippet09}
私はリストのための \code{fmap} の実装を使用しました: 

\src{snippet10}
そして \code{Maybe} のための: 

\src{snippet11}
興味深いケースは、関手の一つが自明な \code{Const} 関手である場合です。 \code{Const} 関手からまたはそれへの自然変換は、それが返り型で多相的であるか、引数型で多相的であるかのいずれかのように見える関数のようです。

例えば、\code{length} はリスト関手から \code{Const Int} 関手への自然変換として考えることができます: 

\src{snippet12}
ここで、\code{unConst} は \code{Const} コンストラクタを剥がすために使用されます: 

\src{snippet13}
もちろん、実際には \code{length} は次のように定義されています: 

\src{snippet14}
これは実際にそれが自然変換であるという事実を隠しています。

\code{Const} 関手からのパラメトリック多相的関数を見つけることは少し難しいかもしれません。それは何もないところから値を作り出す必要があるためです。最善を尽くせば: 

\src{snippet15}
私たちがすでに見たもう一つの一般的な関手は、\code{Reader} 関手です。私はそれの定義を\code{newtype}として書き直します: 

\src{snippet16}
それは二つの型によってパラメータ化されていますが、二つ目のものにのみ (共変的に) 関手的です: 

\src{snippet17}
あなたは任意の型 \code{e} に対して、\code{Reader e} から任意の他の関手 \code{f} への自然変換の族を定義することができます。後で見るように、この族のメンバーは常に \code{f e} の要素と一対一の対応関係にあります (\hyperref[the-yoneda-lemma]{米田の補題}) 。

例えば、要素 \code{()} を持つUnit型 \code{()} を考えてみましょう。関手 \code{Reader ()} は任意の型 \code{a} を関数型 \code{() -> a} に写像します。
これらは単に \code{a} の集合から単一の要素を選ぶすべての関数です。
\code{a} の要素と同じ数だけこれらが存在します。ここで、この関手から \code{Maybe} 関手への自然変換を考えてみましょう: 

\src{snippet18}
これらのうちの二つだけが、\code{dumb} と \code{obvious} です: 

\src{snippet19}
そして

\src{snippet20}
 (\code{g} でできる唯一のことは、それを単位値 \code{()} に適用することです。) 

そして確かに、米田の補題によって予測されるように、これらは \code{Maybe ()} 型の二つの要素、\code{Nothing} と \code{Just ()} に対応しています。後で米田の補題に戻ります --- これはちょっとした予告でした。

\section{自然性を越えて}

二つの関手 (\code{Const} 関手のエッジケースを含む) の間のパラメトリック多相的関数は常に自然変換です。すべての標準的な代数的データ型が関手であるため、そのような型間の多相的関数は自然変換です。

また、関数型を私たちの手元に持っています。これらは返り値の型で関手的です。私たちはそれらを関手 (\code{Reader} 関手のような) を構成し、高階関数である自然変換を定義するために使用することができます。

ただし、関数型は引数型で共変ではありません。\newterm{反変}です。もちろん反変関手は、逆圏からの共変関手に相当します。二つの反変関手間の多相的関数はまだ圏論的な意味で自然変換ですが、それは逆圏から Haskell 型への関手に対して機能します。

以前に見た反変関手の例を覚えているかもしれません: 

\src{snippet21}
この関手は \code{a} で反変です: 

\src{snippet22}
例えば、\code{Op Bool} から \code{Op String} への多相的関数を書くことができます: 

\src{snippet23}
しかし、二つの関手が共変でないため、これは $\Hask$ での自然変換ではありません。ただし、それらが共に反変であるため、「逆」の自然性条件を満たします: 

\src{snippet24}[b]
\code{f} は、\code{fmap} を使用する際に使用するものとは逆方向でなければならないことに注意してください。これは \code{contramap} の署名からです: 

\src{snippet25}
共変でも反変でもない型コンストラクタがありますか？ここに一つの例があります: 

\src{snippet26}
これは関手ではありません。なぜなら同じ型 \code{a} が負 (反変) と正 (共変) の位置の両方で使用されているためです。そのため、\code{fmap} や \code{contramap} をこの型のために実装することはできません。したがって、以下の署名を持つ関数: 

\src{snippet27}
ここで \code{f} は任意の関手で、自然変換にはなり得ません。興味深いことに、自然変換の一般化である、双自然変換と呼ばれるものが、このようなケースを扱います。私たちは、エンドについて議論する時に、それらについて説明します。

\section{関手圏}

関手間の写像 --- 自然変換 --- があると、関手が圏を形成するかという疑問が自然と生じます。そして実際、それらはします！圏のペアごとに一つの関手圏があります。この圏の対象は $\cat{C}$ から $\cat{D}$ への関手で、射はそれらの関手間の自然変換です。

二つの自然変換の合成を定義する必要がありますが、それはかなり簡単です。自然変換のコンポーネントは射であり、射の合成方法を知っています。

実際、関手 $F$ から $G$ への自然変換 $\alpha$ を取りましょう。対象 $a$ におけるそのコンポーネントは何らかの射です: 
\[\alpha_a \Colon F a \to G a\]
関手 $G$ から $H$ への自然変換 $\beta$ と $\alpha$ を合成したいと思います。$a$ における $\beta$ のコンポーネントは射です: 
\[\beta_a \Colon G a \to H a\]
これらの射は合成可能で、その合成は別の射です: 
\[\beta_a \circ \alpha_a \Colon F a \to H a\]
この射を自然変換 $\beta \cdot \alpha$ のコンポーネントとして使用します --- 二つの自然変換 $\beta$ の後に $\alpha$ の合成です: 
\[(\beta \cdot \alpha)_a = \beta_a \circ \alpha_a\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/5_vertical.jpg}
\end{figure}

\noindent
一つ (長い) 図を見るだけで、この合成が実際には $F$ から $H$ への自然変換であることが確信できます: 
\[H f \circ (\beta \cdot \alpha)_a = (\beta \cdot \alpha)_b \circ F f\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/6_verticalnaturality.jpg}
\end{figure}

\noindent
自然変換の合成は結合的です、なぜならそれらのコンポーネント、通常の射であり、その合成に関して結合的だからです。

最後に、各関手 $F$ には、そのコンポーネントが恒等射である自己恒等自然変換 $1_F$ があります: 
\[\id_{F a} \Colon F a \to F a\]
したがって、確かに、関手は圏を形成します。

表記法について一言。Saunders Mac Lane に従って、私は自然変換合成の種類について説明したばかりのものにドットを使用します。問題は、自然変換を合成する二つの方法があるということです。この一つは垂直合成と呼ばれます、なぜなら関手は通常、それを説明する図で縦に積み上げられるからです。垂直合成は関手圏を定義するのに重要です。間もなく水平合成について説明します。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/6a_vertical.jpg}
\end{figure}

\noindent
圏 $\cat{C}$ と $\cat{D}$ の間の関手圏は $\cat{Fun(C, D)}$、または $\cat{{[}C, D{]}}$、時には $\cat{D^C}$ と書かれます。この最後の表記は、関手圏自体が何らかの他の圏の関数対象 (指数関数) と見なされうることを示唆しています。これは実際にそうなのでしょうか？

これまでに構成してきた抽象化の階層を見てみましょう。我々は対象と射の集まりである圏から始めました。圏自体 (厳密には、対象が集合を形成する\emph{小さい}圏) は、より高次元の圏 $\Cat$ の対象です。その圏の射は関手です。$\Cat$ のホム集合は関手の集合です。例えば $\cat{Cat(C, D)}$ は圏 $\cat{C}$ と $\cat{D}$ の間の関手の集合です。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/7_cathomset.jpg}
\end{figure}

\noindent
関手圏 $\cat{{[}C, D{]}}$ もまた二つの圏間の関手の集合 (及び射としての自然変換) です。その対象は $\cat{Cat(C, D)}$ のメンバーと同じです。さらに、関手圏は、圏であるため、それ自体が $\Cat$ の対象でなければなりません (二つの小さい圏間の関手圏はそれ自体小さいです) 。我々は圏内のホム集合と同じ圏内の対象との間の関係を持っています。この状況は、前章で見た指数関数対象と全く同じです。$\Cat$ で後者をどのように構成するか見てみましょう。

指数関数を構成するためには、まず積を定義する必要があります。$\Cat$ では、これは比較的簡単です。なぜなら小さい圏は\emph{集合}の対象であり、集合のデカルト積を定義する方法を知っているからです。そのため、積圏 $\cat{C\times D}$ の対象は単に対象のペア、$(c, d)$で、一つは $\cat{C}$ から、もう一つは $\cat{D}$ からです。同様に、二つのそのようなペア、$(c, d)$ と $(c', d')$ の間の射は、射のペア、$(f, g)$で、$f \Colon c \to c'$ と $g \Colon d \to d'$ です。これらの射のペアはコンポーネントごとに合成され、常に恒等射のペアが存在します。それは単に恒等射のペアです。要するに、$\Cat$ はデカルト閉圏であり、そこには任意の圏のペアの指数関数対象があります。
そして「対象」によって $\Cat$ で意味するのは圏なので、$\cat{D^C}$ は圏です。これを圏 $\cat{C}$ と $\cat{D}$ の間の関手圏と同一視することができます。

\section{2-圏}

それで済んだとして、$\Cat$ をより詳細に見てみましょう。定義により、$\Cat$ の任意のホム集合は関手の集合です。しかし、我々が見てきたように、二つの対象間の関手は単なる集合以上の豊かな構造を持っています。それらは自然変換を射として持つ圏を形成します。関手が $\Cat$ の射と見なされる場合、自然変換は射間の射です。

この豊かな構造は、$\cat{2}$-圏の一例です。これは、対象と射 (この文脈では $1$-射と呼ばれるかもしれません) の他に、射間の射、つまり $2$-射がある圏の一般化です。

$\Cat$ を $\cat{2}$-圏と見なした場合、我々は持っています: 

\begin{itemize}
  \tightlist
  \item
        対象:  (小さい) 圏
  \item
        1-射: 圏間の関手
  \item
        2-射: 関手間の自然変換。
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/8_cat-2-cat.jpg}
\end{figure}

\noindent
圏 $\cat{C}$ と $\cat{D}$ の間のホム集合の代わりに、我々はホム圏、関手圏 $\cat{D^C}$ を持っています。我々は通常の関手合成を持っています: 圏 $\cat{D^C}$ からの関手 $F$ は、圏 $\cat{E^D}$ からの関手 $G$ と合成して $\cat{E^C}$ からの $G \circ F$ を与えます。しかし、我々はまた、各ホム圏内の合成を持っています --- 関手、または 2-射間の自然変換の垂直合成。

二つの合成がある $\cat{2}$-圏では、それらがどのように相互作用するかという問題が生じます。

$\Cat$ の二つの関手、または 1-射を選びましょう: 
\begin{gather*}
  F \Colon \cat{C} \to \cat{D} \\
  G \Colon \cat{D} \to \cat{E}
\end{gather*}
そしてそれらの合成: 
\[G \circ F \Colon \cat{C} \to \cat{E}\]
関手 $F$ と $G$ に作用する二つの自然変換、$\alpha$ と $\beta$ を持っていると仮定しましょう: 
\begin{gather*}
  \alpha \Colon F \to F' \\
  \beta \Colon G \to G'
\end{gather*}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/10_horizontal.jpg}
\end{figure}

\noindent
$\alpha$ のターゲットは $\beta$ のソースと異なるため、このペアに垂直合成を適用することはできません。実際、それらは二つの異なる関手圏のメンバーです: $\cat{D^C}$ と $\cat{E^D}$。しかし、$F'$ と $G'$ の関手に合成を適用することはできます。なぜなら $F'$ のターゲットは $G'$ のソース、つまり圏 $\cat{D}$ です。$G' \circ F'$ と $G \circ F$ の関係は何でしょうか？

$\alpha$ と $\beta$ を持っている場合、$G \circ F$ から $G' \circ F'$ への自然変換を定義できますか？構成をスケッチします。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/9_horizontal.jpg}
\end{figure}

\noindent
通常のように、圏 $\cat{C}$ の対象 $a$ から始めます。その像は $\cat{D}$ の二つの対象、$F a$ と $F'a$ に分裂します。また、$\alpha$ のコンポーネントであるこれら二つの対象をつなぐ射があります: 
\[\alpha_a \Colon F a \to F'a\]
$\cat{D}$ から $\cat{E}$ へ行くと、これら二つの対象はさらに四つの対象に分裂します: $G (F a)$、$G'(F a)$、$G (F'a)$、$G'(F'a)$。また、四つの射を形成する四角形もあります。これらの射のうち二つは自然変換 $\beta$ のコンポーネントです: 
\begin{gather*}
  \beta_{F a} \Colon G (F a) \to G'(F a) \\
  \beta_{F'a} \Colon G (F'a) \to G'(F'a)
\end{gather*}
他の二つは、関手による $\alpha_a$ の像です (関手は射を写像します) : 
\begin{gather*}
  G \alpha_a \Colon G (F a) \to G (F'a) \\
  G'\alpha_a \Colon G'(F a) \to G'(F'a)
\end{gather*}
多くの射があります。私たちの目標は、$G (F a)$ から $G'(F'a)$ への射を見つけることです。これは $G \circ F$ と $G' \circ F'$ の二つの関手をつなぐ自然変換のコンポーネントの候補です。実際には $G (F a)$ から $G'(F'a)$ への二つのパスがあります: 
\begin{gather*}
  G'\alpha_a \circ \beta_{F a} \\
  \beta_{F'a} \circ G \alpha_a
\end{gather*}
幸いにも、これらは等しいです。なぜなら、我々が形成した四角形は $\beta$ の自然性の四角形であるためです。

これで、$G \circ F$ から $G' \circ F'$ への自然変換のコンポーネントを定義しました。この変換の自然性の証明は、十分な忍耐があれば比較的簡単です。

この自然変換を $\alpha$ と $\beta$ の\newterm{水平合成}と呼びます: 
\[\beta \circ \alpha \Colon G \circ F \to G' \circ F'\]
再び、Mac Lane に従って水平合成のために小さい円を使用しますが、その代わりに星を使用することもあります。

ここで圏論的な経験則があります: 合成があるたびに、その圏を探すべきです。自然変換の垂直合成は、関手圏の一部です。しかし、水平合成についてはどうでしょうか？それはどの圏に属していますか？

これを理解する方法は、$\Cat$ を横から見ることです。自然変換を関手間の射としてではなく、圏間の射として考えます。自然変換は二つの圏、関手がつなぐそれらを間に置いています。私たちはそれをこれら二つの圏をつなぐものとして考えることができます。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/sideways.jpg}
\end{figure}

\noindent
$\Cat$ の二つの対象、圏 $\cat{C}$ と $\cat{D}$ に焦点を当てましょう。$\cat{C}$ につながる関手間の自然変換の集合があります。これらの自然変換は、$\cat{C}$ から $\cat{D}$ への我々の新しい射です。同じように、$\cat{D}$ から $\cat{E}$ へつながる関手間の自然変換があります。これらを $\cat{D}$ から $\cat{E}$ への新しい射として扱います。水平合成は、これらの射の合成です。

また、$\cat{C}$ から $\cat{C}$ への恒等射があります。それは $\cat{C}$ 上の恒等関手に自分自身をマッピングする恒等自然変換です。水平合成の恒等射は、垂直合成の恒等射でもありますが、逆は必ずしも真ではありません。

最後に、二つの合成は交換則を満たします: 
\[(\beta' \cdot \alpha') \circ (\beta \cdot \alpha) = (\beta' \circ \beta) \cdot (\alpha' \circ \alpha)\]
ここで、Saunders Mac Lane の言葉を引用します: この事実を証明するために必要な明白な図式を書き下すことを楽しむ読者がいるかもしれません。

さらに、将来的に役立つかもしれないもう一つの表記法があります。この新しい横向きの解釈の $\Cat$ で、対象から対象への二つの方法があります: 関手を使用するか、自然変換を使用するかです。しかし、我々は関手の矢印をこの関手に作用する恒等自然変換として特別な種類の自然変換として再解釈することができます。そのため、このような表記をよく見かけます: 
\[F \circ \alpha\]
ここで $F$ は圏 $\cat{D}$ から $\cat{E}$ への関手であり、$\alpha$ は圏 $\cat{C}$ から $\cat{D}$ への二つの関手間の自然変換です。関手と自然変換を合成することはできませんが、これは恒等自然変換 $1_F$ の後に $\alpha$ を水平合成すると解釈されます。

同様に: 
\[\alpha \circ F\]
は $\alpha$ の後に $1_F$ を水平合成すると解釈されます。

\section{結論}

これで本書の第一部が終わります。私たちは圏論の基本的な語彙を学びました。対象と圏を名詞として、射、関手、自然変換を動詞として考えることができます。射は対象をつなぎ、関手は圏をつなぎ、自然変換は関手をつなぎます。

しかし、我々はまた見てきましたが、あるレベルの抽象化での行為は、次のレベルでの対象となります。射の集合は関数対象に変わります。対象として、それは他の射のソースまたはターゲットになることができます。これが高階関数の背後にあるアイディアです。

関手は対象を対象に写像するので、私たちはそれを型コンストラクタまたはパラメトリック型として使用することができます。関手はまた射を写像するので、それは高階関数 --- \code{fmap} です。いくつかのシンプルな関手、例えば \code{Const}、積、余積は、多様な代数的データ型を生成するために使用することができます。関数型もまた関手的です、共変的にも反変的にも、そして代数的データ型を拡張するために使用することができます。

関手は、関手圏の対象と見なすことができます。そのようにして、彼らは射のソースとターゲットになります: 自然変換。自然変換は、特別なタイプの多相的関数です。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        \code{Maybe} 関手からリスト関手への自然変換を定義し、それに対する自然性条件を証明してください。
  \item
        \code{Reader ()} とリスト関手の間で少なくとも二つの異なる自然変換を定義してください。いくつ異なるリストの \code{()} が存在しますか？
  \item
        前の課題を \code{Reader Bool} と \code{Maybe} で続けてください。
  \item
        自然変換の水平合成が自然性条件を満たすことを示してください (ヒント: コンポーネントを使用します) 。図式を追う良い練習です。
  \item
        交換則を証明するために必要な明白な図式を書き下すことを楽しむかどうかについて短いエッセイを書いてください。
  \item
        異なる \code{Op} 関手間の変換の逆自然性条件のいくつかのテストケースを作成してください。一つの選択は以下の通りです: 

\begin{snip}{haskell}
op :: Op Bool Int
op = Op (\x -> x > 0)
\end{snip}
そして

\begin{snip}{haskell}
f :: String -> Int
f x = read x
\end{snip}
\end{enumerate}


