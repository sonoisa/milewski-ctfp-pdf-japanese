% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{私}{たち}はモノイドのいくつかの形式を見てきました: 集合として、単一対象圏として、モノイダル圏の対象として。このシンプルな概念から、どれだけ多くの知見を引き出すことができるでしょうか？

試してみましょう。集合$m$と一対の関数を用いたモノイドの定義を考えます: 
\begin{align*}
  \mu  & \Colon m\times{}m \to m \\
  \eta & \Colon 1 \to m
\end{align*}
ここで、1は$\Set$内の終対象 --- つまり単集合です。
最初の関数は乗算を定義しています (要素の対を取り、その積を返します)、二番目の関数は$m$から単位要素を選びます。この二つの関数の任意の選択がモノイドになるわけではありません。それには追加の条件、結合則と単位則が必要です。しかし、今はそれを忘れて「潜在的なモノイド」だけを考えてみましょう。関数の対は、二つの関数集合のデカルト積の要素です。これらの集合は指数対象として表現できることが知られています: 
\begin{align*}
  \mu  & \in m^{m\times{}m} \\
  \eta & \in m^1
\end{align*}
これら二つの集合のデカルト積は: 
\[m^{m\times{}m}\times{}m^1\]
高校の代数を使うと (これはデカルト閉圏でも機能します)、次のように書き換えられます: 
\[m^{m\times{}m + 1}\]
$+$記号は$\Set$内の余積を示します。我々はただ関数の対を単一の関数に置き換えただけです --- 集合の要素: 
\[m\times{}m + 1 \to m\]
この関数集合の任意の要素は潜在的なモノイドです。

この定式化の美しさは、それが興味深い一般化につながることです。例えば、この言語を使って群をどのように記述しますか？群は各要素に逆要素を割り当てる追加の関数を持つモノイドです。後者は$m \to m$という型の関数です。例えば、整数は加算を二項演算とし、ゼロを単位要素とし、否定を逆要素として群を形成します。群を定義するためには、関数の三つ組から始めます: 
\begin{align*}
  m\times{}m \to m \\
  m \to m          \\
  1 \to m
\end{align*}
以前と同様に、これらの三つ組を一つの関数集合に結合できます: 
\[m\times{}m + m + 1 \to m\]
私たちは一つの二項演算子 (加算)、一つの単項演算子 (否定)、一つの零項演算子 (恒等要素 --- ここではゼロ) で始めました。それらを一つの関数に結合しました。この署名を持つすべての関数は潜在的な群を定義します。

我々はこのように続けることができます。例えば、環を定義するためには、もう一つの二項演算子と一つの零項演算子を加えます、等々。毎回、我々は左辺がべきの和 (零次べきを含む可能性がある --- 終対象) であり、右辺が集合自体である関数型に終わります。

今、我々は一般化に狂うことができます。まず、集合を対象に置き換え、関数を射に置き換えることができます。我々はn項演算子をn項積からの射として定義できます。それは我々が有限積をサポートする圏を必要とすることを意味します。零項演算子については、終対象の存在を要求します。従って、我々はデカルト圏が必要です。これらの演算子を結合するためには、指数対象が必要です、それがデカルト閉圏です。最後に、我々の代数的ないたずらを完成させるために余積が必要です。

あるいは、我々は我々が導出した方法を忘れて、最後の積に集中することができます。射の左辺に関する積の和は自己関手を定義します。任意の自己関手$F$を選んだらどうでしょうか？その場合、我々は我々の圏に何の制約も課さなくてよいです。我々が得るものはF-代数と呼ばれます。

F-代数は自己関手$F$、対象$a$、そして射
\[F a \to a\]
からなる三つ組です。対象はしばしば台となる対象または、プログラミングの文脈では台となる\emph{型}と呼ばれます。射はしばしば評価関数または構造マップと呼ばれます。関手$F$は表現を形成し、射はそれらを評価すると考えてください。

こちらがF-代数のHaskell定義です: 

\src{snippet01}
これは代数をその評価関数と同一視します。

モノイドの例で、問題の関手は: 

\src{snippet02}
これはHaskellで$1 + a\times{}a$です (
\hyperref[simple-algebraic-data-types]{代数的データ構造}を思い出してください)。

環は以下の関手を使用して定義されます: 

\src{snippet03}
これはHaskellで$1 + 1 + a\times{}a + a\times{}a + a$です。

整数の集合の例は環です。我々は台となる型として\code{Integer}を選び、評価関数を定義することができます: 

\src{snippet04}
同じ関手\code{RingF}に基づくより多くのF-代数があります。例えば、多項式は環を形成し、正方行列もそうです。

関手の役割は、代数の評価者を使用して評価できる表現を生成することです。これまでに、我々は非常に単純な表現しか見ていません。我々はしばしば、再帰を使用して定義されるより複雑な表現に関心があります。

\section{再帰}

任意の表現ツリーを生成する一つの方法は、関手定義内の変数\code{a}を再帰的に置き換えることです。例えば、環内の任意の表現はこのツリー様のデータ構造によって生成されます: 

\src{snippet05}
我々は元の環評価者をその再帰バージョンで置き換えることができます: 

\src{snippet06}
これはまだ非常に実用的ではありません、なぜなら我々はすべての整数を一の和として表現する必要があるからです、しかし一つの方法としては機能します。

しかし、我々はF-代数を使用して表現ツリーをどのように記述することができますか？我々は、関手の定義における自由型変数を、置換の結果で再帰的に置き換えるプロセスを何らかの形で形式化する必要があります。このプロセスを段階的に想像してみてください。まず、次のような深さ1のツリーを定義します: 

\src{snippet07}
我々は\code{RingF a}によって生成される深さゼロのツリーで\code{RingF}の穴を埋めています。深さ2のツリーは同様に得られます: 

\src{snippet08}
我々はまた次のように書くこともできます: 

\src{snippet09}
このプロセスを続けると、我々は次のような記号的な方程式を書くことができます: 

\begin{snipv}
type RingF\textsubscript{n+1} a = RingF (RingF\textsubscript{n} a)
\end{snipv}
概念的には、このプロセスを無限回繰り返すと、最終的には\code{Expr}にたどり着きます。注目すべきは、\code{Expr}は\code{a}に依存しないことです。我々の旅の出発点は何であれ、我々は常に同じ場所に終わります。これは任意の自己関手について任意の圏で常に真であるわけではありませんが、圏$\Set$ではうまくいきます。

もちろん、これは手振りの議論ですが、後でそれをもっと厳密にするつもりです。

自己関手を無限回適用すると、\newterm{不動点}が生成されます。これは次のように定義される対象です: 
\[\mathit{Fix}\ f = f\ (\mathit{Fix}\ f)\]
この定義の直観は、$\mathit{Fix}\ f$を得るために無限回$f$を適用したので、もう一度適用しても何も変わらないということです。Haskellでの不動点の定義は: 

\src{snippet10}
おそらく、コンストラクタの名前が定義されている型の名前と異なる場合、より読みやすいでしょう、例えば: 

\src{snippet11}
しかし、私は受け入れられた表記に固執します。コンストラクタ\code{Fix} (あるいは、好みであれば\code{In}) は関数と見なすことができます: 

\src{snippet12}
関数があり、一つのレベルの関手適用を剥がすこともあります: 

\src{snippet13}
これらの二つの関数は互いに逆です。後でこれらの関数を使用します。

\section{F-代数の圏}

ここには本の中で最も古いトリックがあります: 新しいオブジェクトの構成法を考えたら、それらが圏を形成するかどうかを見てください。驚くべきことではありませんが、与えられた自己関手$F$に対する代数は圏を形成します。その圏の対象は代数 --- 元の圏$\cat{C}$からの対象$a$と射$F a \to a$からなるペアです。

この図を完成させるためには、F-代数の圏における射を定義する必要があります。射は一つの代数$(a, f)$から別の代数$(b, g)$へのマッピングでなければなりません。それを元の圏の対象から対象への射$m$として定義します。どんな射でも良いわけではありません: 我々はそれが二つの評価者と互換性を持つことを望みます。 (このような構造を保存する射を\newterm{準同型}と呼びます。) F-代数の準同型を定義する方法は次のとおりです。まず、$m$を次のマッピングにリフトすることができます: 
\[F m \Colon F a \to F b\]
それに続いて$b$への$g$を使用します。または、$F a$から$a$への$f$を使用し、それに続いて$m$を適用することもできます。二つのパスを等しいものとしたいです: 
\[g \circ F m = m \circ f\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/alg.png}
\end{figure}

\noindent
これが実際に圏であることを自分自身に確認するのは簡単です (ヒント: $\cat{C}$からの恒等射がうまく機能し、準同型の合成は準同型です)。

F-代数の圏における始対象が存在する場合、それは\newterm{初期代数}と呼ばれます。この初期代数の台を$i$、その評価者を$j \Colon F i \to i$と呼びましょう。実は$j$、初期代数の評価者は同型です。これはLambekの定理として知られています。証明は始対象の定義に依存します。それは任意の他のF-代数への唯一の準同型$m$が存在することを要求します。$m$が準同型であるので、以下の図式が可換でなければなりません: 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/alg2.png}
\end{figure}

\noindent
次に、台が$F i$であるような代数を構成しましょう。そのような代数の評価者は$F (F i)$から$F i$への射でなければなりません。我々は簡単に$j$をリフトすることでそのような評価者を構成することができます: 
\[F j \Colon F (F i) \to F i\]
$(i, j)$が初期代数であるので、$(F i, F j)$に対する唯一の準同型$m$が存在しなければなりません。以下の図式が可換でなければなりません: 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/alg3a.png}
\end{figure}

\noindent
しかし、我々はまたこの自明に可換な図式も持っています (両方のパスが同じです！) : 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/alg3.png}
\end{figure}

\noindent
これを、$(F i, F j)$から$(i, j)$への代数の準同型として$j$をマッピングするものとして解釈することができます。我々はこれら二つの図式を一緒に接着して、次のように得ることができます: 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{images/alg4.png}
\end{figure}

\noindent
この図式は、$j \circ m$が代数の準同型であることを示していると解釈することができます。この場合、二つの代数は同じです。さらに、$(i, j)$が初期であるので、それ自体に対しては唯一の準同型が存在し、それが恒等射$\id_i$です --- これは代数の準同型です。したがって$j \circ m = \id_i$です。この事実と左図の可換性を使用して、$m \circ j = \id_{Fi}$を証明することができます。これは$m$が$j$の逆であり、したがって$j$は$F i$と$i$の間の同型です: 
\[F i \cong i\]
しかし、それはただ$i$が$F$の不動点であると言っているだけです。
それが元の手振りの議論の背後にある公式的な証明です。

Haskellに戻ると: 我々は$i$を我々の\code{Fix f}、$j$を我々のコンストラクタ\code{Fix}、その逆を\code{unFix}と認識します。Lambekの定理の同型は、初期代数を得るためには関手$f$を取り、その引数$a$を\code{Fix f}に置き換えると教えてくれます。また、不動点が$a$に依存しない理由もわかります。

\section{自然数}

自然数もF-代数として定義できます。出発点は次の二つの射です: 
\begin{align*}
  zero & \Colon 1 \to N \\
  succ & \Colon N \to N
\end{align*}
最初の射はゼロを選び、二番目の射は全ての数をその後者に写像します。以前と同様に、これら二つを一つに組み合わせることができます: 
\[1 + N \to N\]
左辺はHaskellで次のように書くことができる関手を定義します: 

\src{snippet14}
この関手の不動点 (それが生成する初期代数) はHaskellで次のようにエンコードできます: 

\src{snippet15}
自然数はゼロか他の数の後者のどちらかです。これは自然数のペアノ表現として知られています。

\section{カタモルフィズム}

初期性条件をHaskellの記法を使って書き直しましょう。初期代数を\code{Fix f}と呼び、その評価者をコンストラクタ\code{Fix}とします。初期代数から同じ関手上の任意の他の代数への唯一の射\code{m}が存在します。キャリアが\code{a}で評価者が\code{alg}である代数を選びましょう。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/alg5.png}
\end{figure}

\noindent
ところで、\code{m}とは何かに注意してください: それは不動点の評価者、すなわち全体の再帰的表現ツリーの評価者です。それを実装する一般的な方法を見つけましょう。

Lambekの定理は、コンストラクタ\code{Fix}が同型であることを教えてくれます。私たちはその逆を\code{unFix}と呼びました。したがって、この図の一つの射を反転させることができます: 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/alg6.png}
\end{figure}

\noindent
この図の交通条件を書き下しましょう: 

\begin{snip}{haskell}
m = alg . fmap m . unFix
\end{snip}
この方程式を\code{m}の再帰的定義として解釈することができます。この再帰は関手\code{f}を使用して構成された任意の有限ツリーに対して終了する必要があります。それは\code{fmap m}が関手\code{f}の最上層の下で動作することに気づくことでわかります。言い換えれば、それは元のツリーの子に作用します。子は常に元のツリーより一つレベルが浅いです。

\code{m}を\code{Fix f}を使用して構成されたツリーに適用すると、次のようなことが起こります。\code{unFix}の作用はコンストラクタを剥がし、ツリーの最上層を露出させます。それから、私たちはトップノードの全ての子に\code{m}を適用します。これは\code{a}型の結果を生成します。最後に、非再帰的評価者\code{alg}を適用することによってこれらの結果を結合します。重要な点は、私たちの評価者\code{alg}が単純な非再帰的関数であることです。

任意の代数\code{alg}に対してこれを行うことができるので、代数をパラメータとして取り、私たちが\code{m}と呼んだ関数を与える高階関数を定義することは理にかなっています。この高階関数はカタモルフィズムと呼ばれます: 

\src{snippet16}
それがどのように機能するかの例を見てみましょう。自然数を定義する関手を取ります: 

\src{snippet17}
キャリア型として\code{(Int, Int)}を選び、私たちの代数を次のように定義しましょう: 

\src{snippet18}
簡単に自分自身を納得させることができるでしょう、カタモルフィズム\code{cata fib}はフィボナッチ数を計算します。

一般的に、\code{NatF}の代数は、現在の要素の値を前の要素の値の観点から定義する漸化式を定義します。カタモルフィズムはそのシーケンスのn番目の要素を評価します。

\section{畳み込み}

\code{e}のリストは以下の関手の初期代数です: 

\src{snippet19}
実際、変数\code{a}を再帰の結果で置き換えると、次のようになります: 

\src{snippet20}
リスト関手の代数は、特定のキャリア型を選び、二つのコンストラクタに対するパターンマッチングを行う関数を定義します。その\code{NilF}の値は空リストを評価する方法を教えてくれ、その\code{ConsF}の値は現在の要素を以前に蓄積された値と組み合わせる方法を教えてくれます。

例えば、リストの長さを計算するために使用できる代数は次のとおりです (キャリア型は\code{Int}です) : 

\src{snippet21}
実際、結果のカタモルフィズム\code{cata lenAlg}はリストの長さを計算します。評価者は (1) リスト要素と累積器を取り、新しい累積器を返す関数と (2) ここではゼロである開始値の組み合わせです。値の型と累積器の型はキャリア型によって与えられます。

これを伝統的なHaskellの定義と比較してみてください: 

\src{snippet22}
\code{foldr}への二つの引数はまさに代数の二つのコンポーネントです。

別の例を試してみましょう: 

\src{snippet23}
再び、これを比較してください: 

\src{snippet24}
ご覧のとおり、\code{foldr}はリストに対するカタモルフィズムの便利な特殊化に過ぎません。

\section{余代数}

通常どおり、我々はF-余代数の双対構造を持っています。ここでは射の方向が逆転します: 
\[a \to F a\]
与えられた関手の余代数も圏を形成し、余代数構造を保つ準同型があります。その圏の終対象$(t, u)$は終 (または最終) 余代数と呼ばれます。他の代数$(a, f)$に対しては、次の図式を可換にする唯一の準同型$m$が存在します: 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/alg7.png}
\end{figure}

\noindent
終余代数は、射$u \Colon t \to F t$が同型であるという意味で関手の不動点です (余代数のためのLambekの定理) : 
\[F t \cong t\]
終余代数は通常、 (無限に) データ構造や遷移システムを生成するレシピとしてプログラミングで解釈されます。

カタモルフィズムが初期代数を評価するために使用されるように、アナモルフィズムは終余代数を共評価するために使用されます: 

\src{snippet25}
余代数の標準的な例は、その不動点が型\code{e}の要素の無限ストリームである関手に基づいています。これがその関手です: 

\src{snippet26}
そして、これがその不動点です: 

\src{snippet27}
\code{StreamF e}の余代数は、型\code{a}の種を取り、要素と次の種からなるペア (\code{StreamF}はペアのファンシーな名前です) を生成する関数です。

簡単な余代数の例は、平方数のリストや逆数のリストを生成するものを簡単に生成できます。

より興味深い例は、素数のリストを生成する余代数です。トリックは無限リストをキャリアとして使用することです。私たちの開始種はリスト\code{{[}2..{]}}です。次の種はこのリストの尾であり、すべての2の倍数が除去されます。それは3から始まる奇数のリストです。次のステップでは、このリストの尾を取り、すべての3の倍数を除去します、そして以下同様です。あなたはエラトステネスの篩の始まりを認識するかもしれません。この余代数は次の関数によって実装されます: 

\src{snippet28}
この余代数のアナモルフィズムは素数のリストを生成します: 

\src{snippet29}
ストリームは無限リストなので、それをHaskellリストに変換することが可能です。それを行うために、私たちは同じ関手\code{StreamF}を使用して代数を形成し、それにカタモルフィズムを走らせることができます。例えば、これはストリームをリストに変換するカタモルフィズムです: 

\src{snippet30}
ここでは、同じ不動点が同じ自己関手の初期代数と終余代数の両方で同時に使用されています。任意の圏では必ずしもこのようになるわけではありません。一般に、自己関手は多くの (または無い) 不動点を持つことがあります。初期代数はいわゆる最小不動点であり、終余代数は最大不動点です。しかし、Haskellでは両方とも同じ式で定義されており、一致します。

リストのためのアナモルフィズムはunfoldと呼ばれます。有限リストを作成するためには、関手は\code{Maybe}ペアを生成するように変更されます: 

\src{snippet31}
\code{Nothing}の値はリストの生成を終了します。

レンズに関連する余代数の興味深いケースがあります。レンズは取得関数と設定関数のペアとして表されることがあります: 

\src{snippet32}
ここで、\code{a}は通常、型\code{s}のフィールドを持ついくつかの積データ型です。取得関数はそのフィールドの値を取得し、設定関数はそのフィールドを新しい値で置き換えます。これら二つの関数は一つに結合することができます: 

\src{snippet33}
この関数をさらに次のように書き換えることができます: 

\src{snippet34}
ここで、関手を定義しました: 

\src{snippet35}
注意してください、これは積の和から構成される単純な代数的関手ではありません。それは指数$a^s$を含んでいます。

レンズはこの関手の余代数であり、キャリア型は\code{a}です。前に見たように、\code{Store s}はまた余モナドでもあります。うまく動作するレンズは、余モナド構造と互換性のある余代数に対応します。これについては次のセクションで話しましょう。

\section{チャレンジ}

\begin{enumerate}
  \tightlist
  \item
        一変数の多項式の環の評価関数を実装してください。例えば、$4x^2-1$は (ゼロ次のべきで始まる) \code{{[}-1, 0, 4{]}}として表されるような、$x$のべきの前の係数のリストとして多項式を表現できます。
  \item
        前の構造を多くの独立変数の多項式に一般化してください、例えば$x^2y-3y^3z$。
  \item
        $2\times{}2$行列の環の代数を実装してください。
  \item
        自然数の平方のリストを生成する余代数の定義。
  \item
        \code{unfoldr}を使用して最初の$n$個の素数のリストを生成してください。
\end{enumerate}


