% !TEX root = ../../ctfp-print.tex

\begin{quote}
  私はしばらくの間、プログラマ向けの圏論の本を書くというアイディアを温めてきました。ここで言うプログラマとは、科学者ではなくエンジニア --- 具体的にはコンピュータ科学者ではなく、現場の技術者を指します。これが狂気に聞こえるかもしれませんが、私は正気です。科学と工学の間には大きな隔たりがあるということは否定できませんが、私は常に物事を説明する強い衝動を感じてきました。Richard Feynmanがシンプルな説明の達人であることに大きな敬意を払っています。私はFeynmanではありませんが、最善を尽くすつもりです。この序文を公開することで --- これは読者に圏論を学ぶ動機を与えるためのものです --- 議論を開始し、フィードバックを募ることを期待しています。\footnote{
    私がこの素材をライブオーディエンスに教えるのを視聴することもできます。\href{https://goo.gl/GT2UWU}{https://goo.gl/GT2UWU} で検索するか、「bartosz milewski category theory」でYouTubeを検索してください。}
\end{quote}

\lettrine[lhang=0.17]{私}{は}数段落のスペースを使って、この本があなたのために書かれたものであり、あなたが「豊富な余暇」に最も抽象的な数学分野の一つを学ぶべきではないというどんな反論も根拠がないことを納得させようと試みます。

私の楽観はいくつかの観察に基づいています。まず、圏論は非常に有用なプログラミングのアイデアの宝庫です。Haskellプログラマは長い間このリソースを利用してきましたが、そのアイデアはゆっくりと他の言語に浸透していますが、このプロセスは遅すぎます。私たちはそれを加速させる必要があります。

次に、数学には様々な種類があり、それぞれ異なる聴衆を惹きつけます。あなたは微積分や代数にアレルギーを持っているかもしれませんが、だからといって圏論を楽しめないわけではありません。私は圏論が特にプログラマの頭脳に適した数学であるとさえ主張したいです。それは圏論が --- 特定のものではなく --- 構造を扱うからです。プログラムを合成可能にする種類の構造を扱います。

合成は圏論の根本にあります --- それは圏自体の定義の一部です。そして私は、プログラミングの本質が合成であると強く主張します。私たちは、優れたエンジニアがサブルーチンのアイデアを思いつくずっと前から、ずっと物事を合成してきました。しばらく前、構造化プログラミングの原理がプログラミングを革命的に変えました。それはコードブロックを合成可能にしました。次にオブジェクト指向プログラミングが登場しましたが、それはオブジェクトの合成に関するものです。関数型プログラミングは、関数と代数的データ構造の合成だけでなく、並行性の合成も可能にします。これは他のプログラミングパラダイムではほぼ不可能です。

第三に、私には秘密兵器、数学をプログラマにとってより消化しやすくするための肉切り包丁があります。あなたがプロの数学者であれば、仮定をきちんと整理し、言明を適切に述べて、証明を厳密に構築する必要があります。これにより、数学の論文や本は外部の人にとって非常に読みにくくなります。私は訓練を受けた物理学者であり、物理学では非公式な推論を使用して驚くべき進歩を遂げてきました。数学者はDiracのデルタ関数を笑いましたが、それは偉大な物理学者P. A. M. Diracによって、いくつかの微分方程式を解くためにその場で作られました。彼らがDiracの洞察を形式化した完全に新しい微積分の分野である超関数理論 (distribution theory) を発見したとき、彼らは笑うのをやめました。

もちろん、噛み砕いた説明を用いることで明らかに間違ったことを言うリスクがありますので、この本の非公式な議論の背後にはしっかりとした数学的理論があることを確かめるようにします。私はSaunders Mac Laneの\emph{Categories for the Working Mathematician (邦訳: 圏論の基礎)}の使い古されたコピーを持っています。

これは\emph{プログラマのための}圏論であるため、私はすべての主要な概念をコンピュータコードを使用して説明します。あなたはおそらく、関数型言語がより一般的な命令型言語よりも数学に近いことを知っているでしょう。それはまた、より多くの抽象化力を提供します。従って、圏論の恩恵を受ける前にHaskellを学ぶ必要があると言いたくなるのは当然かもしれません。しかし、それでは圏論が関数型プログラミング以外に適用できないことを意味することになり、ただ単に正しくありません。従って、私は多くのC++の例を提供します。確かに、あなたはいくつかの醜い構文を克服する必要があります。パターンが冗長性の背景から際立たないかもしれませんし、高度な抽象化の代わりにコピーアンドペーストを強いられるかもしれませんが、それはC++プログラマの宿命です。

しかし、Haskellに関してあなたは無関係でいられません。Haskellプログラマになる必要はありませんが、C++で実装されるアイデアをスケッチし、文書化する言語としてそれを必要とします。それはちょうど私がHaskellを始めた方法です。私は、その簡潔な構文と強力な型システムがC++テンプレート、データ構造、およびアルゴリズムの理解と実装に大いに役立つことを発見しました。しかし、読者がすでにHaskellを知っていると期待することはできませんので、ゆっくりと導入し、進むにつれてすべてを説明します。

経験豊富なプログラマであれば、あなたは自分自身に尋ねているかもしれません: 長い間、圏論や関数型の方法について心配することなくコーディングしてきましたが、何が変わったのでしょうか？あなたは間違いなく、命令型言語に新しい関数型の機能が侵入してくる一貫した流れに気付いているはずです。オブジェクト指向プログラミングの砦であるJavaでさえ、ラムダを受け入れました。C++は最近、急速なペースで進化しており --- 数年ごとに新しい標準が出ています --- 変化する世界に追いつこうとしています。このすべての動きは、破壊的な変化、または私たち物理学者がそれを呼ぶように、相転移に備えるためのものです。あなたが水を加熱し続けると、最終的には沸騰を始めます。私たちは現在、ますます熱くなる水の中で泳ぎ続けるべきか、何らかの代替手段を探し始めるべきかを決定するカエルの立場にあります。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/img_1299.jpg}
\end{figure}

\noindent
この大きな変化を推進する力の一つはマルチコア革命です。支配的なプログラミングパラダイムであるオブジェクト指向プログラミングは、並行性と並列性の領域で何の助けも与えてくれません。その代わりに、危険でバグのある設計を奨励します。オブジェクト指向の大前提であるデータの隠蔽は、データの共有と変更と組み合わせると、データ競合の原因となります。データを保護するためにロックを組み合わせるアイデアは良いですが、残念ながら、ロックは合成できませんし、ロックの隠蔽はデッドロックをより起こりやすくし、デバッグを困難にします。

しかし、並行性がなくても、ソフトウェアシステムの成長し続けている複雑さは、命令型パラダイムのスケーラビリティの限界を試しています。単純に言えば、副作用は手に負えなくなっています。副作用を持つ関数はしばしば便利で書きやすいものです。それらの効果は原則として、それらの名前やコメントにエンコードされます。SetPasswordやWriteFileという関数は明らかに何らかの状態を変更し、副作用を生成していることがわかりますが、副作用を持つ関数を他の副作用を持つ関数の上に合成し、といったことを続けると、物事は複雑になり始めます。副作用が根本的に悪いわけではありません --- 隠された副作用が大規模な管理が不可能になる原因です。副作用はスケールしないし、命令型プログラミングとは副作用がすべてです。

ハードウェアの変化とソフトウェアの複雑さの増大は、プログラミングの基盤を再考することを強いています。ヨーロッパの偉大なゴシック大聖堂の建設者たちのように、私たちは物質と構造の限界に挑むために技術を磨いてきました。フランスのボーヴェにある未完成のゴシック\urlref{http://en.wikipedia.org/wiki/Beauvais_Cathedral}{大聖堂}は、この限界との深い人間的な闘いの証人です。それはすべての以前の記録を高さと軽さで打ち負かすことを意図していましたが、度重なる崩壊に見舞われました。鉄の棒や木製の支えが崩壊から守っていますが、明らかに多くの問題があります。現代の視点から見れば、近代的な材料科学、コンピュータモデリング、有限要素法、そして一般的な数学や物理学の助けなしに多くのゴシック建築が成功裏に完成したことは奇跡です。私は将来の世代が、複雑なオペレーティングシステム、ウェブサーバー、そしてインターネットインフラストラクチャを構築するために私たちが見せているプログラミング技術に同じように感心することを望みます。そして、正直に言って、彼らはそうすべきです。なぜなら、私たちは非常に脆弱な理論的基盤に基づいてこれらを行ってきたからです。私たちは前進したいのであれば、それらの基盤を修正する必要があります。

\begin{figure}
  \centering
  \includegraphics[totalheight=0.5\textheight]{images/beauvais_interior_supports.jpg}
  \caption{ボーヴェ大聖堂の崩壊を防ぐための場当たり的な措置}
\end{figure}
